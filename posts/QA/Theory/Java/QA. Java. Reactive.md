 ## QA. 1

#### Что такое реактивное программирование?

Реактивное программирование — это подход, который подразумевает создание и управление асинхронными потоками данных. Он также предполагает собой обработку данных по мере их поступления и реагирование на события в режиме реального времени. Вместо того чтобы писать код, который последовательно выполняет шаги (как в императивном программировании), ты описываешь, как данные должны реагировать на изменения.

2. Какие основные принципы лежат в основе реактивного программирования?

- **Потоки данных (Streams)**: Данные представляются в виде потоков, которые могут изменяться со временем.
- **Реактивность**: Автоматическое обновление данных при изменении их источников.
- **Асинхронность**: Операции могут выполняться параллельно, без блокировки основного потока выполнения.
- **Композиция**: Потоки можно комбинировать, фильтровать, трансформировать и т.д., чтобы создавать сложные цепочки обработки данных.

3. В чем преимущества реактивного программирования перед императивным программированием?

Императивный подход предполагает, что программа состоит из инструкций, которые должны исполняться последовательно для достижения нужного результата. То есть разработчик работает с описанием того, как программе выполнить задачу.

Реактивное программирование же, скорее, относится к декларативному подходу, так как акцент делается на том, чего нужно достичь в результате. Определяются потоки данных и реакции на события, вследствие чего программа может автоматически реагировать на изменения.

4. Как реализуется асинхронность в реактивном программировании?

Асинхронность в реактивном программировании реализуется через использование потоков данных (Streams) и подписок (Subscriptions). Когда данные изменяются, подписчики автоматически получают уведомления и обрабатывают новые данные. Это позволяет выполнять операции без блокировки основного потока выполнения, что особенно полезно в многопоточных и распределенных системах.

5. Какие существуют популярные библиотеки для реактивного программирования на Java?

- **Reactor**: Библиотека, разработанная Pivotal, которая используется в Spring WebFlux.
- **RxJava**: Реализация Reactive Extensions для Java.
- **Akka**: Фреймворк для создания реактивных систем, поддерживающий акторную модель.
- **Vert.x**: Легковесный фреймворк для создания реактивных приложений.

6. Какие паттерны проектирования часто используются в реактивном программировании?

- **Observer (Наблюдатель)**: Используется для подписки на изменения в потоках данных.
- **Publisher/Subscriber**: Паттерн, где издатель (Publisher) отправляет данные подписчикам (Subscribers).
- **Reactive Streams**: Стандарт для асинхронной обработки потоков данных с обратной связью.
- **Circuit Breaker (Предохранитель)**: Используется для обработки ошибок и предотвращения каскадных сбоев.

7. Как реализуется backpressure в реактивном программировании и зачем он нужен?

Backpressure — это механизм, который позволяет подписчику контролировать скорость получения данных от издателя. Это нужно, чтобы избежать перегрузки подписчика, если издатель генерирует данные быстрее, чем подписчик может их обработать. В реактивном программировании backpressure реализуется через протоколы, такие как Reactive Streams, где подписчик может запросить определенное количество данных.

8. Какие есть стратегии обработки ошибок в реактивном программировании?

- **Retry (Повтор)**: Повторная попытка выполнить операцию при возникновении ошибки.
- **Fallback (Резервный вариант)**: Использование альтернативного источника данных или операции в случае ошибки.
- **Circuit Breaker (Предохранитель)**: Временное прекращение выполнения операций при частых ошибках, чтобы дать системе время на восстановление.
- **Error Handling (Обработка ошибок)**: Перехват и обработка ошибок с помощью специальных операторов, таких как `onErrorResume` или `onErrorReturn`.

9. Как реализовать реактивный доступ к данным в приложениях на Java?

- **Reactive Repositories**: В Spring Data есть поддержка реактивных репозиториев, которые возвращают потоки данных (Flux/Mono).
- **Reactive Database Drivers**: Например, драйверы для MongoDB, Cassandra или PostgreSQL, которые поддерживают реактивный доступ.
- **Reactive Streams API**: Использование библиотек, таких как Reactor или RxJava, для работы с потоками данных.

10. Что такое реактивная система?

Реактивная система — это архитектурный подход к созданию распределенных систем, которые остаются отзывчивыми, устойчивыми, эластичными и ориентированными на сообщения даже под нагрузкой или в условиях сбоев. Такие системы способны адаптироваться к изменениям и обеспечивать высокую доступность.

11. Перечислите четыре основные характеристики реактивных систем, описанные в манифесте.

**Отзывчивость (Responsive)**: Система быстро реагирует на запросы.
**Устойчивость (Resilient)**: Система остается работоспособной даже при сбоях.
**Эластичность (Elastic)**: Система может масштабироваться в зависимости от нагрузки.
**Ориентированность на сообщения (Message-Driven)**: Компоненты системы взаимодействуют через асинхронные сообщения.

16. Почему важно, чтобы система была отзывчивой?

Отзывчивость важна, потому что она обеспечивает быстрое взаимодействие с пользователем и другими системами. Это особенно критично в реальном времени, где задержки могут привести к ухудшению пользовательского опыта или даже к финансовым потерям.

17. Как принцип устойчивости реализуется в реактивных системах?

Устойчивость реализуется через изоляцию компонентов, использование механизмов восстановления (например, Circuit Breaker) и репликацию данных. Если один компонент системы выходит из строя, это не должно влиять на работу всей системы.

18. В чем разница между реактивным программированием и реактивными системами?

Реактивное программирование — это подход к написанию кода, который реагирует на изменения данных. Реактивные системы — это архитектурный подход к созданию распределенных систем, которые остаются отзывчивыми, устойчивыми и эластичными. Реактивное программирование может быть частью реактивной системы, но не исчерпывает её.

19. Какие преимущества дает использование реактивного манифеста при проектировании систем?

- **Гибкость**: Система может адаптироваться к изменениям нагрузки и сбоям.
- **Масштабируемость**: Легко масштабировать отдельные компоненты системы.
- **Надежность**: Устойчивость к сбоям и быстрая реакция на ошибки.
- **Производительность**: Высокая отзывчивость и эффективное использование ресурсов.

20. Какие шаблоны проектирования наиболее подходят для реализации реактивных систем?

- **Actor Model (Акторная модель)**: Используется для изоляции компонентов и асинхронного взаимодействия.
- **Event Sourcing (Хранение событий)**: Сохранение состояния системы как последовательности событий.
- **CQRS (Command Query Responsibility Segregation)**: Разделение операций записи и чтения данных.
- **Circuit Breaker (Предохранитель)**: Для предотвращения каскадных сбоев.

21. Опишите, как принцип изоляции отказов способствует повышению отзывчивости системы.

Изоляция отказов означает, что сбой в одном компоненте системы не влияет на работу других компонентов. Это позволяет системе оставаться отзывчивой, даже если часть её компонентов временно недоступна или работает с ошибками. Например, если один микросервис падает, другие продолжают работать, и система в целом остается доступной.

22. Как реактивные системы обеспечивают гибкое масштабирование и управление ресурсами?

Реактивные системы используют асинхронные сообщения и эластичные компоненты, которые могут автоматически масштабироваться в зависимости от нагрузки. Например, если нагрузка на систему увеличивается, можно добавить дополнительные экземпляры компонентов, чтобы распределить нагрузку. Управление ресурсами осуществляется через механизмы, такие как backpressure, которые предотвращают перегрузку системы.

23. Что такое Netty и Event Loop?

**Netty** — это библиотека на Java для создания сетевых приложений (например, серверов), которая эффективно обрабатывает множество одновременных подключений. Она использует **Event Loop** — механизм, позволяющий одному потоку управлять множеством задач без блокировок.

**Event Loop** — это бесконечный цикл внутри потока, который:

- Следит за событиями (новые подключения, данные от клиентов).
- Передаёт их на обработку (например, в ваши функции-обработчики).
- Не блокирует поток, если задача требует ожидания (например, чтение из сети).

![](Pasted%20image%2020250213053141.png)

#### В чем разница между Hot и Cold publishers?

[Реактивные типы](Реактивные%20типы.md)

#### В чем отличие асинхронного и реактивного подхода?

- **Асинхронный подход** — это способ выполнения задач без блокировки потока, но без управления потоками данных.
- **Реактивный подход** — это парадигма, которая строится вокруг потоков данных и реакций на их изменения, с поддержкой backpressure и встроенной обработкой ошибок.

#### publishOn vs subscribeOn

- **`subscribeOn`** :
    - Определяет, на каком потоке будет выполняться подписка (subscription) на источник данных. 
    - Влияет на то, где происходит выполнение всей цепочки до первого вызова `publishOn`.
    - Обычно используется для управления потоком, на котором запускается работа с источником данных (например, чтение из базы данных, сетевые запросы).
- **`publishOn`** :
    - Определяет, на каком потоке будут выполняться операции после вызова `publishOn`.
    - Влияет только на ту часть цепочки, которая следует за ним.
    - Используется для изменения потока выполнения операций в середине или конце цепочки.


#### zip, concat, merge

 **Zip will wait for each publisher emit one element** to combine them.
 
![](image.webp)

**Concat**. The difference between concat and merge is that concat, the first publisher is terminated and the other stream is just concatenated at the end of it. In other words, concat reads one publisher completely and then appends the second one at the end of the flow. The first important point is that the sequence order is respected. Another point is that the operation is layz, which means that the second publisher will only subscribe after the conclusion of the first stream.

![](image-2.webp)

Unlike concat, merge is considered an eager operation where all publishers subscribe simultaneously. The resulting order is not guaranteed, as it simply collects and emits data as soon as it becomes available from any publisher.

![](image-1.webp)

#### Стратегии backpressure

- `IGNORE` – Ignores downstream requests and pushes the data anyway. That may result in `IllegalStateException` so think twice before using it!
- `ERROR` – throws `IllegalStateException` if the downstream can’t keep up.
- `DROP` – drops the signal if the downstream can’t receive it.
- `LATEST` – only allows the latest signal from upstream.
- `BUFFER` – the default – buffers all signal until you run out of memory.

###### Что является подписчиком в WebFlux?

###### Ограничен ли Flux как-то из коробки? Или мы можем их БД доставать данные сколько угодно? Что будет если мы 10_000_000_000 записей пихнем во Flux?

###### Что для нас значит, если мы будем использовать .concatMap() вместо .flatMap() и .map()

###### В чем преимущество WebFlux?

###### В чем отличие несинхронной обработки запроса и неблокирующей реактивной обработки?



## QA. 2

###### Какие задачи реализовывались на WebFlux?

## QA. 3


## Задачи

##### Если у нас фронт запросил какие-то данные. Эти данные качаются через webClient. 

- Затем фронт у нас оборвал соединение. Что будет с webClient? Перестанет качать данные или продолжит потому что он отдельный поток?
- Можно ли прервать скачку данных с уровня контроллера?
- Можно ли запараллерить обработку в рамках запроса?

## Resources

- [difference between zip, merge and concat](https://victorpongolino.com/project-reactor-the-difference-between-zip-merge-and-concat-operation/)
- 
