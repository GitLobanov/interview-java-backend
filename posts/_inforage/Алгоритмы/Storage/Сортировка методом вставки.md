---
Определение: Нам нужен маркер в виде числа, просто второе число в массиве для начала.  Затем сравниваем его с левым числом. Если меньше, сдвигаем левое число в правую сторону, ставим за место него маркерное. Затем берем новый маркер - уже третье число ряда (просто следующее не использованное). Сравниваем его с левой стороной, постепенно перемещая его, перенося элементы в право (если маркер меньше). Ставим его на положенное место, затем снова берем новый маркер и так далее.
Примечание: Данный вид сортировки превосходит вышеописанные, так как несмотря на то, что время работы такое же — O(N²), этот алгоритм работает вдвое быстрее пузырьковой сортировки и немного быстрее сортировки выбором.
---
```java
public class Solution {
   public static void main(String[] args) {
       int[] testArr = new int[]{6, 3, 8, 8, 6, 9, 4, 11, 1};
       insertionSort(testArr);
       for (int i : testArr) {
           System.out.println(i);
       }
   }

   public static void insertionSort(int[] array) {

       for (int i = 1; i < array.length; i++) { // i - разделяющий маркер
           int temp = array[i]; // делаем копию помеченного элемента
           int j = i;
           while (j > 0 && array[j - 1] >= temp) { // пока не будет найден меньший элемент
               array[j] = array[j - 1]; // сдвигаем элементы вправо
               --j;
           }
           array[j] = temp;   // вставляем отмеченный элемент, в положеное ему место
       }
   }
}
```


![[../../../_res/Pasted image 20240924110105.png]]

# Асимптотическая сложность

Асимптотическая сложность алгоритма **сортировки вставками (Insertion Sort)** зависит от упорядоченности входных данных. Рассмотрим основные случаи:

1. **Худший случай (O(n²))**:

В худшем случае, когда массив отсортирован в обратном порядке, сортировка вставками должна переместить каждый элемент в начало списка, сравнивая его с каждым предыдущим элементом. Это приводит к тому, что на каждом шаге требуется i сравнений для вставки элемента на правильное место, где i — номер шага (позиция элемента):

- Первый элемент требует 0 сравнений.
- Второй элемент требует 1 сравнения.
- Третий элемент требует 2 сравнений.
- И так далее...

Таким образом, сложность в **худшем случае** — O(`n^2`).

2. **Лучший случай (O(n))**:

В лучшем случае, если массив уже отсортирован, алгоритм будет проверять каждый элемент и находить, что каждый следующий элемент уже находится на правильной позиции, без необходимости перемещений. Для каждого элемента будет выполнено всего одно сравнение, и общее количество операций составит n−1n-1n−1:

O(n)

Таким образом, сложность в **лучшем случае** — O(n)

3. **Средний случай (O(n²))**:

В среднем случае элементы массива могут быть расположены случайным образом. Количество перемещений и сравнений будет приблизительно таким же, как и в худшем случае, так как элементы, скорее всего, придется вставлять в середину или в начало уже отсортированной части. Это приводит к квадратичной зависимости: O($n^2$)

Вывод:

- **Худший случай**: O($n^2$)
- **Лучший случай**: O(n))
- **Средний случай**: O($n^2$)

Алгоритм сортировки вставками эффективен для **малых массивов** и **почти отсортированных данных**, где он может работать быстро.

# Внутренняя реализация

- Для **примитивных типов данных** в `Arrays.sort()` используется модифицированный вариант быстрой сортировки, а для малых массивов — сортировка вставками. Порог (обычно 47 элементов) — это эмпирически подобранное значение для достижения максимальной производительности.
- Для **объектов** (`Object[]`) в `Arrays.sort()` используется алгоритм **Timsort** — это гибрид быстрой сортировки и сортировки слиянием, который также использует сортировку вставками для малых подмассивов.
# Ресурсы

- [Java. Сортировка вставками](https://www.youtube.com/watch?v=jywoZ2XaQoM&list=PL5BhKu-LkR_0mDGftRWeaakqGuYE1ToGG&index=20)
- 
