1. Создание параллельного потока

Когда ты вызываешь parallelStream(), создается поток, который выполняется параллельно, то есть задачи будут распределены по нескольким потокам. Это отличается от обычного потока (stream()), который выполняется последовательно в одном потоке.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.parallelStream().forEach(System.out::println);
```

2. Использование ForkJoinPool

Внутри parallelStream() используется ForkJoinPool, который является пулом потоков, основанным на модели "разделяй и властвуй" (fork-join). Этот пул позволяет разбивать задачи на более мелкие части, которые затем выполняются параллельно на нескольких ядрах процессора.

ForkJoinPool.commonPool() — это общий пул потоков, который используется большинством параллельных операций по умолчанию.

Количество потоков в ForkJoinPool.commonPool() по умолчанию равно количеству ядер процессора (с учетом гиперпоточности), что можно узнать через Runtime.getRuntime().availableProcessors().

3. Разбиение задачи (Splitting)

Потоковые данные (например, коллекция) разбиваются на более мелкие части для обработки в параллельных потоках. Этот процесс называется разделением (splitting). Разбиение выполняется с помощью интерфейса Spliterator, который оптимизирует разбиение на подзадачи.

Если данные позволяют легко разделить их на части (например, массивы, списки), разбиение будет эффективным.

Для коллекций с трудной структурой, таких как LinkedList, разбиение может быть менее эффективным.

4. Выполнение задач в параллельных потоках

Каждая подзадача отправляется в ForkJoinPool и выполняется в одном из потоков пула. ForkJoinPool управляет потоками и координирует выполнение задач.

5. Синхронизация результатов
После завершения всех подзадач результаты объединяются (если необходимо) и возвращаются в основную программу. Это называется редукцией (reduction). Например, при использовании методов reduce(), collect() и других.

```java
Пример работы под капотом:
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
```

```java
// Создание параллельного потока
numbers.parallelStream()
       .map(n -> n * 2) // Задача "умножение на 2" разбивается на несколько подзадач
       .forEach(System.out::println); // Выполняется параллельно
```
       
Основные компоненты под капотом parallelStream():

ForkJoinPool.commonPool() — управление потоками для параллельного выполнения.
Spliterator — для разбиения данных на части для параллельной обработки.
Рабочие потоки (Worker Threads) — потоки, выполняющие параллельные задачи.
Редукция (если требуется) — объединение результатов.

Как изменить количество потоков:

Если нужно управлять количеством потоков, используемых в parallelStream(), можно создать свой собственный ForkJoinPool:

```java
ForkJoinPool customThreadPool = new ForkJoinPool(4); // Создание пула с 4 потоками
customThreadPool.submit(() -> {
    numbers.parallelStream().forEach(System.out::println);
}).join();
customThreadPool.shutdown();
```

Это полезно, если ты хочешь ограничить количество потоков или использовать разные настройки для параллельных операций.