---
Определение: Определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.
Тип:
  - Поведенческий
пример: "Навигатор предлагает разные маршруты: быстрый или короткий"
---
### Проблема

Вы решили написать приложение-навигатор для путешественников. Оно должно показывать красивую и удобную карту, позволяющую с лёгкостью ориентироваться в незнакомом городе.

Одной из самых востребованных функций являлся поиск и прокладывание маршрутов. Пребывая в неизвестном ему городе, пользователь должен иметь возможность указать начальную точку и пункт назначения, а навигатор — проложит оптимальный путь.

Первая версия вашего навигатора могла прокладывать маршрут лишь по дорогам, поэтому отлично подходила для путешествий на автомобиле. Но, очевидно, не все ездят в отпуск на машине. Поэтому следующим шагом вы добавили в навигатор прокладывание пеших маршрутов.

Через некоторое время выяснилось, что некоторые люди предпочитают ездить по городу на общественном транспорте. Поэтому вы добавили и такую опцию прокладывания пути.

Но и это ещё не всё. В ближайшей перспективе вы хотели бы добавить прокладывание маршрутов по велодорожкам. А в отдалённом будущем — интересные маршруты посещения достопримечательностей.

Если с популярностью навигатора не было никаких проблем, то техническая часть вызывала вопросы и периодическую головную боль. С каждым новым алгоритмом код основного класса навигатора увеличивался вдвое. В таком большом классе стало довольно трудно ориентироваться.

Любое изменение алгоритмов поиска, будь то исправление багов или добавление нового алгоритма, затрагивало основной класс. Это повышало риск сделать ошибку, случайно задев остальной работающий код.

Кроме того, осложнялась командная работа с другими программистами, которых вы наняли после успешного релиза навигатора. Ваши изменения нередко затрагивали один и тот же код, создавая конфликты, которые требовали дополнительного времени на их разрешение.

### Решение 

Паттерн Стратегия предлагает определить семейство схожих алгоритмов, которые часто изменяются или расширяются, и вынести их в собственные классы, называемые _стратегиями_.

Вместо того, чтобы изначальный класс сам выполнял тот или иной алгоритм, он будет играть роль контекста, ссылаясь на одну из стратегий и делегируя ей выполнение работы. Чтобы сменить алгоритм, вам будет достаточно подставить в контекст другой объект-стратегию.

Важно, чтобы все стратегии имели общий интерфейс. Используя этот интерфейс, контекст будет независимым от конкретных классов стратегий. С другой стороны, вы сможете изменять и добавлять новые виды алгоритмов, не трогая код контекста.

![[../../../../../_res/Pasted image 20240902102733.png]]

В нашем примере каждый алгоритм поиска пути переедет в свой собственный класс. В этих классах будет определён лишь один метод, принимающий в параметрах координаты начала и конца пути, а возвращающий массив точек маршрута.

Хотя каждый класс будет прокладывать маршрут по-своему, для навигатора это не будет иметь никакого значения, так как его работа заключается только в отрисовке маршрута. Навигатору достаточно подать в стратегию данные о начале и конце маршрута, чтобы получить массив точек маршрута в оговорённом формате.

Класс навигатора будет иметь метод для установки стратегии, позволяя изменять стратегию поиска пути на лету. Такой метод пригодится клиентскому коду навигатора, например, переключателям типов маршрутов в пользовательском интерфейсе.

### Пример

```java
// Определяем интерфейс, который будет реализован конкретными стратегиями.
interface DeliveryStrategy {
    double calculateCost(double weight);
}

// Реализуем несколько конкретных стратегий для расчета стоимости доставки.
class GroundDeliveryStrategy implements DeliveryStrategy {
    @Override
    public double calculateCost(double weight) {
        return weight * 1.0; // Стоимость доставки по суше: 1 доллар за кг
    }
}

// Контекст использует объект стратегии для выполнения расчета. В контексте можно динамически менять стратегию.
class AirDeliveryStrategy implements DeliveryStrategy {
    @Override
    public double calculateCost(double weight) {
        return weight * 2.0; // Стоимость доставки по воздуху: 2 доллара за кг
    }
}

// Стратегия доставки по морю
class SeaDeliveryStrategy implements DeliveryStrategy {
    @Override
    public double calculateCost(double weight) {
        return weight * 0.5; // Стоимость доставки по морю: 0.5 доллара за кг
    }
}

// Класс Контекста
class DeliveryCostCalculator {
    private DeliveryStrategy strategy;

    // Устанавливаем стратегию
    public void setStrategy(DeliveryStrategy strategy) {
        this.strategy = strategy;
    }

    // Рассчитываем стоимость доставки
    public double calculate(double weight) {
        return strategy.calculateCost(weight);
    }
}

// Создаем объект контекста, устанавливаем разные стратегии и рассчитываем стоимость доставки.
public class Main {
    public static void main(String[] args) {
        DeliveryCostCalculator calculator = new DeliveryCostCalculator();

        double weight = 10.0; // вес посылки

        // Используем стратегию доставки по суше
        calculator.setStrategy(new GroundDeliveryStrategy());
        System.out.println("Стоимость доставки по суше: $" + calculator.calculate(weight)); // Вывод: Стоимость доставки по суше: $10.0

        // Используем стратегию доставки по воздуху
        calculator.setStrategy(new AirDeliveryStrategy());
        System.out.println("Стоимость доставки по воздуху: $" + calculator.calculate(weight)); // Вывод: Стоимость доставки по воздуху: $20.0

        // Используем стратегию доставки по морю
        calculator.setStrategy(new SeaDeliveryStrategy());
        System.out.println("Стоимость доставки по морю: $" + calculator.calculate(weight)); // Вывод: Стоимость доставки по морю: $5.0
    }
}
```

### Шаги реализации

1. Определим алгоритм, который подвержен частым изменениям. Также подойдёт алгоритм, имеющий несколько вариаций, которые выбираются во время выполнения программы.
    
2. Создаем интерфейс стратегий. Он должен быть общим для всех вариантов алгоритма.
    
3. Помещаем алгоритм в собственные классы, которые реализуют этот интерфейс.
    
4. В классе контекста создаем поле для хранения ссылки на текущий объект-стратегию (Интерфейс), а также метод для изменения (который оборачивает метод из стратегии). <mark style="background: #FF5582A6;">Контекст должен работать с этим объектом только через общий интерфейс стратегий.</mark>
    
5. Клиенты контекста должны передавать в него соответствующий объект-стратегию ([[../../../../Principles/03 Storage/OOP/Полиморфизм]]), когда хотят, чтобы контекст вёл себя определённым образом.
### Отношения с другими паттернами

- [[GoF Мост|Мост]], [[Gof Стратегия|Стратегия]] и [[GoF Состояние|Состояние]] (а также слегка и [[GoF Адаптер|Адаптер]]), имеют схожие структуры классов - все они построены на принципе [[../../../../Java/Core/Композиция]], делегирование работы другим объектам. Тем не менее они решают разные задачи!
    
- [[GoF Команда]] и [[Gof Стратегия]] похожи по духу, но отличаются масштабом и применением:
    
    - _Команду_ используют, чтобы превратить любые разнородные действия в объекты. Параметры операции превращаются в поля объекта. Этот объект теперь можно логировать, хранить в истории для отмены, передавать во внешние сервисы и так далее.
    - С другой стороны, _Стратегия_ описывает разные способы произвести одно и то же действие, позволяя взаимозаменять эти способы в каком-то объекте контекста.
    
- [[Gof Стратегия]] меняет поведение объекта «изнутри», а [[GoF Декоратор]] изменяет его «снаружи».
    
- [[GoF Шаблонный метод]] использует наследование, чтобы расширять части алгоритма. [[Gof Стратегия]] использует делегирование, чтобы изменять выполняемые алгоритмы на лету. _Шаблонный метод_ работает на уровне классов. _Стратегия_ позволяет менять логику отдельных объектов.
    
- [[GoF Состояние]] можно рассматривать как надстройку над [[Gof Стратегия|Стратегией]]. Оба паттерна используют композицию, чтобы менять поведение основного объекта, делегируя работу вложенным объектам-помощникам. Однако в _Стратегии_ эти объекты не знают друг о друге и никак не связаны. В _Состоянии_ сами конкретные состояния могут переключать контекст.

### Resources

- [Spring Strategy Pattern Example](https://dzone.com/articles/spring-strategy-pattern)
- 