---
Определение: Позволяет объектам менять поведение в зависимости от своего состояния. Извне создаётся впечатление, что изменился класс объекта.
Тип:
  - Поведенческий
пример: Светофор меняет поведение в зависимости от цвета.
---
State

К примеру обучающий курс: не выбран, начато обучение, тестирование, закончен курс.
### Проблема

Паттерн Состояние невозможно рассматривать в отрыве от концепции _машины состояний_, также известной как _стейт-машина_ или _конечный автомат_ .

Основная идея в том, что программа может находиться в одном из нескольких состояний, которые всё время сменяют друг друга. Набор этих состояний, а также переходов между ними, предопределён и _конечен_. Находясь в разных состояниях, программа может по-разному реагировать на одни и те же события, которые происходят с ней.

Такой подход можно применить и к отдельным объектам. Например, объект `Документ` может принимать три состояния: `Черновик`, `Модерация` или `Опубликован`. В каждом из этих состоянии метод `опубликовать` будет работать по-разному:

- Из черновика он отправит документ на модерацию.
- Из модерации — в публикацию, но при условии, что это сделал администратор.
- В опубликованном состоянии метод не будет делать ничего.

![[../../../../../_res/Pasted image 20240901144156.png]]

Машину состояний чаще всего реализуют с помощью множества условных операторов, `if` либо `switch`, которые проверяют текущее состояние объекта и выполняют соответствующее поведение.

Основная проблема такой машины состояний проявится в том случае, если в `Документ` добавить ещё десяток состояний. Каждый метод будет состоять из увесистого условного оператора, перебирающего доступные состояния. Такой код крайне сложно поддерживать. Малейшее изменение логики переходов заставит вас перепроверять работу всех методов, которые содержат условные операторы машины состояний.

Путаница и нагромождение условий особенно сильно проявляется в старых проектах. Набор возможных состояний бывает трудно предопределить заранее, поэтому они всё время добавляются в процессе эволюции программы. Из-за этого решение, которое выглядело простым и эффективным в самом начале разработки, может впоследствии стать проекцией большого макаронного монстра.

### Решение 

Паттерн Состояние предлагает создать отдельные классы для каждого состояния, в котором может пребывать объект, а затем вынести туда поведения, соответствующие этим состояниям.

Вместо того, чтобы хранить код всех состояний, первоначальный объект, называемый _контекстом_, будет содержать ссылку на один из объектов-состояний и делегировать ему работу, зависящую от состояния.

![[../../../../../_res/Pasted image 20240901144402.png]]

Благодаря тому, что объекты состояний будут иметь общий интерфейс, контекст сможет делегировать работу состоянию, не привязываясь к его классу. Поведение контекста можно будет изменить в любой момент, подключив к нему другой объект-состояние.

Очень важным нюансом, отличающим этот паттерн от [[Gof Стратегия]], является то, что и контекст, и сами конкретные состояния могут знать друг о друге и инициировать переходы от одного состояния к другому.
### Пример

```java
// Интерфейс состояния
interface State {
    void insertCoin();
    void ejectCoin();
    void selectDrink();
    void dispense();
}

// Конкретное состояние: Ожидание монеты
class WaitingForCoinState implements State {
    private VendingMachine vendingMachine;

    public WaitingForCoinState(VendingMachine vendingMachine) {
        this.vendingMachine = vendingMachine;
    }

	...
}

// Конкретное состояние: Ожидание выбора напитка
class WaitingForSelectionState implements State {
    private VendingMachine vendingMachine;

    public WaitingForSelectionState(VendingMachine vendingMachine) {
        this.vendingMachine = vendingMachine;
    }

	...
}

// Конкретное состояние: Выдача напитка
class DispensingState implements State {
    private VendingMachine vendingMachine;

    public DispensingState(VendingMachine vendingMachine) {
        this.vendingMachine = vendingMachine;
    }

	...
}

// Класс автомата
class VendingMachine {
    private State waitingForCoinState;
    private State waitingForSelectionState;
    private State dispensingState;

    private State currentState;

    public VendingMachine() {
        waitingForCoinState = new WaitingForCoinState(this);
        waitingForSelectionState = new WaitingForSelectionState(this);
        dispensingState = new DispensingState(this);

        currentState = waitingForCoinState;
    }

    public void setState(State state) {
        this.currentState = state;
    }

	...

    public void insertCoin() {
        currentState.insertCoin();
    }

    public void ejectCoin() {
        currentState.ejectCoin();
    }

    public void selectDrink() {
        currentState.selectDrink();
    }

    public void dispense() {
        currentState.dispense();
    }
}


public class Main {
    public static void main(String[] args) {
        VendingMachine vendingMachine = new VendingMachine();

        vendingMachine.insertCoin(); // Переходит в состояние ожидания выбора напитка
        vendingMachine.selectDrink(); // Переходит в состояние выдачи напитка
        vendingMachine.dispense(); // Возвращается в состояние ожидания монеты

        vendingMachine.selectDrink(); // Сообщение: "Сначала вставьте монету."
    }
}

```

### Шаги реализации

1. Определитесь с классом, который будет играть роль контекста. Это может быть как существующий класс, в котором уже есть зависимость от состояния, так и новый класс, если код состояний размазан по нескольким классам.
    
2. Создайте общий интерфейс состояний. Он должен описывать методы, общие для всех состояний, обнаруженных в контексте. Заметьте, что не всё поведение контекста нужно переносить в состояние, а только то, которое зависит от состояний.
    
3. Для каждого фактического состояния создайте класс, реализующий интерфейс состояния. Переместите код, связанный с конкретными состояниями в нужные классы. В конце концов, все методы интерфейса состояния должны быть реализованы во всех классах состояний.
    
    При переносе поведения из контекста вы можете столкнуться с тем, что это поведение зависит от приватных полей или методов контекста, к которым нет доступа из объекта состояния. Существует парочка способов обойти эту проблему.
    
    Самый простой — оставить поведение внутри контекста, вызывая его из объекта состояния. С другой стороны, вы можете сделать классы состояний вложенными в класс контекста, и тогда они получат доступ ко всем приватным частям контекста. Но последний способ доступен только в некоторых языках программирования (например, Java, C#).
    
4. Создайте в контексте поле для хранения объектов-состояний, а также публичный метод для изменения значения этого поля.
    
5. Старые методы контекста, в которых находился зависимый от состояния код, замените на вызовы соответствующих методов объекта-состояния.
    
6. В зависимости от бизнес-логики, разместите код, который переключает состояние контекста либо внутри контекста, либо внутри классов конкретных состояний.

### Отношения с другими паттернами

- [[GoF Мост]], [[Gof Стратегия]] и [[GoF Состояние]] (а также слегка и [[GoF Адаптер]]) имеют схожие структуры классов — все они построены на принципе «композиции», то есть делегирования работы другим объектам. Тем не менее, они отличаются тем, что решают разные проблемы. Помните, что паттерны — это не только рецепт построения кода определённым образом, но и описание проблем, которые привели к данному решению.
    
- [[GoF Состояние]] можно рассматривать как надстройку над [[Gof Стратегия]]. Оба паттерна используют композицию, чтобы менять поведение основного объекта, делегируя работу вложенным объектам-помощникам. Однако в _Стратегии_ эти объекты не знают друг о друге и никак не связаны. В _Состоянии_ сами конкретные состояния могут переключать контекст.