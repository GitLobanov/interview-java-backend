---
Определение: Предоставляет способ оценки предложений или выражений на определенном языке. Интерпретирует набор правил состоящих из дерева.
Тип:
  - Поведенческий
---
### Проблема

Представим, что у нас есть язык (например, математические выражения или команды для обработки), и нам нужно его обработать или интерпретировать. Проблема возникает, когда есть набор правил (грамматика) для этого языка, и мы хотим автоматически обрабатывать предложения или выражения, написанные на этом языке. Пример: вычисление арифметических выражений, анализ формул, разбор команд.

Без структурированного подхода такие задачи могут привести к сложному и запутанному коду с множеством `if-else` или `switch` выражений. Нам нужно что-то более гибкое и расширяемое для таких ситуаций.
### Решение 

**Паттерн Interpreter** предлагает представлять каждое правило грамматики как класс (или объект) и позволяет организовать обработку выражений через комбинацию объектов. Каждый объект соответствует определенному правилу или части выражения. Эти объекты взаимодействуют друг с другом, чтобы выполнить интерпретацию всего выражения.

Основная идея: создать структуру, в которой каждый класс может "интерпретировать" выражение и возвращать результат.
### Пример

Задача: построить интерпретатор для простых арифметических выражений, таких как `(5 + 10) - 2`.

1. **Терминальные выражения**: простые числа, которые не требуют дальнейшей обработки.
2. **Нетерминальные выражения**: операции, такие как сложение и вычитание, которые могут применяться к другим выражениям.

Реализация:

- **Терминальные выражения**: это числа (например, `5`, `10`, `2`).
- **Нетерминальные выражения**: это операции сложения и вычитания (например, `(5 + 10)`, а затем результат минус `2`).

Мы строим дерево, где узлы — это операции (сложение, вычитание), а листья — это числа.

### Шаги реализации

- **Определить грамматику** для языка (например, арифметические выражения). Для нашего примера грамматика может быть:
    - Число → это терминальное выражение.
    - Операция → это нетерминальное выражение (сложение, вычитание и т. д.).
- **Создать интерфейс или абстрактный класс** для выражений:

```java
interface Expression {
    int interpret();
}
```

- **Создать классы для терминальных выражений**:
	- Например, числа будут простыми выражениями, которые возвращают свои значения.

```java
class NumberExpression implements Expression {
    private int number;

    public NumberExpression(int number) {
        this.number = number;
    }

    @Override
    public int interpret() {
        return number;
    }
}
```

- **Создать классы для нетерминальных выражений**:
	- Это операции сложения и вычитания, которые комбинируют другие выражения.

```java
class AddExpression implements Expression {
    private Expression leftExpression;
    private Expression rightExpression;

    public AddExpression(Expression leftExpression, Expression rightExpression) {
	    ...
    }

    @Override
    public int interpret() {
        return leftExpression.interpret() + rightExpression.interpret();
    }
}

class SubtractExpression implements Expression {
	...

    @Override
    public int interpret() {
        return leftExpression.interpret() - rightExpression.interpret();
    }
}
```

- **Создать клиентский код для построения выражения**:
	- Мы строим дерево выражений и интерпретируем его.

```java
public class InterpreterPatternExample {
    public static void main(String[] args) {
        // Создаем выражения
        Expression five = new NumberExpression(5);
        Expression ten = new NumberExpression(10);
        Expression two = new NumberExpression(2);

        // (5 + 10)
        Expression addition = new AddExpression(five, ten);

        // (5 + 10) - 2
        Expression fullExpression = new SubtractExpression(addition, two);

        // Интерпретируем выражение
        int result = fullExpression.interpret();
        System.out.println("(5 + 10) - 2 = " + result);  // Вывод: (5 + 10) - 2 = 13
    }
}
```
### Отношения с другими паттернами

- Паттерн **Interpreter** часто использует структуру [[GoF Компоновщик|Компоновщика]], так как выражения могут быть составными (деревья выражений), где нетерминальные выражения (операции) содержат другие выражения (терминальные или нетерминальные).
    
- Можно использовать [[Gof Стратегия|Стратегию]] для реализации различных типов интерпретаций. Например, разные стратегии могут интерпретировать выражения по-разному (например, разные системы счисления).
    
- **Interpreter** может быть частью [[GoF Цепочка обязанностей|Цепочки обязанностей]], когда разные обработчики пробуют интерпретировать выражение. Если один обработчик не справляется, он передает работу другому.
    
- Если грамматика сложная, можно комбинировать [[GoF Посетитель|Посетителя]] с **Interpreter**. Посетитель помогает обрабатывать выражения, разделяя логику обработки и хранения данных.