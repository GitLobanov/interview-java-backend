В Hibernate наследование — это концепция, позволяющая моделировать и управлять иерархиями классов в объектно-реляционном отображении (ORM). Hibernate предоставляет несколько стратегий для реализации наследования, каждая из которых подходит для различных сценариев.

## Стратегии наследования в Hibernate

### 1. (Inheritance Strategy: Single Table)

![[../../../_res/Pasted image 20240919164120.png]]

Все сущности, связанные с иерархией наследования, хранятся в одной таблице. В этой таблице есть специальный столбец для указания типа сущности, чтобы различать записи.

```sql
CREATE TABLE Animal (
    id BIGINT NOT NULL AUTO_INCREMENT,  -- Идентификатор
    name VARCHAR(255),                   -- Общий атрибут
    type VARCHAR(255),                   -- Дискриминатор для различия типов (например, "Dog", "Cat")
    breed VARCHAR(255),                  -- Поле для Dog
    lives INT,                           -- Поле для Cat
    PRIMARY KEY (id)
);
```
### 2. (Inheritance Strategy: Table per Class)

Каждая сущность и её подтипы хранятся в отдельных таблицах. Каждая таблица представляет собой полный набор данных для соответствующей сущности.

Одна таблица для каждого конкретного класса, с полным исключением полиморфизма и отношений наследования из схемы SQL (для полиморфного поведения во время выполнения будут использоваться UNION-запросы). Сохранять можно все сущности (родительские и дочерние) — они пойдут в независимые таблицы.

![[../../../_res/Pasted image 20240919164418.png]]

```sql
-- Таблица для родительского класса (Animal)
CREATE TABLE Animal (
    id BIGINT NOT NULL AUTO_INCREMENT,  -- Идентификатор
    name VARCHAR(255),                   -- Общий атрибут
    PRIMARY KEY (id)
);

-- Таблица для подкласса Dog (содержит данные из Animal и Dog)
CREATE TABLE Dog (
    id BIGINT NOT NULL AUTO_INCREMENT,  -- Идентификатор
    name VARCHAR(255),                   -- Атрибут из Animal
    breed VARCHAR(255),                  -- Поле для Dog
    PRIMARY KEY (id)
);

-- Таблица для подкласса Cat (содержит данные из Animal и Cat)
CREATE TABLE Cat (
    id BIGINT NOT NULL AUTO_INCREMENT,  -- Идентификатор
    name VARCHAR(255),                   -- Атрибут из Animal
    lives INT,                           -- Поле для Cat
    PRIMARY KEY (id)
);
```

### 3. (Inheritance Strategy: JOINED)

- Каждая сущность (родительская и дочерняя) имеет свою собственную таблицу. Родительская таблица содержит общие поля, а дочерние таблицы содержат только специфические для них поля.
- Первичные ключи являются заодно и внешними они ссылаются на главную таблицу

```sql
-- Таблица для родительского класса (Animal)
CREATE TABLE Animal (
    id BIGINT NOT NULL AUTO_INCREMENT,  -- Идентификатор
    name VARCHAR(255),                   -- Общий атрибут
    PRIMARY KEY (id)
);

-- Таблица для подкласса Dog
CREATE TABLE Dog (
    id BIGINT NOT NULL,                  -- Идентификатор (ссылается на родительский класс)
    breed VARCHAR(255),                  -- Поле для Dog
    FOREIGN KEY (id) REFERENCES Animal(id) -- Связь с таблицей Animal
);

-- Таблица для подкласса Cat
CREATE TABLE Cat (
    id BIGINT NOT NULL,                  -- Идентификатор (ссылается на родительский класс)
    lives INT,                           -- Поле для Cat
    FOREIGN KEY (id) REFERENCES Animal(id) -- Связь с таблицей Animal
);
```
## Сравнение стратегий

— Стратегию №2 (TABLE_PER_CLASS на основе UNION), если полиморфные запросы и ассоциации не требуются. Если вы редко выполняете (или не выполняете вообще) **«select bd from BillingDetails bd»,** и у вас нет классов, ссылающихся на BillingDetails, этот вариант будет лучшим (поскольку возможность добавления оптимизированных полиморфных запросов и ассоциаций сохранится).  
  
— Стратегию №3 (SINGLE_TABLE) стоит использовать:  
  
а) Только для простых задач. В ситуациях, когда нормализация и ограничение NOT NULL являются критическими – следует отдать предпочтение стратегии №4 (JOINED). Имеет смысл задуматься, не стоит ли в данном случае вообще отказаться от наследования и [заменить его делегированием](https://refactoring.guru/ru/replace-inheritance-with-delegation)  
б) Если требуются полиморфные запросы и ассоциации, а также динамическое определение конкретного класса во время выполнения; при этом подклассы объявляют относительно мало новых полей и основная разница с суперклассом заключается в поведении.  
  
— Стратегия №4 (JOINED) подойдет в случаях, когда требуются полиморфные запросы и ассоциации, но подклассы объявляют относительно много новых полей.  
  
Здесь стоит оговориться: решение между JOINED и TABLE_PER_CLASS требует оценки планов выполнения запросов на реальных данных, поскольку ширина и глубина иерархии наследования могут сделать стоимость соединений (и, как следствие, производительность) неприемлемыми.

## Дополнительно @MappedSuperclass Аннотация

Аннотация @MappedSuperclass позволяет вынести общие поля в родительский класс, но при этом не создавать для него отдельную таблицу. При такой стратегии классы наследники преобразуются в независимые таблицы. @ MappedSuperclass никак не влияет на структуру в базе это просто способ вынести общие поля.

Сохранять можно только дочерние сущности — они пойдут в независимые таблицы и будут включать поля родительской. Отдельно _Customer_ не сохранить, это абстракция, в которую вынесена часть полей.

Поля также можно было бы вынести вовне с помощью _@Embedded_, но не все (кроме _@Id)_. Здесь же мы вынесли и _@Id_.

![[../../../_res/Pasted image 20240919164641.png]]