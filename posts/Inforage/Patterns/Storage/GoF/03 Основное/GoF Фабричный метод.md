---
Определение: Определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.
Тип:
  - Порождающий
пример: Автосалон собирает машины разной модели на одной платформе
---
Виртуальный конструктор, Factory Method

![[Pasted image 20241001184521.png]]
### Проблема

Представьте, что вы создаёте программу управления грузовыми перевозками. Сперва вы рассчитываете перевозить товары только на автомобилях. Поэтому весь ваш код работает с объектами класса `Грузовик`.

В какой-то момент ваша программа становится настолько известной, что морские перевозчики выстраиваются в очередь и просят добавить поддержку морской логистики в программу.

Отличные новости, правда?! Но как насчёт кода? Большая часть существующего кода жёстко привязана к классам `Грузовиков`. Чтобы добавить в программу классы морских `Судов`, понадобится перелопатить всю программу. Более того, если вы потом решите добавить в программу ещё один вид транспорта, то всю эту работу придётся повторить.

В итоге вы получите ужасающий код, наполненный условными операторами, которые выполняют то или иное действие, в зависимости от класса транспорта.
### Решение 

Паттерн Фабричный метод предлагает создавать объекты не напрямую, используя оператор `new`, а через вызов особого _фабричного_ метода. Не пугайтесь, объекты всё равно будут создаваться при помощи `new`, но делать это будет фабричный метод.

На первый взгляд, это может показаться бессмысленным: мы просто переместили вызов конструктора из одного конца программы в другой. Но теперь вы сможете переопределить фабричный метод в подклассе, чтобы изменить тип создаваемого продукта.

Чтобы эта система заработала, все возвращаемые объекты должны иметь общий интерфейс. Подклассы смогут производить объекты различных классов, следующих одному и тому же интерфейсу.

Например, классы `Грузовик` и `Судно` реализуют интерфейс `Транспорт` с методом `доставить`. Каждый из этих классов реализует метод по-своему: грузовики везут грузы по земле, а суда — по морю. Фабричный метод в классе `ДорожнойЛогистики` вернёт объект-грузовик, а класс `МорскойЛогистики` — объект-судно.

![[Pasted image 20240901162936.png]]

Для клиента фабричного метода нет разницы между этими объектами, так как он будет трактовать их как некий абстрактный `Транспорт`. Для него будет важно, чтобы объект имел метод `доставить`, а как конкретно он работает — не важно.

### Примеры

#### Пример с разными уведомлениями

Система создания уведомлений. Создадим систему для отправки уведомлений, где разные типы уведомлений (например, Email и SMS) создаются через фабричный метод.

Создадим интерфейс `Notification`, который будут реализовывать конкретные уведомления.

```java
public interface Notification {
    void notifyUser();
}
```

Создадим конкретные классы уведомлений, реализующие интерфейс `Notification`.

```java
public class EmailNotification implements Notification {
    @Override
    public void notifyUser() {
        System.out.println("Sending an Email Notification");
    }
}

public class SMSNotification implements Notification {
    @Override
    public void notifyUser() {
        System.out.println("Sending an SMS Notification");
    }
}
```

Определим интерфейс `NotificationFactory`, который будет содержать фабричный метод для создания уведомлений.

Создадим конкретные фабрики для создания различных типов уведомлений.

```java
public class EmailNotificationFactory implements NotificationFactory {
    @Override
    public Notification createNotification() {
        return new EmailNotification();
    }
}

public class SMSNotificationFactory implements NotificationFactory {
    @Override
    public Notification createNotification() {
        return new SMSNotification();
    }
}
```

Теперь мы можем использовать фабрики для создания и отправки уведомлений без привязки к конкретным классам уведомлений.

```java
public class NotificationService {
    private NotificationFactory factory;

    public NotificationService(NotificationFactory factory) {
        this.factory = factory;
    }

    public void sendNotification() {
        Notification notification = factory.createNotification();
        notification.notifyUser();
    }
}

public class FactoryMethodDemo {
    public static void main(String[] args) {
        // Используем фабрику для создания Email уведомлений
        NotificationFactory emailFactory = new EmailNotificationFactory();
        NotificationService emailService = new NotificationService(emailFactory);
        emailService.sendNotification(); // Output: Sending an Email Notification

        // Используем фабрику для создания SMS уведомлений
        NotificationFactory smsFactory = new SMSNotificationFactory();
        NotificationService smsService = new NotificationService(smsFactory);
        smsService.sendNotification(); // Output: Sending an SMS Notification
    }
}
```

- **Notification** — интерфейс для всех уведомлений.
- **EmailNotification** и **SMSNotification** — конкретные реализации уведомлений.
- **NotificationFactory** — интерфейс для фабрик, которые создают уведомления.
- **EmailNotificationFactory** и **SMSNotificationFactory** — конкретные фабрики для создания конкретных типов уведомлений.
- **NotificationService** — клиентский код, который использует фабрику для создания и отправки уведомлений.

#### Пример с картами

```java
public class StandardCardFactory implements CardFactory {
  public Card newCard(ClientAttributes attributes) {
    ...
    return new StandardCard();
  }
}

public class GoldCardFactory implements CardFactory {
  public Card newCard(ClientAttributes attributes) {
    ...
    return new GoldCard();
  }
}

public class PlatinumCardFactory implements CardFactory {
  public Card newCard(ClientAttributes attributes) {
    ...
    return new PlatinumCard();
  }
}
```
### Шаги реализации

1. Приведите все создаваемые продукты к общему интерфейсу.
    
2. В классе, который производит продукты, создайте пустой фабричный метод. В качестве возвращаемого типа укажите общий интерфейс продукта.
    
3. Затем пройдитесь по коду класса и найдите все участки, создающие продукты. Поочерёдно замените эти участки вызовами фабричного метода, перенося в него код создания различных продуктов.
    
    В фабричный метод, возможно, придётся добавить несколько параметров, контролирующих, какой из продуктов нужно создать.
    
    На этом этапе фабричный метод, скорее всего, будет выглядеть удручающе. В нём будет жить большой условный оператор, выбирающий класс создаваемого продукта. Но не волнуйтесь, мы вот-вот исправим это.
    
4. Для каждого типа продуктов заведите подкласс и переопределите в нём фабричный метод. Переместите туда код создания соответствующего продукта из суперкласса.
    
5. Если создаваемых продуктов слишком много для существующих подклассов создателя, вы можете подумать о введении параметров в фабричный метод, которые позволят возвращать различные продукты в пределах одного подкласса.
    
    Например, у вас есть класс `Почта` с подклассами `АвиаПочта` и `НаземнаяПочта`, а также классы продуктов `Самолёт`, `Грузовик` и `Поезд`. `Авиа` соответствует `Самолётам`, но для `НаземнойПочты` есть сразу два продукта. Вы могли бы создать новый подкласс почты для поездов, но проблему можно решить и по-другому. Клиентский код может передавать в фабричный метод `НаземнойПочты` аргумент, контролирующий тип создаваемого продукта.
    
6. Если после всех перемещений фабричный метод стал пустым, можете сделать его абстрактным. Если в нём что-то осталось — не беда, это будет его реализацией по умолчанию.

### Отношения с другими паттернами

- Многие архитектуры начинаются с применения **фабричного метода**  (более простого и расширяемого через подклассы) и эволюционируют в сторону [[GoF Абстрактная фабрика |Абстрактной фабрики]], [[GoF Прототип|Прототипа]] или [[GoF Строитель|Строителя]] (более гибких, но и более сложных).
    
- Классы [[GoF Абстрактная фабрика]] чаще всего реализуются с помощью **фабричного метода**, хотя они могут быть построены и на основе [[GoF Прототип]].
    
- **Фабричный метод** можно использовать вместе с [[GoF Итератор]], чтобы подклассы коллекций могли создавать подходящие им итераторы.
    
- [[GoF Прототип]] не опирается на наследование, но ему нужна сложная операция инициализации. [[GoF Фабричный метод]], наоборот, построен на наследовании, но не требует сложной инициализации.
    
- **Фабричный метод** можно рассматривать как частный случай [[GoF Шаблонный метод]]. Кроме того, _Фабричный метод_ нередко бывает частью большого класса с _Шаблонными методами_. [[../01 Примеры/EX. Фабричный метод вместе с Шаблонными методами]]