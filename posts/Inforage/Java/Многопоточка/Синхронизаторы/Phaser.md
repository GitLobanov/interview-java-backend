Phaser вполне естественно расширяет функциональность предшественника из JDK 1.5, CyclicBarrier.

- **Делится на фазы**  
    Метод: `onAdvance(int phase, int registeredParties)`  
    Это callback, который вызывается при завершении фазы перед переходом к следующей.
- **Каждая фаза (цикл синхронизации) имеет номер**  
    Метод: `getPhase()`  
    Возвращает текущий номер фазы, в которой находится фейзер.
- **Количество сторон-участников жестко не задано и может меняться: поток может регистрироваться в качестве участника и отменять свое участие**  
    Методы:
    - `register()` — Регистрирует новый поток как участника.
    - `arriveAndDeregister()` — Сообщает о прибытии и снимает поток с участия в фазе.
- **Участник не обязан ожидать, пока все остальные участники соберутся на барьере. Чтобы продолжить свою работу, достаточно сообщить о своем прибытии**  
    Метод: `arrive()`  
    Уведомляет фейзер о прибытии потока, но не заставляет поток ожидать завершения фазы.
- **Случайные свидетели могут следить за активностью в барьере**  
    Метод: `getUnarrivedParties()`  
    Возвращает количество участников, которые еще не прибыли.
    Метод: `awaitAdvance(int phase)`  
    Позволяет потоку ожидать завершения определенной фазы, даже если он не зарегистрирован как участник.
- **У фазера нет опционального действия**  
    Особенность: В `Phaser` метод `onAdvance()` можно переопределить, но сам по себе он не содержит опционального действия, как в других синхронизационных механизмах (например, в CyclicBarrier).

Это расширение настолько общо, что согласуется и с контрактом третьего барьера из стандартной библиотеки, CountDownLatch.

Состояние этапщика включает

1. номер этапа (фазы, цикла синхронизации) | int phase
2. количество участников | int parties
3. количество участников, которые заявили/не заявили о своей готовности | int arrived, unarrived
4. состояние завершения | boolean terminated

Всегда верно:  
terminated = false   →   phase = [реальный номер этапа, счет ведется с нуля] % (2$^{31}$ − 1)  
parties  =  arrived + unarrived  
0  ≤  unarrived, arrived  ≤  parties

1. Основные управляющие методы:  

| метод                   | описание                                                             |
| ----------------------- | -------------------------------------------------------------------- |
| register()              | зарегистрировать участника                                           |
| arrive()                | сообщить этапщику о своей готовности, _не_ ожидая открытия барьера   |
| arriveAndAwaitAdvance() | классическое прибытие на барьер. Точный аналог CyclicBarrier.await() |
| arriveAndDeregister()   | отменить свое участие                                                |
2. Барьер открывается сразу после всякого _уменьшения unarrived до нуля._ То есть, в том числе, когда снимается последний участник, однако при создании «пустого» этапщика (new Phaser() или new Phaser(0)) «ворота закрыты».

Как это примерно работает:  

```java
final Phaser ph = new Phaser(4);
ph.arrive();
ph.register();
new Thread() {public void run(){ ph.arriveAndAwaitAdvance(); }}.start();
ph.arrive();
ph.arrive();
ph.arriveAndDeregister(); 
// phase number = 1 
// Thread-0 released
```

![[Pasted image 20241009094914.png]]

3. arriveAndDeregister — поток одновременно прибывает и снимается с учета