### 1. **Constructor Injection (Инъекция через конструктор)**

#### Определение:

Этот метод внедрения зависимостей заключается в том, что все зависимости передаются через параметры конструктора. Это наиболее распространенный и рекомендуемый способ DI, так как зависимости становятся обязательными для создания объекта.

#### Пример:

```java
public class TaskService {
    private TaskRepository taskRepository;

    // Инъекция через конструктор
    public TaskService(TaskRepository taskRepository) {
        this.taskRepository = taskRepository;
    }

    public void trackTask(String taskId) {
        taskRepository.saveTask(taskId);
    }
}
```

#### Когда использовать:

- Когда все зависимости обязательны для работы класса.
- При необходимости работы с **неизменяемыми объектами**.
- Предпочтительно в большинстве случаев, так как гарантирует наличие всех зависимостей при создании объекта.
### 2. **Setter Injection (Инъекция через сеттеры)**

#### Определение:

В этом виде DI зависимости внедряются через **сеттеры** (методы) после создания объекта. Таким образом, зависимости могут быть опциональными, а не обязательными для создания объекта.

#### Пример:

```java
public class TaskService {
    private TaskRepository taskRepository;

    // Инъекция через сеттер
    public void setTaskRepository(TaskRepository taskRepository) {
        this.taskRepository = taskRepository;
    }

    public void trackTask(String taskId) {
        if (taskRepository != null) {
            taskRepository.saveTask(taskId);
        }
    }
}
```

#### Когда использовать:

- Когда зависимость является **необязательной**.
- Если зависимости могут быть **переустановлены** или **изменены** после создания объекта.
- Иногда используется в фреймворках, таких как Spring, для инъекции дополнительных параметров.

### 3. **Field Injection (Инъекция через поля)**

#### Определение:

В этом подходе зависимости напрямую внедряются в поля класса с помощью аннотаций (например, `@Autowired` в Spring). Это самый простой способ инъекции, но имеет некоторые недостатки.

#### Пример

```java
public class TaskService {
    @Autowired
    private TaskRepository taskRepository;

    public void trackTask(String taskId) {
        taskRepository.saveTask(taskId);
    }
}
```

#### Когда использовать:

- Применяется в **Spring** и других DI-фреймворках.
- Подходит для случаев, когда нужно минимизировать код инъекции, но рекомендуется избегать этого подхода для важных зависимостей, так как сложно протестировать и поддерживать.
- Полезно, если DI-контейнер сам управляет жизненным циклом объектов (например, в фреймворках, где контейнер контролирует создание классов).

### 4. **Interface Injection (Инъекция через интерфейс)**

#### Определение:

В этом методе класс предоставляет метод через интерфейс, который должен быть вызван для внедрения зависимостей. В отличие от других видов DI, здесь зависимости передаются через специальный интерфейс, который должен реализовывать класс.

#### Пример:

```java
public interface TaskRepositoryAware {
    void setTaskRepository(TaskRepository taskRepository);
}

public class TaskService implements TaskRepositoryAware {
    private TaskRepository taskRepository;

    // Реализация метода интерфейса
    public void setTaskRepository(TaskRepository taskRepository) {
        this.taskRepository = taskRepository;
    }

    public void trackTask(String taskId) {
        taskRepository.saveTask(taskId);
    }
}
```

#### Когда использовать:

- Это менее распространенный подход и редко используется.
- Можно использовать, если нужно передать зависимость через интерфейс, и объект обязан его реализовать.
- Полезен в сложных системах, где объекты могут передавать друг другу зависимости, не имея явной зависимости от DI-контейнера.

### 5. Lookup Injection

### Определение:

**Lookup Injection** позволяет объекту самостоятельно находить и получать зависимости в момент, когда они ему нужны, а не при создании объекта. Это обеспечивает большую гибкость, когда невозможно или нецелесообразно инжектировать зависимость на этапе инициализации объекта.
### Пример:

В Java-фреймворках, таких как **Spring**, часто используется аннотация `@Lookup` для реализации этого механизма.

```java
public abstract class TaskService {

    // Зависимость не передается напрямую, а запрашивается при необходимости
    public void performTask(String taskId) {
        TaskRepository taskRepository = getTaskRepository();
        taskRepository.saveTask(taskId);
    }

    // Абстрактный метод для выполнения lookup
    @Lookup
    protected abstract TaskRepository getTaskRepository();
}
```

### Когда использовать Lookup Injection:

1. **Необходимость в прототипах**: Если зависимость должна быть новым экземпляром каждый раз, когда она запрашивается, например, при работе с объектами с **краткосрочной областью видимости** (scope). Lookup Injection полезен, когда нельзя инжектировать зависимость как singleton.
    
2. **Динамическое создание зависимостей**: Когда зависимость зависит от текущего контекста, и её нецелесообразно инжектировать сразу при создании объекта. Например, при работе с разными реализациями одного и того же интерфейса в зависимости от условий.
    
3. **Необходимость отложенной инициализации**: Если объект не всегда нуждается в зависимости и она может быть запрошена только при определенных условиях.

### Когда использовать каждый вид DI:

| Тип инъекции              | Применение                                                                                              | Преимущества                                                                                                                                                                                                                                      | Недостатки                                                                                                                                                                                                                                                                                                        |
| ------------------------- | ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Constructor Injection** | Когда зависимости обязательны и неизменяемы.                                                            | Гарантирует наличие всех зависимостей, поддерживает неизменяемость.                                                                                                                                                                               | Может стать сложным, если зависимостей много.                                                                                                                                                                                                                                                                     |
| **Setter Injection**      | Когда зависимости необязательны или могут быть изменены после создания объекта.                         | Легче управлять опциональными зависимостями.                                                                                                                                                                                                      | Может привести к отсутствию некоторых зависимостей, сложнее тестировать.                                                                                                                                                                                                                                          |
| **Field Injection**       | Для минимизации кода инъекции, особенно в фреймворках.                                                  | Минимум кода, простота реализации.                                                                                                                                                                                                                | Трудно тестировать, отсутствие зависимости может быть неочевидно.                                                                                                                                                                                                                                                 |
| **Interface Injection**   | В редких случаях, когда классы обязаны реализовывать интерфейсы для получения зависимостей.             | Гибкость, возможен многоразовый код.                                                                                                                                                                                                              | Мало используется, усложняет проектирование классов.                                                                                                                                                                                                                                                              |
| **Lookup Injeciton**      | Необходимость в прототипах. Динамическое создание зависимостей. Необходимость отложенной инициализации. | Позволяет гибко управлять зависимостями, особенно в случае, когда зависимости динамически меняются или должны быть прототипами.<br>Удобно для инъекции краткоживущих объектов, таких как сессии пользователей или специфичные для запроса данные. | Сложнее тестировать, так как объект сам запрашивает зависимости.<br>Более сложная архитектура по сравнению с классической инъекцией через конструктор или сеттеры.<br>В некоторых случаях может нарушать принцип инверсии управления (IoC), поскольку объект сам запрашивает зависимость, а не получает её извне. |
