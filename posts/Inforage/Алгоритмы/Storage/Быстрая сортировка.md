---
Определение: Выбирается опорный элемент. Опорным может выступать любое число, но в частном случае делим ряд на две половины - серединный элемент становится опорным.  Исходя от него, в лево уносим числа меньше, в право - больше (сравниваем числа с опорным). Затем рекурсивно каждую половину делим, и повторятся тоже самое. И так пока не отсортируем весь массив.
Примечание: Вне всяких сомнений, алгоритм быстрой сортировки считается самым популярным, так как в большинстве ситуаций он выполняется быстрее остальных, за время O(N*logN).
---
# Попытки объяснить

1. У нас должен быть опорный элемент, лучше медианный. Мы проходим циклом и кидаем меньшие элементы в лево, большие в право. Определяем их по опорному элементу (к примеру 3 > **2** > 1). Потом рекурсивно делим эти половины, каждую на еще две половины и также перебрасываем элементы. **Важно!** Чтобы перебросить элемент из одной части в другую, нужен элемент из другой половины на который его можно поменять. 

# Принцип работы

- **Выбор опорного элемента (pivot)**: Выбирается один элемент массива, который будет опорным (часто выбирают средний, случайный или первый элемент).
- **Разделение**: Массив перестраивается таким образом, чтобы все элементы, меньшие опорного, оказались слева, а все элементы, большие опорного, — справа. Опорный элемент занимает свою окончательную позицию.
- **Рекурсия**: Процесс повторяется рекурсивно для левой и правой частей массива, пока массивы не станут размером 1 или 0.

```java
public class Solution {
   public static void main(String[] args) {
       int[] testArr = new int[]{6, 3, 8, 8, 6, 9, 4, 11, 1};
       fastSort(testArr);
       for (int i : testArr) {
           System.out.println(i);
       }
   }

   public static void fastSort(int[] array) {
       recursionFastSort(array, 0, array.length - 1);
   }


   public static void recursionFastSort(int[] array, int min, int max) {
       if (array.length == 0)
           return;

       if (min >= max)
           return;


       int middle = min + (max - min) / 2; 
       int middleElement = array[middle];


       int i = min, j = max;
       // в право кидаем большие элементы
       // в лево кидаем меньшие элементы
       // исходим от медианного числа
       while (i <= j) {  
			// поиск большего элемента в ПРАВОЙ
           while (array[i] < middleElement) {
               i++;
           }
           // поиск меньшего элемента в ЛЕВОЙ
           while (array[j] > middleElement) {
               j--;
           }
		   // меняем меньший и больший местами
           if (i <= j) { 
               int temp = array[i];
               array[i] = array[j];
               array[j] = temp;
               i++;
               j--;
           }
       }

	   // делим получившиеся срезы массива
	
	   // запускаем рекурсию с элементами меньшими чем middle
       if (min < j) 
           recursionFastSort(array, min, j);

	   // запускаем рекурсию с элементами большими чем middle
       if (max > i)
           recursionFastSort(array, i, max);
   }
}
```

![[Pasted image 20240924093119.png]]

# Оптимизация

 1. Выбор опорного элемента (pivot selection)

- **Случайный выбор**: Выбор случайного элемента в качестве опорного может помочь избежать худшего случая при сортировке уже отсортированных или почти отсортированных данных.
- **Медиана трех**: Выбор опорного элемента как медианы первых, последних и среднего элементов массива. Это помогает получить более сбалансированное разделение.

2. Устранение рекурсии для маленьких массивов, к примеру применение **сортировки вставками**. Как в Arrays.sort().

3. Ограничение глубины рекурсии

- В случае больших глубин рекурсии, что может привести к переполнению стека, можно использовать итеративную реализацию с помощью собственного стека или массивов для хранения диапазонов, которые нужно отсортировать.

4. Использование трехраздельного подхода (Dutch National Flag) для сортировки, который делит массив на три части: меньше опорного, равные опорному и больше опорного. Это эффективно работает для массивов с множественными одинаковыми элементами.

5. Использование **in-place** версии алгоритма, что позволяет выполнять сортировку без дополнительного выделения памяти для копирования массивов.

6. Параллельная реализация быстрой сортировки может значительно ускорить обработку на многоядерных системах, разбивая массив на части и сортируя их параллельно. Как в Arrays.parallelSort().

7. В некоторых реализациях можно оптимизировать сравнения, используя битовые операции или другие подходы, чтобы уменьшить количество необходимых операций.

8. При реализации рекурсивной функции можно оптимизировать вызовы, чтобы последний вызов функции был tail-recursive. Это позволяет компилятору оптимизировать использование стека.

9. Если обнаруживается, что выбранный опорный элемент приводит к плохому разделению, можно изменить выбор опорного элемента в будущем, чтобы добиться лучшего баланса.
# Преимущества

### Преимущества быстрой сортировки:

1. **Высокая средняя производительность (O(n log n))**: Быстрая сортировка в среднем работает за время O(n log n), что делает её более эффективной для больших массивов, чем простые алгоритмы сортировки, такие как сортировка вставками или пузырьковая сортировка, у которых сложность $O(n^2)$. Несмотря на то, что худший случай у быстрой сортировки тоже $O(n^2)$, на практике с использованием удачного выбора опорного элемента этот случай встречается редко.
2. **Малое использование дополнительной памяти**: В отличие от сортировки слиянием, которая требует O(n) дополнительной памяти для временных массивов, быстрая сортировка может быть реализована **ин-ситу (in-place)**, т.е. она сортирует элементы внутри исходного массива и требует лишь O(log n) дополнительной памяти для рекурсивных вызовов.
3. **Гибкость**: Быстрая сортировка хорошо работает с различными типами данных и эффективно обрабатывает даже частично отсортированные массивы. Она также может быть модифицирована для работы с определёнными специфическими типами данных или оптимизирована под конкретные задачи.
4. **Эффективность на практике**: Несмотря на то, что теоретически сложность быстрой сортировки в худшем случае — O(n^2), она на практике быстрее большинства других алгоритмов благодаря маленьким постоянным факторам, хорошей локальности данных и эффективному использованию кэш-памяти.
5. **Поддержка многопоточности**: Быстрая сортировка хорошо параллелизуется, так как каждая часть массива может сортироваться независимо. Это позволяет использовать её в многопоточных приложениях, что также может ускорить выполнение сортировки.

# Внутренняя реализация

- Для **примитивных типов данных** в `Arrays.sort()` используется модифицированный вариант быстрой сортировки, а для малых массивов — сортировка вставками. Порог (обычно 47 элементов) — это эмпирически подобранное значение для достижения максимальной производительности.
- Для **объектов** (`Object[]`) в `Arrays.sort()` используется алгоритм **Timsort** — это гибрид быстрой сортировки и сортировки слиянием, который также использует сортировку вставками для малых подмассивов.
# Ресурсы

- [Java. Быстрая сортировка.](https://www.youtube.com/watch?v=CeHJV4zu_Ts&list=PL5BhKu-LkR_0mDGftRWeaakqGuYE1ToGG&index=5)
- [Пишем и подробно разбираем алгоритм Quick Sort на JavaScript](https://www.youtube.com/watch?v=btS8Qf-wM2M)
- [Пишем и подробно разбираем алгоритм Quick Sort на JavaScript](https://www.youtube.com/watch?v=btS8Qf-wM2M)
- 