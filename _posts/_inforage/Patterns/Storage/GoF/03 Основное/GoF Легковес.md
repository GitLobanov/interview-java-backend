---
Определение: Позволяет вместить бóльшее количество объектов в отведённую оперативную память. Легковес экономит память, разделяя общее состояние объектов между собой, вместо хранения одинаковых данных в каждом объекте, он храни только ссылки на общий ресурс.
Тип:
  - Структурный
пример: Прокат автомобилей использует одни и те же машины для множества клиентов.
---
Приспособленец, Кэш, Flyweight

![[../../../../../_res/Pasted image 20241003121639.png]]
### Проблема

На досуге вы решили написать небольшую игру, в которой игроки перемещаются по карте и стреляют друг в друга. Фишкой игры должна была стать реалистичная система частиц. Пули, снаряды, осколки от взрывов — всё это должно красиво летать и радовать взгляд.

Игра отлично работала на вашем мощном компьютере. Однако ваш друг сообщил, что игра начинает тормозить и вылетает через несколько минут после запуска. Покопавшись в логах, вы обнаружили, что игра вылетает из-за недостатка оперативной памяти. У вашего друга компьютер значительно менее «прокачанный», поэтому проблема у него и проявляется так быстро.

И действительно, каждая частица представлена собственным объектом, имеющим множество данных. В определённый момент, когда побоище на экране достигает кульминации, новые объекты частиц уже не вмещаются в оперативную память компьютера, и программа вылетает.

![[../../../../../_res/Pasted image 20240901121535.png]]

### Решение 

Если внимательно посмотреть на класс частиц, то можно заметить, что цвет и спрайт занимают больше всего памяти. Более того, они хранятся в каждом объекте, хотя фактически их значения одинаковы для большинства частиц.

Паттерн Легковес предлагает не хранить в классе внешнее состояние, а передавать его в те или иные методы через параметры. Таким образом, одни и те же объекты можно будет повторно использовать в различных контекстах. Но главное — понадобится гораздо меньше объектов, ведь теперь они будут отличаться только внутренним состоянием, а оно имеет не так много вариаций.
#### Хранилище внешнего состояния

Но куда переедет внешнее состояние? Ведь кто-то должен его хранить. Чаще всего, его перемещают в контейнер, который управлял объектами до применения паттерна.

В нашем случае это был главный объект игры. Вы могли бы добавить в его класс поля-массивы для хранения координат, векторов и скоростей частиц. Кроме этого, понадобится ещё один массив для хранения ссылок на объекты-легковесы, соответствующие той или иной частице.
#### Неизменяемость Легковесов

Так как объекты легковесов будут использованы в разных контекстах, вы должны быть уверены в том, что их состояние невозможно изменить после создания. Всё внутреннее состояние легковес должен получать через параметры конструктора. Он не должен иметь сеттеров и публичных полей.
#### Фабрика Легковесов

Для удобства работы с легковесами и контекстами можно создать фабричный метод, принимающий в параметрах всё внутреннее (а иногда и внешнее) состояние желаемого объекта.

Главная польза от этого метода в том, чтобы искать уже созданные легковесы с таким же внутренним состоянием, что и требуемое. Если легковес находится, его можно повторно использовать. Если нет — просто создаём новый. Обычно этот метод добавляют в контейнер легковесов либо создают отдельный класс-фабрику. Его даже можно сделать статическим и поместить в класс легковесов.

### Пример

Представьте себе приложение, которое визуализирует текстовые документы. Каждая буква текста может быть представлена отдельным объектом, но шрифты, стили и размеры могут повторяться. Вместо того чтобы создавать отдельный объект для каждого символа, мы можем использовать паттерн Легковес, чтобы разделить общие данные (например, шрифт и размер) и уникальные данные (например, сам символ).

Интерфейс для Легковеса

```java
interface Glyph {
    void draw(int x, int y);  // Отображение символа в координатах (x, y)
}
```

Конкретные Легковесы

```java
class Character implements Glyph {
    private char symbol;
    private Font font;  // Общая часть состояния

    public Character(char symbol, Font font) {
        this.symbol = symbol;
        this.font = font;
    }

    @Override
    public void draw(int x, int y) {
        System.out.println("Drawing " + symbol + " at (" + x + ", " + y + ") with font " + font);
    }
}
```

Фабрика Легковесов

```java
import java.util.HashMap;
import java.util.Map;

class GlyphFactory {
    private Map<Character, Glyph> glyphs = new HashMap<>();
    
    public Glyph getGlyph(char symbol, Font font) {
        Glyph glyph = glyphs.get(symbol);
        if (glyph == null) {
            glyph = new Character(symbol, font);
            glyphs.put(symbol, glyph);
        }
        return glyph;
    }
}
```

Использование паттерна

```java
public class FlyweightExample {
    public static void main(String[] args) {
        GlyphFactory factory = new GlyphFactory();
        Font commonFont = new Font("Arial", Font.PLAIN, 12);

        // Получаем или создаем легковесные объекты
        Glyph a1 = factory.getGlyph('A', commonFont);
        Glyph a2 = factory.getGlyph('A', commonFont);
        Glyph b = factory.getGlyph('B', commonFont);

        // Используем легковесные объекты
        a1.draw(10, 10);
        a2.draw(20, 10);
        b.draw(30, 10);
    }
}
```
### Шаги реализации

1. Разделите поля класса, который станет легковесом, на две части:
    
    - внутреннее состояние: значения этих полей одинаковы для большого числа объектов;
    - внешнее состояние (контекст): значения полей уникальны для каждого объекта.
2. Оставьте поля внутреннего состояния в классе, но убедитесь, что их значения неизменяемы. Эти поля должны инициализироваться только через конструктор.
    
3. Превратите поля внешнего состояния в параметры методов, где эти поля использовались. Затем удалите поля из класса.
    
4. Создайте фабрику, которая будет кешировать и повторно отдавать уже созданные объекты. Клиент должен запрашивать из этой фабрики легковеса с определённым внутренним состоянием, а не создавать его напрямую.
    
5. Клиент должен хранить или вычислять значения внешнего состояния (контекст) и передавать его в методы объекта легковеса.

### Отношения с другими паттернами

- [[GoF Компоновщик]] часто совмещают с легковесом, чтобы реализовать общие ветки дерева и сэкономить при этом память.
    
- Легковес показывает, как создавать много мелких объектов, а [[GoF Фасад]] показывает, как создать один объект, который отображает целую подсистему.
    
- Паттерн легковес может напоминать [[GoF Одиничка]], если для конкретной задачи у получилось свести количество объектов к одному. Но помните, что между паттернами есть два кардинальных отличия:
    
    1. В отличие от _Одиночки_, вы можете иметь множество объектов-легковесов.
    2. Объекты-легковесы должны быть неизменяемыми, тогда как объект-одиночка допускает изменение своего состояния.