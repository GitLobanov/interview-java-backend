---
Определение: Позволяет подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то _до_ или _после_ передачи вызова оригиналу.
Тип:
  - Структурный
пример: Ассистент заказывает билеты вместо начальника.
---
Proxy

A Decorator is always passed its delegatee. A Proxy might create it himself, or he might have it injected.

A Decorator **requires** an instance of the interface it is wrapping, while a Proxy does **not require** such an instance. A Proxy _can_ receive an instance, but is also allowed to create this instance itself. So you can create a `new` Proxy on its own, while a Decorator _needs_ another instance as dependency.

**Tip:** Both Decorators and Proxies are allowed to add any extra functions or parameters that are _not on the interface_. It can therefore be wise to implement some magic `__isset()`, `__get()` and `__call()` methods on the Decorator or Proxy to pass these calls along to their inner instance as well. This way you can still call those methods and parameters even if you add multiple decorators on top.

![[../../../../../_res/Pasted image 20241122071810.png]]
### Проблема

Для чего вообще контролировать доступ к объектам? Рассмотрим такой пример: у вас есть внешний ресурсоёмкий объект, который нужен не все время, а изредка.

Мы могли бы создавать этот объект не в самом начале программы, а только тогда, когда он кому-то реально понадобится. Каждый клиент объекта получил бы некий код отложенной инициализации. Но, вероятно, это привело бы к множественному дублированию кода.

В идеале, этот код хотелось бы поместить прямо в служебный класс, но это не всегда возможно. Например, код класса может находиться в закрытой сторонней библиотеке.
### Решение 

Паттерн Заместитель предлагает создать новый класс-дублёр, имеющий тот же интерфейс, что и оригинальный служебный объект. При получении запроса от клиента объект-заместитель сам бы создавал экземпляр служебного объекта и переадресовывал бы ему всю реальную работу.

Но в чём же здесь польза? Вы могли бы поместить в класс заместителя какую-то промежуточную логику, которая выполнялась бы до (или после) вызовов этих же методов в настоящем объекте. А благодаря одинаковому интерфейсу, объект-заместитель можно передать в любой код, ожидающий сервисный объект.

В этом примере **Заместитель** помогает добавить в программу механизм ленивой инициализации и кеширования результатов работы библиотеки интеграции с YouTube.

![[../../../../../_res/Pasted image 20240901124132.png]]

Оригинальный объект начинал загрузку по сети, даже если пользователь запрашивал одно и то же видео. Заместитель же загружает видео только один раз, используя для этого служебный объект, но в остальных случаях возвращает закешированный файл.


### Пример

Представим, что у нас есть класс `RealImage`, который загружает и отображает изображение. Эта операция может быть ресурсозатратной. Мы можем использовать `ProxyImage`, который будет представлять изображение, но загрузит его только тогда, когда это действительно потребуется.

```java
interface Image {
    void display();
}

class RealImage implements Image {
    private String filename;

    public RealImage(String filename) {
        this.filename = filename;
        loadFromDisk();
    }

    private void loadFromDisk() {
        System.out.println("Загрузка " + filename);
    }

    @Override
    public void display() {
        System.out.println("Отображение " + filename);
    }
}

class ProxyImage implements Image {
    private RealImage realImage;
    private String filename;

    public ProxyImage(String filename) {
        this.filename = filename;
    }

    @Override
    public void display() {
        if (realImage == null) {
            realImage = new RealImage(filename);
        }
        realImage.display();
    }
}

public class Main {
    public static void main(String[] args) {
        Image image = new ProxyImage("image.jpg");

        // Изображение загружается только при первом вызове display()
        image.display();  // Выведет: "Загрузка image.jpg" и "Отображение image.jpg"
        image.display();  // Выведет: "Отображение image.jpg"
    }
}

```

### Шаги реализации

1. Определите интерфейс, который бы сделал заместитель и оригинальный объект взаимозаменяемыми.
    
2. Создайте класс заместителя. Он должен содержать ссылку на сервисный объект. Чаще всего, сервисный объект создаётся самим заместителем. В редких случаях заместитель получает готовый сервисный объект от клиента через конструктор.
    
3. Реализуйте методы заместителя в зависимости от его предназначения. В большинстве случаев, проделав какую-то полезную работу, методы заместителя должны передать запрос сервисному объекту.
    
4. Подумайте о введении фабрики, которая решала бы, какой из объектов создавать — заместитель или реальный сервисный объект. Но, с другой стороны, эта логика может быть помещена в создающий метод самого заместителя.
    
5. Подумайте, не реализовать ли вам ленивую инициализацию сервисного объекта при первом обращении клиента к методам заместителя.

### Отношения с другими паттернами

- С [[GoF Адаптер|Адаптер]] вы получаете доступ к существующему объекту через другой интерфейс. Используя **заместителя**, интерфейс остается неизменным. Используя [[GoF Декоратор|Декоратор]], вы получаете доступ к объекту через расширенный интерфейс.
    
- [[GoF Фасад]] похож на заместителя тем, что замещает сложную подсистему и может сам её инициализировать. Но в отличие от _Фасада_, _Заместитель_ имеет тот же интерфейс, что его служебный объект, благодаря чему их можно взаимозаменять.
    
- [[GoF Декоратор|Декоратор]] и **заместитель** имеют схожие структуры, но разные назначения. Они похожи тем, что оба построены на принципе композиции и делегируют работу другим объектам. Паттерны отличаются тем, что _Заместитель_ сам управляет жизнью сервисного объекта, а обёртывание _Декораторов_ контролируется клиентом. [[../02 Проблемы/В чем разница между Декоратором и Заместителем]]