---
Определение: Позволяет уменьшить связанность множества классов между собой, благодаря перемещению этих связей в один класс-посредник.
Тип:
  - Поведенческий
пример: Управляет взаимодействием между объектами, как диспетчер в авиадиспетчерской.
---
Intermediary, Controller, Mediator

Классы ходят не к друг другу, а к посреднику, который передает их поведение. Пример - чат который получает сообщение от пользователя и рассылает другим
### Проблема

Предположим, что у вас есть диалог создания профиля пользователя. Он состоит из всевозможных элементов управления — текстовых полей, чекбоксов, кнопок.

![[../../../../../_res/Pasted image 20240901135258.png]]

Отдельные элементы диалога должны взаимодействовать друг с другом. Так, например, чекбокс «у меня есть собака» открывает скрытое поле для ввода имени домашнего любимца, а клик по кнопке отправки запускает проверку значений всех полей формы.

Прописав эту логику прямо в коде элементов управления, вы поставите крест на их повторном использовании в других местах приложения. Они станут слишком тесно связанными с элементами диалога редактирования профиля, которые не нужны в других контекстах. Поэтому вы сможете использовать либо все элементы сразу, либо ни одного.

### Решение 

Паттерн Посредник заставляет объекты общаться не напрямую друг с другом, а через отдельный объект-посредник, который знает, кому нужно перенаправить тот или иной запрос. Благодаря этому, компоненты системы будут зависеть только от посредника, а не от десятков других компонентов.

В нашем примере посредником мог бы стать диалог. Скорее всего, класс диалога и так знает, из каких элементов состоит, поэтому никаких новых связей добавлять в него не придётся.

![[../../../../../_res/Pasted image 20240901135514.png]]

Основные изменения произойдут внутри отдельных элементов диалога. Если раньше при получении клика от пользователя объект кнопки сам проверял значения полей диалога, то теперь его единственной обязанностью будет сообщить диалогу о том, что произошёл клик. Получив извещение, диалог выполнит все необходимые проверки полей. Таким образом, вместо нескольких зависимостей от остальных элементов кнопка получит только одну — от самого диалога.

Чтобы сделать код ещё более гибким, можно выделить общий интерфейс для всех посредников, то есть диалогов программы. Наша кнопка станет зависимой не от конкретного диалога создания пользователя, а от абстрактного, что позволит использовать её и в других диалогах.

Таким образом, посредник скрывает в себе все сложные связи и зависимости между классами отдельных компонентов программы. А чем меньше связей имеют классы, тем проще их изменять, расширять и повторно использовать.

### Пример

```java
// Интерфейс посредника
interface Mediator {
    void registerUser(User user);
    void sendMessage(String message, User sender);
}

// Конкретный посредник
class ChatRoom implements Mediator {
    private List<User> users = new ArrayList<>();

    @Override
    public void registerUser(User user) {
        users.add(user);
    }

    @Override
    public void sendMessage(String message, User sender) {
        for (User user : users) {
            if (user != sender) {
                user.receiveMessage(message, sender);
            }
        }
    }
}

abstract class User {
    protected Mediator mediator;
    protected String name;

    public User(Mediator mediator, String name) {
        this.mediator = mediator;
        this.name = name;
    }

    public abstract void sendMessage(String message);
    public abstract void receiveMessage(String message, User sender);
}

class ConcreteUser extends User {
    public ConcreteUser(Mediator mediator, String name) {
        super(mediator, name);
    }

    @Override
    public void sendMessage(String message) {
        System.out.println(name + " отправляет сообщение: " + message);
        mediator.sendMessage(message, this);
    }

    @Override
    public void receiveMessage(String message, User sender) {
        System.out.println(name + " получает сообщение от " + sender.name + ": " + message);
    }
}


public class Main {
    public static void main(String[] args) {
        Mediator chatRoom = new ChatRoom();

        User alice = new ConcreteUser(chatRoom, "Alice");
        User bob = new ConcreteUser(chatRoom, "Bob");
        User charlie = new ConcreteUser(chatRoom, "Charlie");

        chatRoom.registerUser(alice);
        chatRoom.registerUser(bob);
        chatRoom.registerUser(charlie);

        alice.sendMessage("Привет всем!");
        bob.sendMessage("Привет, Алиса!");
        charlie.sendMessage("Привет, Алиса и Боб!");
    }
}

```

### Шаги реализации

1. Найдите группу тесно переплетённых классов, отвязав которые друг от друга, можно получить некоторую пользу. Например, чтобы повторно использовать их код в другой программе.
    
2. Создайте общий интерфейс посредников и опишите в нём методы для взаимодействия с компонентами. В простейшем случае достаточно одного метода для получения оповещений от компонентов.
    
    Этот интерфейс необходим, если вы хотите повторно использовать классы компонентов для других задач. В этом случае всё, что нужно сделать — это создать новый класс конкретного посредника.
    
3. Реализуйте этот интерфейс в классе конкретного посредника. Поместите в него поля, которые будут содержать ссылки на все объекты компонентов.
    
4. Вы можете пойти дальше и переместить код создания компонентов в класс посредника, после чего он может напоминать [[GoF Абстрактная фабрика|Абстрактную фабрику]] или [[GoF Фасад|Фасад]].
    
5. Компоненты тоже должны иметь ссылку на объект посредника. Связь между ними удобнее всего установить, подавая посредника в параметры конструктора компонентов.
    
6. Измените код компонентов так, чтобы они вызывали метод оповещения посредника, вместо методов других компонентов. С противоположной стороны, посредник должен вызывать методы нужного компонента, когда получает оповещение от компонента.

### Отношения с другими паттернами

- [[GoF Цепочка обязанностей]], [[GoF Команда]], [[GoF Посредник]] и [[GoF Наблюдатель]] показывают различные способы работы отправителей запросов с их получателями:
    
    - _Цепочка обязанностей_ передаёт запрос последовательно через цепочку потенциальных получателей, ожидая, что какой-то из них обработает запрос.
    - _Команда_ устанавливает косвенную одностороннюю связь от отправителей к получателям.
    - _Посредник_ убирает прямую связь между отправителями и получателями, заставляя их общаться опосредованно, через себя.
    - _Наблюдатель_ передаёт запрос одновременно всем заинтересованным получателям, но позволяет им динамически подписываться или отписываться от таких оповещений.
- [[GoF Посредник]] и [[GoF Фасад]] похожи тем, что пытаются организовать работу множества существующих классов.
    
    - _Фасад_ создаёт упрощённый интерфейс к подсистеме, не внося в неё никакой добавочной функциональности. Сама подсистема не знает о существовании _Фасада_. Классы подсистемы общаются друг с другом напрямую.
    - _Посредник_ централизует общение между компонентами системы. Компоненты системы знают только о существовании _Посредника_, у них нет прямого доступа к другим компонентам.
- Разница между [[GoF Посредник]] и [[GoF Наблюдатель]] не всегда очевидна. Чаще всего они выступают как конкуренты, но иногда могут работать вместе.
    
    Цель _Посредника_ — убрать обоюдные зависимости между компонентами системы. Вместо этого они становятся зависимыми от самого посредника. С другой стороны, цель _Наблюдателя_ — обеспечить динамическую одностороннюю связь, в которой одни объекты косвенно зависят от других.
    
    Довольно популярна реализация _Посредника_ при помощи _Наблюдателя_. При этом объект посредника будет выступать издателем, а все остальные компоненты станут подписчиками и смогут динамически следить за событиями, происходящими в посреднике. В этом случае трудно понять, чем же отличаются оба паттерна.
    
    Но _Посредник_ имеет и другие реализации, когда отдельные компоненты жёстко привязаны к объекту посредника. Такой код вряд ли будет напоминать _Наблюдателя_, но всё же останется _Посредником_.
    
    Напротив, в случае реализации посредника с помощью _Наблюдателя_ представим такую программу, в которой каждый компонент системы становится издателем. Компоненты могут подписываться друг на друга, в то же время не привязываясь к конкретным классам. Программа будет состоять из целой сети _Наблюдателей_, не имея центрального объекта-_Посредника_.