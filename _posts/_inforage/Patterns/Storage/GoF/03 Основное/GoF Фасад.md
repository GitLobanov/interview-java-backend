---
Определение: Предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.
Тип:
  - Структурный
пример: "Туристическое агентство организует все услуги: перелет, отель, экскурсии."
---
Facade

SLF4J предоставляет единый API для разных логгеров (например, Logback, Log4j, java.util.logging). SLF4J — это фасад для библиотек логирования.

![[../../../../../_res/Pasted image 20241003122552.png]]
### Проблема

Вашему коду приходится работать с большим количеством объектов некой сложной библиотеки или фреймворка. Вы должны самостоятельно инициализировать эти объекты, следить за правильным порядком зависимостей и так далее.

В результате бизнес-логика ваших классов тесно переплетается с деталями реализации сторонних классов. Такой код довольно сложно понимать и поддерживать.

### Решение 

Фасад — это простой интерфейс для работы со сложной подсистемой, содержащей множество классов. Фасад может иметь урезанный интерфейс, не имеющий 100% функциональности, которой можно достичь, используя сложную подсистему напрямую. Но он предоставляет именно те фичи, которые нужны клиенту, и скрывает все остальные.

Фасад полезен, если вы используете какую-то сложную библиотеку со множеством подвижных частей, но вам нужна только часть её возможностей.

К примеру, программа, заливающая видео котиков в социальные сети, может использовать профессиональную библиотеку сжатия видео. Но все, что нужно клиентскому коду этой программы — простой метод `encode(filename, format)`. Создав класс с таким методом, вы реализуете свой первый фасад.

### Пример

Рассмотрим пример использования паттерна **Фасад** в контексте домашнего кинотеатра. Допустим, у нас есть сложная система, состоящая из множества компонентов, таких как телевизор, усилитель, DVD-плеер и система освещения. Мы создадим фасад, который упростит управление этой системой для пользователя.

Для начала создадим классы, представляющие компоненты системы домашнего кинотеатра.

```java
// Класс для управления телевизором
class TV {
    public void on() {
        System.out.println("TV is ON");
    }

    public void off() {
        System.out.println("TV is OFF");
    }

    public void setChannel(int channel) {
        System.out.println("TV channel set to " + channel);
    }
}

// Класс для управления усилителем
class Amplifier {
    public void on() {
        System.out.println("Amplifier is ON");
    }

    public void off() {
        System.out.println("Amplifier is OFF");
    }

    public void setVolume(int volume) {
        System.out.println("Amplifier volume set to " + volume);
    }
}

// Класс для управления DVD-плеером
class DVDPlayer {
    public void on() {
        System.out.println("DVD Player is ON");
    }

    public void off() {
        System.out.println("DVD Player is OFF");
    }

    public void play(String movie) {
        System.out.println("Playing movie: " + movie);
    }
}

// Класс для управления системой освещения
class Lights {
    public void dim(int level) {
        System.out.println("Lights dimmed to " + level + "%");
    }

    public void on() {
        System.out.println("Lights are ON");
    }
}
```

Теперь создадим класс HomeTheaterFacade, который будет упрощать управление всеми этими компонентами.

```java
// Класс Фасад
class HomeTheaterFacade {
    private TV tv;
    private Amplifier amplifier;
    private DVDPlayer dvdPlayer;
    private Lights lights;

    public HomeTheaterFacade(TV tv, Amplifier amplifier, DVDPlayer dvdPlayer, Lights lights) {
        this.tv = tv;
        this.amplifier = amplifier;
        this.dvdPlayer = dvdPlayer;
        this.lights = lights;
    }

    // Упрощенный метод для запуска системы
    public void watchMovie(String movie) {
        System.out.println("Get ready to watch a movie...");
        lights.dim(30);
        tv.on();
        amplifier.on();
        amplifier.setVolume(5);
        dvdPlayer.on();
        dvdPlayer.play(movie);
    }

    // Упрощенный метод для завершения просмотра
    public void endMovie() {
        System.out.println("Shutting down the home theater...");
        lights.on();
        tv.off();
        amplifier.off();
        dvdPlayer.off();
    }
}
```

Теперь клиент может использовать фасад, чтобы управлять домашним кинотеатром, не беспокоясь о деталях работы отдельных компонентов.

```java
public class Main {
    public static void main(String[] args) {
        // Создаем компоненты системы
        TV tv = new TV();
        Amplifier amplifier = new Amplifier();
        DVDPlayer dvdPlayer = new DVDPlayer();
        Lights lights = new Lights();

        // Создаем фасад
        HomeTheaterFacade homeTheater = new HomeTheaterFacade(tv, amplifier, dvdPlayer, lights);

        // Используем фасад для управления системой
        homeTheater.watchMovie("Inception");
        homeTheater.endMovie();
    }
}
```
### Шаги реализации

1. Определите, можно ли создать более простой интерфейс, чем тот, который предоставляет сложная подсистема. Вы на правильном пути, если этот интерфейс избавит клиента от необходимости знать о подробностях подсистемы.
    
2. Создайте класс фасада, реализующий этот интерфейс. Он должен переадресовывать вызовы клиента нужным объектам подсистемы. Фасад должен будет позаботиться о том, чтобы правильно инициализировать объекты подсистемы.
    
3. Вы получите максимум пользы, если клиент будет работать только с фасадом. В этом случае изменения в подсистеме будут затрагивать только код фасада, а клиентский код останется рабочим.
    
4. Если ответственность фасада начинает размываться (большое нарушение [[../../../../Java/Рефакторинг/Single Responsibility]]), подумать о создании других фасадов.

### Отношения с другими паттернами

- [[GoF Фасад|Фасад]] задает новый интерфейс, тогда как [[GoF Адаптер|Адаптер]] повторно использует старый. [[GoF Адаптер|Адаптер]] оборачивает только один класс, а Фасад оборачивает целую подсистему. Кроме того, Адаптер позволяет [[GoF Адаптер|Адаптер]] двум существующим интерфейсам сообща, вместо того, чтобы задать полностью новый.
    
- [[GoF Абстрактная фабрика]] может быть использована вместо [[GoF Фасад]] для того, чтобы скрыть платформо-зависимые классы.
    
- [[GoF Легковес]] показывает, как создавать много мелких объектов, а [[GoF Фасад]] показывает, как создать один объект, который отображает целую подсистему.
    
- [[GoF Посредник]] и [[GoF Фасад]] похожи тем, что пытаются организовать работу множества существующих классов.
    
    - _Фасад_ создаёт упрощённый интерфейс к подсистеме, не внося в неё никакой добавочной функциональности. Сама подсистема не знает о существовании _Фасада_. Классы подсистемы общаются друг с другом напрямую.
    - _Посредник_ централизует общение между компонентами системы. Компоненты системы знают только о существовании _Посредника_, у них нет прямого доступа к другим компонентам.
- [[GoF Фасад]] можно сделать [[GoF Одиничка|Одичнкой]], так как обычно нужен только один объект-фасад.
    
- [[GoF Фасад]] похож на [[GoF Заместитель|Заместителя]] тем, что замещает сложную подсистему и может сам её инициализировать. Но в отличие от _Фасада_, _Заместитель_ имеет тот же интерфейс, что его служебный объект, благодаря чему их можно взаимозаменять.