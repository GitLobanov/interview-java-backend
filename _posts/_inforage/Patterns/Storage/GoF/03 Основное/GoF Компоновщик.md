---
Определение: Компонует множество объектов в древовидную структуру, позволяя обращаться к отдельному объекту или целому поддереву
Тип:
  - Структурный
пример: Папка на компьютере содержит и файлы, и другие папки.
---
Дерево, Composite

Lib JSOB (JSON, File)

![[../../../../../_res/Pasted image 20241003120929.png]]
### Проблема

Паттерн Компоновщик имеет смысл только тогда, когда основная модель вашей программы может быть структурирована в виде дерева.

Например, есть два объекта: `Продукт` и `Коробка`. `Коробка` может содержать несколько `Продуктов` и других `Коробок` поменьше. Те, в свою очередь, тоже содержат либо `Продукты`, либо `Коробки` и так далее.

Теперь предположим, ваши `Продукты` и `Коробки` могут быть частью заказов. Каждый заказ может содержать как простые `Продукты` без упаковки, так и составные `Коробки`. Ваша задача состоит в том, чтобы узнать цену всего заказа.

![[../../../../../_res/Pasted image 20240901114533.png]]

Если решать задачу в лоб, то потребуется открыть все коробки заказа, перебрать все продукты и посчитать их суммарную стоимость. Но это слишком хлопотно, так как типы коробок и их содержимое могут быть вам неизвестны. Кроме того, наперёд неизвестно и количество уровней вложенности коробок, поэтому перебрать коробки простым циклом не выйдет.

### Решение 

Компоновщик предлагает рассматривать `Продукт` и `Коробку` через единый интерфейс с общим методом получения стоимости.

`Продукт` просто вернёт свою цену. `Коробка` спросит цену каждого предмета внутри себя и вернёт сумму результатов. Если одним из внутренних предметов окажется коробка поменьше, она тоже будет перебирать своё содержимое, и так далее, пока не будут посчитаны все составные части.

![[../../../../../_res/Pasted image 20240901114651.png]]

### Пример

<mark style="background: #FFB86CA6;">отличный пример</mark>
В Swing, GUI (графический пользовательский интерфейс) компоненты могут быть объединены в иерархическую структуру, где отдельные компоненты и контейнеры (которые могут содержать другие компоненты) обрабатываются одинаково. Это в точности соответствует идее паттерна Компоновщик.
#### Дополнительный пример реализации:

Представьте, что у вас есть графический редактор, который работает с различными графическими элементами, такими как **прямоугольники**, **круги**, **линии** и **группы объектов**. Вам нужно создать систему, которая позволит вам работать как с отдельными элементами, так и с группами элементов одинаковым образом.

Все графические элементы (примитивы и группы) будут реализовывать интерфейс `Graphic`, который определяет метод `draw` для отрисовки элемента.

```java
interface Graphic {
    void draw();  // Метод для отрисовки графического элемента
}
```

Классы `Circle`, `Rectangle`, и `Line` представляют примитивные графические элементы. Каждый из них реализует интерфейс `Graphic`.

```java
class Circle implements Graphic {
    @Override
    public void draw() {
        System.out.println("Drawing a circle");
    }
}

class Rectangle implements Graphic {
    @Override
    public void draw() {
        System.out.println("Drawing a rectangle");
    }
}

class Line implements Graphic {
    @Override
    public void draw() {
        System.out.println("Drawing a line");
    }
}
```

Класс `CompositeGraphic` представляет группу графических элементов. Он также реализует интерфейс `Graphic` и может содержать как примитивные элементы, так и другие группы элементов.

```java
import java.util.ArrayList;
import java.util.List;

class CompositeGraphic implements Graphic {
    private List<Graphic> children = new ArrayList<>();

    // Добавление элемента в группу
    public void add(Graphic graphic) {
        children.add(graphic);
    }

    // Удаление элемента из группы
    public void remove(Graphic graphic) {
        children.remove(graphic);
    }

    // Отрисовка всех элементов в группе
    @Override
    public void draw() {
        for (Graphic graphic : children) {
            graphic.draw();
        }
    }
}
```

Теперь вы можете создавать отдельные графические элементы, объединять их в группы и отрисовывать как отдельные элементы, так и группы целиком.

```java
public class Main {
    public static void main(String[] args) {
        // Создаем примитивные графические элементы
        Graphic circle = new Circle();
        Graphic rectangle = new Rectangle();
        Graphic line = new Line();

        // Создаем группу графических элементов
        CompositeGraphic group1 = new CompositeGraphic();
        group1.add(circle);
        group1.add(rectangle);

        // Создаем другую группу, которая включает первую группу
        CompositeGraphic group2 = new CompositeGraphic();
        group2.add(group1);  // Добавляем первую группу
        group2.add(line);    // Добавляем линию

        // Отрисовываем все элементы в группе group2
        group2.draw();
    }
}
```

### Шаги реализации

1. Убедитесь, что вашу бизнес-логику можно представить как древовидную структуру. Попытайтесь разбить её на простые компоненты и контейнеры. Помните, что контейнеры могут содержать как простые компоненты, так и другие вложенные контейнеры.
    
2. Создайте общий интерфейс компонентов, который объединит операции контейнеров и простых компонентов дерева. Интерфейс будет удачным, если вы сможете использовать его, чтобы взаимозаменять простые и составные компоненты без потери смысла.
    
3. Создайте класс компонентов-листьев, не имеющих дальнейших ответвлений. Имейте в виду, что программа может содержать несколько таких классов.
    
4. Создайте класс компонентов-контейнеров и добавьте в него массив для хранения ссылок на вложенные компоненты. Этот массив должен быть способен содержать как простые, так и составные компоненты, поэтому убедитесь, что он объявлен с типом интерфейса компонентов.
    
    Реализуйте в контейнере методы интерфейса компонентов, помня о том, что контейнеры должны делегировать основную работу своим дочерним компонентам.
    
5. Добавьте операции добавления и удаления дочерних компонентов в класс контейнеров.
    
    Имейте в виду, что методы добавления/удаления дочерних компонентов можно поместить и в интерфейс компонентов. Да, это нарушит _принцип разделения интерфейса_, так как реализации методов будут пустыми в компонентах-листьях. Но зато все компоненты дерева станут действительно одинаковыми для клиента.

### Отношения с другими паттернами

- [[GoF Строитель]] позволяет пошагово сооружать дерево Компоновщика.
    
- [[GoF Цепочка обязанностей]] часто используют вместе с Компоновщиком. В этом случае запрос передаётся от дочерних компонентов к их родителям.
    
- Можем обходить дерево Компоновщика, используя Итератор.
    
- Можем выполнить какое-то действие над всем деревоv Компоновщика при помощи [[GoF Посетитель]].
    
- Часто совмещают с [[GoF Легковес]], чтобы реализовать общие ветки дерева и сэкономить при этом память.
    
- Компоновщик и [[GoF Декоратор]] имеют похожие структуры классов из-за того, что оба построены на [[../../../../Java/Core/Рекурсия|рекурсивной]] вложенности. Она позволяет связать в одну структуру бесконечное количество объектов.
    
    _Декоратор_ оборачивает только один объект, а узел _Компоновщика_ может иметь много детей. _Декоратор_ добавляет вложенному объекту новую функциональность, а _Компоновщик_ не добавляет ничего нового, но «суммирует» результаты всех своих детей.
    
    Но они могут и сотрудничать: _Компоновщик_ может использовать _Декоратор_, чтобы переопределить функции отдельных частей дерева компонентов.
    
- Архитектура, построенная на Компоновщике и [[GoF Декоратор]], часто может быть улучшена за счёт внедрения [[GoF Прототип]]. Он позволяет клонировать сложные структуры объектов, а не собирать их заново.