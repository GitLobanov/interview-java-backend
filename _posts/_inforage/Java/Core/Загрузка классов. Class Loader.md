## Этапы загрузки

- Загрузка (loading) — поиск и импорт бинарных данных для типа по его имени, создание класса или интерфейса из этого бинарного представления.
- Связывание, линковка (linking) — выполнение верификации, подготовки и, необязательного, разрешения:  
    - Верификация (verification) — проверка корректности импортируемого типа.
    - Подготовка (preparation) — выделение памяти для статических переменных класса и инициализация памяти значениями по умолчанию.
    - Разрешение (resolution) — преобразование символьных ссылок типов в прямые ссылки.
- Инициализация (initialization) — вызов Java-кода, который инициализирует переменные класса их правильными начальными значениями.

![[../../../_res/Pasted image 20241006121025.png]]
# Виды Class Loader

- Bootstrap ClassLoader: Загружает классы из стандартной Java платформы (`rt.jar`), такие как `java.lang.Object` и `java.util.ArrayList`.  
- Platform ClassLoader: Загружает остальные библиотеки из JDK `(jdk/jre/lib/ext)`  
- Application ClassLoader: Загружает классы из классовых путей, указанных в `CLASSPATH` (например, классы вашего приложения и сторонних библиотек).  
- Custom ClassLoader: Пользовательские загрузчики классов.
# Процесс

### 1. Загрузка класса (Class Loading)

На этом этапе класс загружается в память. При загрузке класс еще не связан с другими классами, и его поля не инициализированы. Этот процесс осуществляется загрузчиком классов (`ClassLoader`).

Пример загрузки класса:

`Class<?> clazz = Class.forName("com.example.MyClass");`

### 2. Связывание класса (Linking)

В этом этапе класс проверяется на наличие ошибок, и происходит связывание с другими классами, а также инициализация статических полей. Linking делится на три подэтапа:

- Проверка (Verification): Проверяет, что класс корректен и соответствует спецификации языка Java. Это помогает предотвратить загрузку классов, содержащих ошибки или нарушения безопасности.
- Подключение (Preparation): Инициализирует статические переменные класса значениями по умолчанию (например, `0` для `int`, `null` для объектов). Это происходит перед выполнением статических инициализаторов.
- Разрешение (Resolution): Преобразует символические ссылки на классы, методы и поля в ссылки на действительные объекты. Это позволяет JIT-компилятору и виртуальной машине Java (JVM) находить конкретные классы и методы.
### 3. Инициализация класса (Initialization)

Инициализация класса — это процесс выполнения статических инициализаторов и статических блоков инициализации класса. Этот этап выполняется, когда класс впервые используется, например, при создании экземпляра класса или вызове статического метода.

Пример статического блока инициализации:

![[../../../_res/Pasted image 20240829132037.png]]

Когда создаете новый экземпляр `MyClass`, сначала выполняется статический блок, а затем конструктор.
### Специальные случаи

- Lazy Initialization: Классы инициализируются только при первом использовании. Это помогает избежать ненужных затрат на ресурсы при загрузке классов, которые могут не понадобиться.
- Initialization-on-demand: Классы могут быть инициализированы только когда это требуется, что также помогает оптимизировать производительность.

# Принципы

##  Основные принципы ClassLoader в Java:

1. Делегирование загрузки более высокому загрузчику (Delegation Model)
2. Иерархическая структура загрузчиков (Hierarchy Model)
3. Изоляция классов (ClassLoader Isolation)
4. Реиспользование загруженных классов (Class Reuse)
5. Ограничение видимости загруженных классов (Visibility)

## 1. Принцип делегирования (Delegation Model)

Этот принцип означает, что каждый `ClassLoader` сначала делегирует загрузку класса своему родительскому загрузчику (более высокоуровневому). Если родительский загрузчик не может найти или загрузить класс, то только тогда текущий `ClassLoader` пытается его загрузить. Это помогает предотвратить конфликт между разными версиями классов и гарантировать, что стандартные классы (например, `java.lang.*`) будут загружены только один раз и в единственном экземпляре.

- Bootstrap ClassLoader (на уровне JVM) — самый верхний и основной загрузчик, который загружает стандартные классы Java (например, классы из `rt.jar`).
- Extension ClassLoader — загружает классы из расширений Java (например, JRE расширений).
- Application ClassLoader — загружает классы приложения с пути `classpath`.

### 2. Принцип иерархии (Hierarchy Model)

Загрузчики классов образуют иерархическую структуру. Каждый загрузчик имеет ссылку на родительский загрузчик, который находится выше по иерархии. В результате загрузка классов происходит снизу вверх, начиная с `Application ClassLoader` (или пользовательского загрузчика) и проходя через родительские загрузчики, пока не дойдет до корневого загрузчика (`Bootstrap ClassLoader`).

- Пользовательские ClassLoader'ы могут наследоваться от других ClassLoader'ов, формируя цепочку загрузки классов.

### 3. Изоляция (ClassLoader Isolation)

Каждый `ClassLoader` может загружать классы в своё собственное пространство имен. Это означает, что один и тот же класс с одинаковым именем может быть загружен двумя разными `ClassLoader'ами`, и он будет считаться разными классами с точки зрения JVM. Это особенно важно в случае модульных или плагинных архитектур.

- Это позволяет, например, изолировать классы разных модулей или приложений друг от друга в одном JVM.

### 4. Реиспользование классов (Class Reuse)

Один и тот же класс, загруженный родительским `ClassLoader`, может быть использован всеми потомками этого загрузчика. Это предотвращает многократную загрузку одного и того же класса в разных частях приложения. При этом загруженные родительским `ClassLoader` классы автоматически видимы для дочерних загрузчиков.

### 5. Ограничение видимости (Visibility)

Загруженные классы видны только тому `ClassLoader`, который их загрузил, и всем дочерним `ClassLoader'ам`. В обратную сторону — от дочернего к родительскому — видимость не распространяется. Это также является частью иерархической модели.

# Resources

- [Внутренности JVM, Часть 1 — Загрузчик классов](https://habr.com/ru/companies/otus/articles/468193/)
- 