> Интерфейс `Collector` инкапсулирует процесс комбинирования элементов потока в одну итоговую структуру.

![[../../../../_res/screen-787.webp]]

Класс `Collectors` содержит набор предопределённых статических методов для выполнения общих операций, таких как преобразование элементов в списки, множества и другие структуры данных.

Некоторые популярные методы класса `Collectors`:

- `toList()`: Возвращает коллектор, который собирает элементы в список.
- `toSet()`: Собирает элементы в множество.
- `joining()`: Объединяет элементы потока в одну строку.
- `counting()`: Подсчитывает количество элементов в потоке.
- `toCollection(new HashSet())` 
- `toMap(p->p.getName(), t->t.getPrice())`

Следующий пример показывает, как можно создать собственный коллектор, который накапливает элементы в список. В данном случае используется лямбда-выражение для определения поведения коллектора.

```java
Stream<?> stream;
List<?> list = stream.collect(Collectors.toList());

//Коллектор выше аналогичен данному коду
list = stream.collect(
        () -> new ArrayList<>(), // определяем структуру
        (list, t) -> list.add(t), // определяем, как добавлять элементы
        (l1, l2) -> l1.addAll(l2) // и как объединять две структуры в одну
);
```


```java
Collectors.groupingBy(Function keyExtractor) - вернет Map<Key, List<?>>, т.е. группирует элементы стримп по ключу  

Collectors.partitioningBy(Predicate) - вернет Map<Boolean, List<?>>, т.е. группирует элементы стрима по предикату  

Collectors.toList() - вернет лист с объектами стрима  

Collectors.counting() - вернет количество элементов стрима  

Collectors.maxBy(Predicate) - вернет максимальный элемент стрима по предикату.  
```

```java
Supplier<A> supplier() - возвращает объект контейнера  

BiConsumer<A, T> accumulator() - кладет новый элемент в контейнер  

BinaryOperator<A> combiner() - объединяет два контейнера в один. Используется при параллельности.  

Function<A, R> finisher() - преобразует для преобразования контейнера в финальный результат.  

Set<Characteristics> characteristics() - возвращает характеристики коллектора, которые используются для внутренних оптимизаций.

CONCURRENT - коллектор поддерживает многопоточность (контейнер может пополнятся из разных потоков)

UNORDERED - не зависит от порядка поступаемых элементов

IDENTITY_FINISH - finisher() имеет реализацию Function.identity() - следовательно его можно не вызывать
```



