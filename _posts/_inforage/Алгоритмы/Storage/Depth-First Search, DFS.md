- Начните с корневой вершины.
- Пометьте текущую вершину как посещённую.
- Для каждой непосещённой соседней вершины:
    - Рекурсивно примените DFS.
- Если все соседние вершины посещены, вернитесь к предыдущей вершине.

![[../../../_res/Pasted image 20241028100001.png]]

# Use cases

## 1. Поиск в графах

- Социальные сети: Определение связей между пользователями, поиск друзей, исследование связности графа.
- Поиск путей: Поиск маршрутов в картах (например, от одного места к другому, учитывая разные пути).

 1. Подготовка графа. Граф может быть представлен в виде:

- **Списка смежности**: Каждая вершина хранит список её соседей.
- **Матрицы смежности**: Двумерный массив, где значение указывает наличие или отсутствие ребра между вершинами.

 2. Инициализация

- **Структура данных для отслеживания посещённых вершин**: Можно использовать массив, список или множество для хранения информации о том, какие вершины уже были посещены.
- **Стек**: DFS можно реализовать как рекурсивную функцию или с использованием стека. Стек используется для хранения вершин, которые необходимо исследовать. В рекурсивной реализации стек управляется автоматически через стек вызовов.

 3. Алгоритм. Вот общий процесс реализации DFS:

1. **Выбор начальной вершины**: Начинаем обход с определенной начальной вершины (например, `start`).
2. **Посещение вершины**:
    - Отметить вершину как посещённую (например, добавив её в множество посещённых).
    - Обработать вершину (например, вывести её значение или сохранить в результирующий список).
3. **Рекурсивный обход**:
    - Для каждого соседа текущей вершины:
        - Если сосед ещё не посещён, вызвать DFS для этого соседа (рекурсивно или с использованием стека).
4. **Возврат**:
    - Вернуться назад, когда все соседи текущей вершины обработаны.

4. **Временная сложность**: O(V + E), где V — количество вершин, а E — количество рёбер в графе. Это объясняется тем, что каждая вершина и каждое ребро обрабатываются ровно один раз.
## 2. Решение головоломок

- Лабиринты: Как мы рассмотрели, DFS помогает находить пути в лабиринтах и решать задачи о кратчайшем пути.
- Судоку и другие логические игры: DFS может использоваться для генерации и решения головоломок.

 3. Топологическая сортировка

- Управление зависимостями: В проектах с большим количеством модулей (например, в системах сборки) DFS может помочь в определении порядка сборки.

4. Анализ данных

- Обход структурированных данных: DFS используется для анализа сложных структур данных, таких как XML и JSON.

5. Обнаружение циклов

- Проверка графов: В системах, где важна проверка на циклы, например, в графах зависимостей.

6. Поиск компонентов связности

- Сети: В сетевых приложениях для определения компонент связности и проверки доступности узлов.

7. Обход файловых систем

- Иерархические структуры: Обход каталогов и файлов для выполнения операций, таких как поиск, фильтрация и обработка файлов.

8. Искусственный интеллект

- Игры: Использование DFS для создания игровых AI, которые исследуют возможные ходы.

# Пример: Найти путь в лабиринте

> Найти путь от верхнего левого угла (0, 0) до нижнего правого угла (4, 4).

```
[
  [0, 1, 0, 0, 0],
  [0, 1, 0, 1, 0],
  [0, 0, 0, 1, 0],
  [1, 1, 0, 0, 0],
  [0, 0, 1, 1, 0]
]
```

```java
public class MazeSolver {
    private static final int[] ROWS = {0, 0, -1, 1}; // Смещения по строкам (вверх, вниз)
    private static final int[] COLS = {-1, 1, 0, 0}; // Смещения по столбцам (влево, вправо)

    public static void main(String[] args) {
        int[][] maze = {
            {0, 1, 0, 0, 0},
            {0, 1, 0, 1, 0},
            {0, 0, 0, 1, 0},
            {1, 1, 0, 0, 0},
            {0, 0, 1, 1, 0}
        };

        List<String> path = new ArrayList<>();
        if (dfs(maze, 0, 0, path)) {
            System.out.println("Путь найден: " + path);
        } else {
            System.out.println("Путь не найден.");
        }
    }

    private static boolean dfs(int[][] maze, int row, int col, List<String> path) {
        // Проверка выхода за пределы, стен и посещенных клеток
        if (row < 0 || row >= maze.length || col < 0 || col >= maze[0].length || 
            maze[row][col] == 1) {
            return false;
        }
        
        // Если достигли правого нижнего угла, возвращаем true
        if (row == maze.length - 1 && col == maze[0].length - 1) {
            path.add("(" + row + ", " + col + ")");
            return true;
        }

        // Отметить текущую клетку как посещенную
        maze[row][col] = 1;
        path.add("(" + row + ", " + col + ")");

        // Рекурсивно исследуем соседние клетки
        for (int i = 0; i < 4; i++) {
            int newRow = row + ROWS[i];
            int newCol = col + COLS[i];
            if (dfs(maze, newRow, newCol, path)) {
                return true; // Если путь найден, возвращаем true
            }
        }

        // Если ни один из путей не сработал, откатимся (backtrack)
        path.remove(path.size() - 1);
        maze[row][col] = 0; // Отметить как непосещенную для других путей
        return false;
    }
}
```