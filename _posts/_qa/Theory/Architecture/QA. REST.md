## QA

###### Принципы REST? 

- **Клиент-серверная архитектура**: Клиент и сервер работают независимо друг от друга. Клиент отправляет запросы на сервер, сервер их принимает и возвращает ответы. Это позволяет развиваться клиенту и серверу независимо друг от друга
- **Stateless (Отсутствие состояния)**: Сервер не сохраняет информацию о состоянии клиента между запросами. Информация о текущей сессии должна целиком храниться у клиента
- **Кеширование**: В REST API сервер может запомнить результаты частых запросов, чтобы быстрее их вернуть и не тратить ресурсы на повторные вычисления.
- **Единообразие интерфейса**: В API используются стандартные команды (GET, POST, PUT, DELETE), чтобы взаимодействие было простым и предсказуемым
- **Многоуровневость системы**: Система может быть разделена на несколько слоев, каждый из которых выполняет свою задачу. Между клиентом и сервером могут быть посредники (например балансировщик или proxy-сервер). При правильном построении слоистой архитектуры слои не будут влиять друг на друга, т.е., например, при изменении логики в proxy-сервере, ни клиент, ни сервер об этом даже не узнают
- **Код по требованию**: Иногда сервер может отправлять клиенту код (например, скрипты), который клиент может использовать для выполнения задач
###### Зрелости RESTful сервиса

[Зрелость RESTful сервиса](../../../_inforage/Компсети/03%20Storage/Зрелость%20RESTful%20сервиса.md)
###### RESTful и RESTless

_RESTful_ строго следует принципам REST, используя стандартные методы HTTP и четко структурированные URL, а _RESTless_ нарушает эти принципы, делая взаимодействие менее стандартным и гибким
###### Stateless относится к клиенту или серверу?

- Клиент может хранить состояние (например, токены).
- Сервер обрабатывает каждый запрос независимо.
- Stateless — как общение с роботом: вы говорите «Привет» каждый раз, и он не помнит, что вы уже знакомы.

Исключения:
- **Cookies** — технически нарушают Stateless, но используются для удобства (например, аутентификация).
- **Серверные кеши** — могут временно хранить данные, но не состояние клиента.

###### Что подразумевается под единообразием интерфейса?

- **Идентификация ресурсов** (URI) — каждый ресурс имеет уникальный URL.
- **Манипуляция через представление** — клиент работает с ресурсом через стандартные HTTP-методы (`GET`, `POST`, `PUT`, `DELETE`).
- **Гипермедиа (HATEOAS)** — ответы включают ссылки на связанные ресурсы (например, `next`, `prev` в пагинации).

Пример:

```json
Ответ от сервера содержит ссылки для навигации:
{
  "accountId": "A1",
  "balance": 5000,
  "_links": {
    "transactions": { "href": "/api/transactions?accountId=A1" },
    "transfer": { "href": "/api/transactions" }
  }
}
- React использует эти ссылки для динамического построения UI (например, кнопка «Показать транзакции»).
```

```java
@GetMapping("/{id}")
public EntityModel<AccountDTO> getAccount(@PathVariable String id) {
    AccountDTO account = service.getAccount(id);
    return EntityModel.of(account,
        linkTo(methodOn(AccountController.class)
	        .getAccount(id)).withSelfRel(),
        linkTo(methodOn(TransactionController.class)
	        .getTransactions(id)).withRel("transactions")
    );
}
```

###### Какие HTTP методы считаются идемпотентными?

**Идемпотентность** — это свойство HTTP-запроса, при котором **повторный вызов запроса дает тот же результат**, что и первый вызов (без дополнительных побочных эффектов).

**✅ Идемпотентные HTTP-методы**

| **Метод**   | **Описание**                                | **Идемпотентен?**                       |
| ----------- | ------------------------------------------- | --------------------------------------- |
| **GET**     | Получение ресурса                           | ✅ Да                                    |
| **HEAD**    | Получение мета-информации (без тела ответа) | ✅ Да                                    |
| **PUT**     | Обновление ресурса (замена)                 | ✅ Да                                    |
| **DELETE**  | Удаление ресурса                            | ✅ Да (если сервер реализован правильно) |
| **OPTIONS** | Запрос доступных методов для ресурса        | ✅ Да                                    |

**❌ Неидемпотентные методы**

| **Метод** | **Описание**         | **Идемпотентен?** |
| --------- | -------------------- | ----------------- |
| **POST**  | Создание ресурса     | ❌ Нет             |
| **PATCH** | Частичное обновление | ❌ Нет             |
###### Какие группы статусов знаешь?

- 100-199. Информационные
- 200-299. Успешные
- 300-399. Перенаправления
- 400-499. Клиентские ошибки
- 500-599. Серверные ошибки
- [Статусы REST](../../../_inforage/Компсети/03%20Storage/Статусы%20REST.md)
###### Почему для конфиденциальных данных рекомендуется использовать POST, а не GET запросы

- 1. **Безопасность**:
	- В GET запросе данные передаются в URL, который может быть виден в истории браузера, логах сервера и прокси.
	- В POST данные передаются в теле запроса, что снижает риск случайной утечки.
2. **Ограничения длины**:
	- Длина URL в GET ограничена браузерами или серверами, поэтому большие объемы данных (например, конфиденциальные формы) могут не пройти. При использовании метода GET можно использовать не более 2048 символов за вычетом количества символов в фактическом пути.
3. **Кэширование**:
	- GET запросы могут быть кэшированы прокси-серверами или браузерами, что нежелательно для конфиденциальной информации.
###### В чем разница между HTTP и HTTPS?

| **Критерий**              | **HTTP**                                                 | **HTTPs**                                                                                                                        |
| ------------------------- | -------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| **Безопасность данных**   | Данные передаются в открытом виде (без шифрования)       | Использует шифрование (обычно с помощью SSL/TLS)                                                                                 |
| **Протоколы**             | Работает по порту 80                                     | Работает по порту 443                                                                                                            |
| **Сертификаты**           | Не требует сертификатов                                  | Требует установки SSL/TLS-сертификата на сервере, чтобы подтвердить подлинность сайта и обеспечить шифрование.                   |
| **Производительность**    | Быстрее, так как не требует шифрования данных.           | Немного медленнее из-за накладных расходов на шифрование, но современные технологии (например, HTTP/2) минимизируют эту разницу. |
###### Какие нововведения были введены в HTTP/2 по сравнению с HTTP/1.1?

###### Какие типы данных можно использовать при работе с REST?

- строки (`"name": "John"`),
- числа (`"age": 30`),
- булевы значения (`"active": true`),
- объекты (`{"user": {"id": 1}}`),
- массивы (`"tags": ["tech", "api"]`),
- `null`.

###### REST vs RPC. Как выбрать что лучше подходит? 

Для работы с данными это обычно всегда _REST_
Для работы с действиями, операциями(logout,login,signin) _RPC_ будет смотреться лучше
_RPC_ - все описывает глаголами, а _REST_ - существительными
###### Что такое GRPC?

1. **Бинарный формат (Protobuf)**
    - Заменяет JSON/XML — меньше накладных расходов, быстрее парсинг.
    - Автоматическая генерация кода из `.proto`-файлов.
2. **Работа поверх HTTP/2**
    - Мультиплексирование (множество потоков в одном соединении).
    - Двунаправленная потоковая передача.
    - Возможно несколько раз передавать сообщение в одном соеденении 
3. **Поддержка 4 типов взаимодействия**
    - **Unary RPC** — классический запрос-ответ.
    - **Server streaming** — сервер отправляет поток данных.
    - **Client streaming** — клиент отправляет поток данных.
    - **Bidirectional streaming** — двусторонний поток.
4. **Кросс-языковая совместимость**
    - Клиент и сервер могут быть на разных языках (Go, Java, Python, C++, Rust и др.).
5. **Встроенные механизмы**
    - Аутентификация (TLS, OAuth2).
    - Балансировка нагрузки.
    - Таймауты и повторные попытки.
6. **Интеграция с облачными технологиями**
    - Используется в Kubernetes, Istio, микросервисных архитектурах.
7. **gRPC-Web**
    - Поддержка вызовов gRPC из браузера через прокси.
8. **Интерсепторы (Interceptors)**
    - Аналог middleware для логирования, мониторинга и т.д.
9. **Высокая производительность**
    - До 10x быстрее REST/JSON благодаря бинарному формату и HTTP/2.
10. **Схема-контракт (`*.proto`)**
    - Чёткое API-описание, исключающее недопонимание между командами.

###### Какие виды взаимодействия поддерживает GRPC?

- Унарный RPC (Unary RPC)
	- Аналог обычного HTTP-запроса: клиент отправляет **один запрос** и получает **один ответ**.
	- Пример: получение данных пользователя по ID.
	- One-to-one
- Серверный поток (Server Streaming RPC)
	- Клиент отправляет **один запрос**, а сервер возвращает **поток сообщений**.
	- Пример: получение обновлений в реальном времени (например, лента новостей, биржевые котировки).
	- One-to-many
- Клиентский поток (Client Streaming RPC)
	- Клиент отправляет **поток сообщений**, а сервер возвращает **один ответ**.
	- Пример: загрузка большого файла или пакетная обработка данных.
	- Many-to-one
- Двунаправленный поток (Bidirectional Streaming RPC)
	- Клиент и сервер обмениваются **независимыми потоками сообщений**.
	- Пример: чат, онлайн-игры, интерактивные сеансы.
	- Many-to-many
###### Можно организовать асинхронное взаимодействие с GRPC?

- **gRPC** поддерживает асинхронное взаимодействие через **ListenableFuture**, **StreamObserver** и **CompletableFuture**
- Одна из причин генирации асинхронного кода - grpc-netty

###### Отличия gRPC от REST

| **Критерий**                  | **gRPC**                                              | **REST (HTTP/JSON)**                                              |
| ----------------------------- | ----------------------------------------------------- | ----------------------------------------------------------------- |
| **Протокол**                  | HTTP/2 (бинарный)                                     | HTTP/1.1 или HTTP/2 (текстовый)                                   |
| **Формат данных**             | Protocol Buffers (бинарный)                           | JSON/XML (текстовый)                                              |
| **Производительность**        | Высокая (меньше накладных расходов)                   | Ниже (из-за текстового формата)                                   |
| **Типы взаимодействия**       | 4 вида: Unary, Client/Server Streaming, Bidirectional | Только запрос-ответ (но можно имитировать через Polling/Webhooks) |
| **Кодогенерация**             | Автоматическая (из `.proto`)                          | Вручную (Swagger/OpenAPI)                                         |
| **Поддержка языков**          | Мультиязычный (Go, Java, Python и др.)                | Любой язык с HTTP-клиентом                                        |
| **Использование в браузерах** | Требуется gRPC-Web                                    | Нативная поддержка                                                |
| **Кеширование**               | Нет (бинарный поток)                                  | Да (HTTP-кеши)                                                    |
| **Безопасность**              | TLS/mTLS (встроен)                                    | HTTPS + OAuth2/JWT                                                |
| **Идеальные сценарии**        | Микросервисы, стриминг, низкие задержки               | Веб-API, мобильные приложения                                     |
###### Расскажи про SOAP? 

- Simple Object Access Protocol — простой протокол доступа к объектам. То есть правила передачи информации в SOAP строго стандартизированы, есть [спецификация](https://www.w3.org/TR/soap/), которой нужно соответствовать.
- RPC-протокол на основе **XML/HTTP** (синхронный, запрос-ответ).
- Request:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<soap:Envelope 
    xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"
    xmlns:ex="http://example.com/UserService">
  <soap:Header>
    <ex:AuthHeader>
      <ex:Token>SECRET_TOKEN</ex:Token>
    </ex:AuthHeader>
  </soap:Header>
  <soap:Body>
    <ex:GetUserDetailsRequest>
      <ex:userId>123</ex:userId>
    </ex:GetUserDetailsRequest>
  </soap:Body>
</soap:Envelope>
```
###### Расскажи про WebSocket?

- **Одно подключение** — соединение устанавливается один раз и остается открытым.
- **Поддержка бинарных данных** (не только текст/JSON).
- **Асинхронность** — сервер может сам инициировать отправку сообщений.
###### Чем отличаются REST vs SOAP?

- SOAP основывает на технологии удаленного вызова процедур. Сервис, который работает на базе SOAP - ресурсы с одним-едиственным входом.
	- Каждый раз обращаясь ко входу, нужно указывать название процедуры, функцию которую мы хотим вызвать
	- Также мы должны передать входные данные для функции
- REST представляют собой ресурсы, имеющий множество таких входов, которые называют Endpoint
###### Какие форматы данных обычно используются в REST и SOAP сервисах?
###### Как бы ты реализовал CRUD операции с помощью кафки (рассказать про то, сколько топиков и какие они будут)?

- Event Sourcing
- Request:

```json
{
  "eventId": "550e8400-e29b-41d4-a716-446655440000",
  "eventType": "UserCreated",
  "timestamp": "2024-01-01T12:00:00Z",
  "data": {
    "id": "123",
    "name": "Alice"
  }
}
```

###### В сообщении ключом будет операция из CRUD, а значение – сам объект. Сталкивался ли ты с таким паттерном strategy через enum?

```java
@Service
public class KafkaUserConsumer {

    @Autowired
    private UserRepository userRepository;

    @KafkaListener(topics = "users-topic")
    public void handleUserOperation(
            @Header(KafkaHeaders.RECEIVED_KEY) String operation,
            @Payload User user) {

		// enum with abstract method process
        CrudOperation crudOp = CrudOperation.valueOf(operation);
        crudOp.process(user, userRepository);
    }
}
```

###### Как браузер понимает что сертификат настоящий.

###### SSL/TLS/MTLS - чем отличаются?

- Эти технологии обеспечивают **безопасную передачу данных** в сети, но имеют ключевые различия.
- SSL - устаревший протокол (1995 г.), заменён на TLS.
- TLS
	- Обмениваются **симметричными ключами** (через асимметричное шифрование).
	- **Клиент** и **сервер** согласовывают параметры шифрования (Handshake).
	- Данные передаются в зашифрованном виде.
	- сервер имеет сертификат, а клиент — нет.
	- TLS 1.0 (уязвим), 1.1 (устарел), 1.2 (рекомендуется), 1.3 (самый быстрый и безопасный).
- mTLS
	- **и клиент, и сервер** имеют сертификаты
	- 1. Сервер отправляет свой сертификат. 2. Клиент проверяет его и отправляет **свой сертификат**. 3. Сервер проверяет клиентский сертификат. 4. Устанавливается безопасное соединение.
	- Микросервисы (Kubernetes, service mesh).
###### Что такое публичный и приватный ключи?

- **Приватный ключ** — для расшифровки и подписи (хранить в секрете).
- **Публичный ключ** — для шифрования и проверки (можно распространять).
###### Хранилище сертифкатов в браузере

###### Сетевые протоколы, какие знаешь?

Сетевые протоколы — это правила передачи данных между устройствами. Они делятся на категории по уровням модели **OSI** или **TCP/IP**. Вот ключевые протоколы

###### Уровни сетевых протоколов по OSI

- **Физический уровень (Physical Layer)**: Управляет физической передачей данных через носители, такие как кабели или беспроводные сети.
- **Канальный уровень (Data Link Layer)**: Обеспечивает надежную передачу данных между узлами через физическую связь. Включает управление доступом к каналу (MAC) и контроль ошибок.
- **Сетевой уровень (Network Layer)**: <mark style="background: #ABF7F7A6;">Отвечает за маршрутизацию данных между устройствами в сети.</mark> Пример — IP-протокол.
- **Транспортный уровень (Transport Layer)**: <mark style="background: #ABF7F7A6;">Обеспечивает надежную передачу данных между узлами, включая сегментацию и управление потоком.</mark> Примеры — TCP, UDP.
- **Сеансовый уровень (Session Layer)**: <mark style="background: #ABF7F7A6;">Управляет сессиями или соединениями между приложениями. </mark>Обеспечивает установление, поддержание и завершение сессий.
- **Представительный уровень (Presentation Layer)**: Отвечает за преобразование данных, например, за <mark style="background: #ABF7F7A6;">шифрование, сжатие или преобразование форматов</mark>.
- **Прикладной уровень (Application Layer)**: <mark style="background: #ABF7F7A6;">Определяет интерфейсы и протоколы для взаимодействия приложений.</mark> Примеры — HTTP, FTP, SMTP.

###### Уровни протоколов по TCP/IP

| **Уровень доступа к сети (Network Access Layer)** | Этот уровень отвечает за физическую передачу данных по сети. Включает физические и канальные уровни модели OSI, управляет взаимодействием с сетевым оборудованием, таким как сетевые карты и маршрутизаторы             | [[../../../_inforage/Компсети/03 Storage/Физический уровень]] [[../../../_inforage/Компсети/03 Storage/Канальный уровень]]                 |
| ------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------ |
| **Интернет-уровень (Internet Layer)**             | На этом уровне происходит маршрутизация и адресация данных с использованием IP. Основные протоколы этого уровня — IP, ICMP, ARP и RARP                                                                                  | Сетевой уровень                                              |
| **Транспортный уровень (Transport Layer)**        | Транспортный уровень управляет доставкой данных от одного узла к другому. Основные протоколы: TCP (для надёжной передачи) и UDP (для ненадёжной, но быстрой передачи)                                                   | [[../../../_inforage/Компсети/03 Storage/Транспортный уровень]]                                     |
| **Уровень приложений (Application Layer)**        | Этот уровень отвечает за взаимодействие с конечным пользователем и включает протоколы таки как HTTP, FTP, SMTP, DNS, которые обеспечивают работу веб-сайтов, электронной почты, передачу файлов и других сетевых услуг. | Сеансовый уровень, Уровень представления, Уровень приложений |

###### Какие есть синхронные виды взаимодействия?

1. **Синхронные HTTP-запросы** (REST, SOAP, GraphQL).
2. **RPC (Remote Procedure Call)** (gRPC Unary, Java RMI).
3. **Очереди с синхронным poll()** (Kafka, RabbitMQ в блокирующем режиме).
4. **Файловый I/O в блокирующем режиме** (чтение/запись файлов).

######  Можно ли использовать POST для получения данных?

- **`GET`** — должен использоваться для **получения** данных (без изменения состояния сервера).
- **`POST`** — для **создания** или **изменения** данных.
###### Зачем указывать v1 в запросе? (api/v1/.....)

###### Какие знаешь способы версионирования приложения?

###### Что общего между Rest Api и CRUD

###### Можно ли сделать REST асинхронным?

###### Расскажите что такое Web сессия. Из каких частей она состоит и какие данные хранятся на стороне клиента, а какие на стороне сервера.

###### Что делают интерцепторы в RestTemplate

###### Из чего состоит JWT?

JWT состоит из трех частей, разделенных точками (`.`):

```
<Header>.<Payload>.<Signature>
```

1. **Header (Заголовок):**
    - Содержит метаинформацию о токене:
        - Алгоритм подписи (например, HMAC SHA256, RSA).
        - Тип токена (`JWT`).
        ```json
        {
          "alg": "HS256",
          "typ": "JWT"
        }
        ```
2. **Payload (Полезная нагрузка):**
    - Содержит данные (клеймы), которые нужно передать.
    - Может включать:
        - **Зарезервированные клеймы:** стандартные поля, такие как `iss` (издатель), `exp` (время истечения), `sub` (тема).
        - **Пользовательские клеймы:** любые данные, такие как роль пользователя, идентификатор и т.д.
        ```json
        {
          "sub": "1234567890",
          "name": "John Doe",
          "admin": true
        }
        ```
3. **Signature (Подпись):**
    - Подписывает токен, чтобы проверить его подлинность.
    - Формируется с использованием заголовка, полезной нагрузки и секретного ключа (или приватного ключа в случае асимметричного шифрования).
    - Пример формулы:
        ```
        HMACSHA256(
          base64UrlEncode(header) + "." + base64UrlEncode(payload),
          secret
        )
        ```

###### Что такое MultiPartFile

## Задачи

###### Спроектируй путь запроса (URL) для получения адреса клиента?
###### Как бы ты реализовал REST API по работе с пользователем, расскажи, как бы реализовывал получение Rest запроса, обращения к базе, сохранение, какая цепочка прохождения до БД