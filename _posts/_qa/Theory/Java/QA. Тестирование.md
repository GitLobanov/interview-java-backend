###### На чем пишутся тесты?

- _Unit-тесты_: В основном используются фреймворки **JUnit** для написания модульных тестов в Java.
- _Интеграционные тесты_: Используют **Spring Test**, **Testcontainers** для интеграционного тестирования с базами данных и внешними системами.
- _Mocking_: Фреймворки, такие как **Mockito** применяются для создания заглушек (mock-объектов) в unit-тестах.
- _UI-тесты_: Для тестирования интерфейсов часто используют **Selenium**.
- _Performance тесты_: Инструменты вроде **JMeter**.

###### Что такое модульное тестирование?

 процесс в программировании, позволяющий проверить на корректность отдельные модули исходного кода программы. Идея состоит в том, чтобы писать тесты для каждой нетривиальной функции или метода.

- _тесты состояния (state based)_, проверяющие что вызываемый метод объекта отработал корректно, проверяя состояние тестируемого объекта после вызова метода.
- _тесты взаимодействия (interaction tests)_, в которых тестируемый объект производит манипуляции с другими объектами. Применяются, когда требуется удостовериться, что тестируемый объект корректно взаимодействует с другими объектами.

###### Что такое _«интеграционное тестирование»_?

тестирование, проверяющие работоспособность двух или более модулей системы в совокупности — то есть нескольких объектов как единого блока. В тестах взаимодействия же тестируется конкретный, определенный объект и то, как именно он взаимодействует с внешними зависимостями.

###### Примеры интеграционных тестов

- Проверить взаимодействие между контроллером, сервисом и БД.
- Убедиться, что репозиторий корректно сохраняет/извлекает данные.
- Проверить бизнес-логику с поднятым контекстом Spring. (Отдельного сервиса при запущенном контексте)

###### Чем интеграционное тестирование отличается от модульного?

Допустим, есть класс, который при определенных условиях взаимодействует с web-сервисом через зависимый объект. И нам надо проверить, что определенный метод зависимого объекта действительно вызывается. Если в качестве зависимого класса передать:

- реальный класс, работающий с web-сервисом, то это будет интеграционное тестирование.
- заглушку, то это будет тестирование состояния.
- шпиона, а в конце теста проверить, что определенный метод зависимого объекта действительно был вызван, то это будет тест взаимодействия.

| **Критерий**            | **Unit-тесты**            | **Интеграционные тесты**                |
| ----------------------- | ------------------------- | --------------------------------------- |
| **Что тестируют?**      | Отдельные методы, классы  | Взаимодействие компонентов              |
| **Зависимости?**        | Заменяются mock-объектами | Используются реальные сервисы (БД, API) |
| **Скорость выполнения** | 🟢 Быстро (миллисекунды)  | 🔴 Медленно (секунды и больше)          |
| **Пример**              | `Calculator.add(2, 3)`    | `UserService` работает с `Database`     |
###### Какие существуют виды тестовых объектов?

**пустышка (dummy)** - объект, который обычно передается в тестируемый класс в качестве параметра, но не имеет поведения: с ним ничего не происходит и никакие его методы не вызываются.

> Примером dummy-объектов являются new object(), null, «Ignored String» и т.д.

**фальшивка (fake object)** применяется в основном для ускорения запуска ресурсоёмких тестов и является заменой тяжеловесного внешнего зависимого объекта его легковесной реализацией.

> Основные примеры — эмулятор базы данных (fake database) или фальшивый web-сервис.

**заглушка (test stub)** используется для получения данных из внешней зависимости, подменяя её. При этом заглушка игнорирует все данные, поступающие из тестируемого объекта, возвращая заранее определённый результат.

> Тестируемый объект использует чтение из конфигурационного файла? Тогда передаем ему заглушку `ConfigFileStub` возвращающую тестовые строки конфигурации без обращения к файловой системе.

**шпион (test spy)** - разновидность заглушки, которая умеет протоколировать сделанные к ней обращения из тестируемой системы, чтобы проверить их правильность в конце теста. При этом фиксируется количество, состав и содержание параметров вызовов.

> Если существует необходимость проверки, что определённый метод тестируемого класса вызывался ровно 1 раз, то шпион - именно то, что нам нужно.

**фикция (mock object)** похож на _шпиона_, но обладает расширенной функциональностью, заранее заданными поведением и реакцией на вызовы.

###### Spy. Как работает?

**Spy** – это объект, который ведет себя **как настоящий** объект, но позволяет **подменить поведение некоторых методов** или **проверить, были ли вызваны методы**.

- Позволяет сохранять реальное поведение объекта, но при этом можно **подменить отдельные методы** или **проверить, как часто методы были вызваны**.
- Используется, когда вы хотите **тестировать реальный объект**, но в какой-то момент вам нужно изменить его поведение.

- **Spy** сохраняет реальные данные и действия объекта, но при этом позволяет **переопределять отдельные методы**.
- В отличие от **Mock**, где вы полностью контролируете поведение, **Spy позволяет тестировать и фактическую логику**, и при этом **подменять метод**, если это необходимо.

###### Каким образом проверяются результаты тестов?

**✅ 1. Проверка значений (Assertions)**

📌 **Используется `assertEquals`, `assertTrue`, `assertFalse` и др.**

```java
assertEquals(5, calculator.add(2, 3)); // Проверка, что результат 5
assertTrue(user.isActive()); // Проверка, что юзер активен
```

**✅ 2. Проверка вызовов Mock (Mockito)**

📌 **Проверяем, вызывался ли метод и сколько раз.**

```java
verify(mockRepo, times(1)).findNameById(1);
```

✔ Убедимся, что метод `findNameById(1)` был вызван **ровно 1 раз**.

**✅ 3. Проверка исключений**

📌 **Проверяем, выбросил ли метод нужное исключение.**

```java
assertThrows(IllegalArgumentException.class, () -> service.findUser(-1));
```

✔ Проверяем, что при передаче `-1` выбрасывается `IllegalArgumentException`.

###### Приведи дубликатов тестов

- Stubs - предоставляют готовые ответы на вызовы, сделанные во время теста. Используется для тестирования состояния (мокаем репозиторий, чтобы они имитировал работы базы, а возвращаемые результаты как-то используем для тестов)  
- Spy - вид стаба, который оборачивает настоящий объект  
- Mock - вид стаба, методы которого изначально пустые. Мы должны вручную определить то, что они будут возвращать. Используется для тестирования поведения (проверить был ли вызван метод)
- Dummy - объекты передаются, но никогда не используются. Используются только для заполнения списка параметров  

```java
User dummyUser = new User("John", 25);  // Этот объект будет просто передан, но не использован
userService.addUser(dummyUser);  // Вызов метода с "dummy" объектами
verify(dummyRepository).save(dummyUser); // Проверка, что метод был вызван (но объекты не использованы)
```

- Fake - объекты имеют рабочую реализацию, но обычно непригодны для производства. Пример - InMemory база данных H2

###### Mock vs Spy

- _stub_ используется как заглушка сервисов, методов, классов и т.д. с заранее запрограммированным ответом на вызовы.
- _mock_ использует подмену результатов вызова, проверяет сам факт взаимодействия, протоколирует и контролирует его.

|**Критерий**|**Mock**|**Spy**|
|---|---|---|
|**Описание**|Полностью имитирует поведение объекта. Вы задаёте ожидаемые ответы на вызовы методов.|Реальный объект, но с возможностью “шпионить” за вызовами методов.|
|**Подход**|Заменяет объект, тестируется только взаимодействие (behavior verification).|Используется реальный объект, но вы можете подменять результаты вызовов его методов.|
|**Когда использовать**|Когда необходимо полностью изолировать тестируемый объект от зависимости.|Когда хотите протестировать реальный объект, но также отследить вызовы его методов.|
|**Пример использования**|Проверка взаимодействия с внешней зависимостью, например, базой данных.|Проверка поведения конкретного метода объекта, оставаясь близко к реальной логике.|
|**Типы подмен**|Вы задаёте возвращаемые значения для всех методов объекта.|Реальные методы объекта выполняются, если не настроена их подмена.|

###### Какие аннотации фикстур существуют в JUnit?

- `@BeforeClass` - определяет код, который должен единожды выполниться перед запуском набора тестовых методов.
- `@AfterClass` - код, выполняемый один раз после исполнения набора тестовых методов.
- `@Before` - определяет код, который должен выполняться каждый раз перед запуском любого тестового метода.
- `@After` - код, выполняемый каждый раз после исполнения любого тестового метода.

###### Для чего в JUnit используется аннотация `@Ignore`?

`@Ignore` указывает JUnit на необходимость пропустить данный тестовый метод.

###### Как расшифруешь абревиатуру F.I.R.S.T.

- [[../../../_inforage/Тестирование/F.I.R.S.T.]]

###### Как работают параметризированные тесты

- [[../../../_inforage/Тестирование/Параметризованные тесты]]

```java
@ParameterizedTest
@ValueSource(ints = {1, 2, 3, 4, 5})
void testWithParameters(int number) {
    assertTrue(number > 0);
}
```

###### Типы параметризованных тестов в JUnit 5

| **Аннотация**    | **Описание**                                            |
| ---------------- | ------------------------------------------------------- |
| `@ValueSource`   | Передаёт фиксированные наборы данных (массив значений). |
| `@CsvSource`     | Передаёт данные в формате CSV.                          |
| `@CsvFileSource` | Загружает данные из файла CSV.                          |
| `@MethodSource`  | Использует метод для предоставления набора данных.      |
| `@EnumSource`    | Передаёт значения перечислений (enums).                 |
| @ArgumenSource   |                                                         |
#### В чем плюсы и минусы использования ин мемори и тестконтейнеров

With in-memory databases, you are testing against a different database than your production database. This significantly reduces the meaning and reliability of your tests. **A green h2-based test doesn’t mean that your application will also work against the real-world database**. Let me give a very simple example from my experience.

Another even bigger issue is the different feature set of in-memory databases compared to the real database. From time to time, you need to use **vendor-specific features**. For me, this is fine, because those features often allow you to be more efficient, accurate, elegant or maintainable - or to do certain things at all. But they are usually not supported by in-memory databases.

Postgres has powerful features like window functions and JSON data types which are not supported by H2.

- _If_ you are lucky, the integration tests will show those database-specific errors. It depends on the coverage of the integration tests.
- You only have a single layer of security, because your first test layer, the h2-based tests of your build, won’t find them.
- Setting up a proper production-like environment and a delivery pipeline is required. This can be non-trivial.
- Integration tests are only black-box tests and coarse-grained. They are slower and require more bootstrapping.
- - The more external services and resources are used by your application, the more fragile your integration tests can become.

###### Что такое пирамида тестирования? 

###### Как реализовать параметризованные тесты в JUnit 5?

###### Какие подходы и методологии могут быть использованы для тестирования ПО в микросервисной архитектуре?

###### Что такое TDD и для чего оно используется?

###### Можешь ли описать цикл "Красный-Зеленый-Рефактор" в контексте TDD?

###### На каком этапе нужно поднятие контекста? Для чего? Порядок запуска тестов важен? 

###### Какие есть аннотации для тестов в Spring? 

###### Расскажите о @InjectMock и @MockBean.

###### Чем отличаются тесты функциональные и нефункциональные?

###### Можете пример привести, что вы там в тестах пишите? теорию я знаю, можете конкретный пример привести?

