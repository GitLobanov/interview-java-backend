1. Как реализовать алгоритм сортировки подсчетом на Java?  

- [[../../_inforage/Алгоритмы/Storage/Сортировка подсчетом]]

2. Какие стратегии оптимизации могут быть применены к алгоритму быстрой сортировки?  
- [[../../_inforage/Алгоритмы/Storage/Быстрая сортировка#Оптимизация]]

3. Опишите процесс реализации алгоритма поиска в глубину на графе.

- [[../../_inforage/Алгоритмы/Storage/Depth-First Search, DFS#1. Поиск в графах]]

101. Как можно оценить пространственную сложность алгоритма?  

- [[../../_inforage/Алгоритмы/Storage/Пространственная сложность алгоритма]]

102. Каковы основные различия между сложностью О(n log n) и О(n^2)? Приведите примеры алгоритмов.  

Основные различия между сложностью **O(n log n)** и **O(n²)** — это скорость роста времени выполнения алгоритма в зависимости от размера входных данных `n`. Чем больше значение `n`, тем существеннее становится разница между ними.

Основные различия

- **Скорость роста времени выполнения:**
    - **O(n log n)**: Растет медленнее, чем O(n²). Алгоритмы с такой сложностью обычно быстрее для больших входных данных.
    - **O(n²)**: Время выполнения возрастает квадратично, т.е., при увеличении `n` затраты времени растут значительно быстрее. Это делает алгоритмы O(n²) медленными для больших `n`.

- O(n log n)

1. **Сортировка слиянием (Merge Sort):**
    - Делит массив на половины, сортирует каждую рекурсивно и затем объединяет.
    - Средняя и худшая сложность: `O(n log n)`.
2. **Быстрая сортировка (Quick Sort):**
    - Выбирает "опорный элемент", делит массив на меньшие части и сортирует каждую часть.
    - Средняя сложность: `O(n log n)`; худшая: `O(n²)` (в неудачном случае выбора опорного элемента).

- O(n²)

1. **Сортировка пузырьком (Bubble Sort):**
    - Каждый элемент сравнивается с последующим и перемещается, если он больше.
    - Средняя и худшая сложность: `O(n²)`.
2. **Сортировка вставками (Insertion Sort):**
    - Последовательно вставляет каждый элемент на нужное место в отсортированной части массива.
    - Средняя и худшая сложность: `O(n²)`.
3. **Поиск всех пар элементов (двойной цикл):**
    - Например, поиск всех пар чисел, сумма которых равна заданному значению.
    - Использует два вложенных цикла, проверяя каждую возможную пару элементов массива.
    - Сложность: `O(n²)`.

103. Как влияет структура данных на временную сложность алгоритма? Приведите пример.

Структура данных сильно влияет на временную сложность алгоритма, потому что разные структуры данных организуют данные по-разному и определяют, как быстро можно выполнять операции — например, добавление, удаление и поиск.

Пример 1: Поиск элемента

Представьте, что нужно найти элемент в массиве и в хеш-таблице:

- **Массив**: Чтобы найти нужный элемент, в худшем случае нужно пройти по всем элементам — это будет **O(n)**.
- **Хеш-таблица**: Она использует хеш-функцию для быстрого доступа к данным, поэтому поиск занимает **O(1)** (в среднем случае), независимо от размера данных.

Пример 2: Упорядочивание данных

Допустим, нужно постоянно вставлять данные в отсортированном порядке:

- **Связный список**: В связном списке вставка элемента занимает O(1), но чтобы найти место для вставки, нужно просмотреть все элементы, что займет O(n). В итоге, вставка в нужное место в связном списке будет занимать **O(n)**.
- **Сбалансированное бинарное дерево (например, AVL)**: Позволяет вставлять элементы в отсортированном порядке за **O(log n)**, так как дерево остается сбалансированным.