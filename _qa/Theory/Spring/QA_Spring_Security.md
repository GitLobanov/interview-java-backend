#### Что такое аутентификация и авторизация? В чем разница? [X]

Аутентификация — процесс верификации пользователя компьютерной системы.  Вот как он происходит в Spring:

1. Полученные пароль и имя пользователя преобразуются в экземпляр [UsernamePasswordAuthenticationToken](https://docs.spring.io/spring-security/site/docs/4.2.12.RELEASE/apidocs/org/springframework/security/authentication/UsernamePasswordAuthenticationToken.html). Он реализует интерфейс [Authentication](https://docs.spring.io/spring-security/site/docs/4.2.11.RELEASE/apidocs/org/springframework/security/core/Authentication.html).
2. Токен передается объекту `AuthenticationManager` для проверки
3. В случае удачной проверки AM возвращает заполненный объект `Authentication`
4. Устанавливается security context, с помощью вызова `SecurityContextHolder.getContext().setAuthentication(...)`

Авторизация — это процесс удостоверения в том, что у пользователя есть роль, требуемая чтобы сделать какое-либо действие. При авторизации проверяется, есть ли у вас соответствующие права на доступ к ресурсу.

Процесс:

1. По принципалу(principal) пользователя отображается его роль
2. Роль пользователя сверяется с ролью ресурса

Сначала происходит аутентификация, а потом — авторизация.

#### Какие проблемы с безопасностью знаешь?

1. Неправильная настройка ролей и разрешений — пользователи могут получить доступ к операциям, к которым они не должны иметь доступ.
2. Ошибки в аутентификации — недостаточная проверка аутентификации может позволить пользователям войти в систему без проверки.
3. Проблемы с токенами и сессиями — устаревшие токены или сессии могут остаться активными, создавая риск для безопасности.
4. Уязвимости CSRF — отсутствие защиты от CSRF-атак может позволить злоумышленникам совершать действия от имени пользователя.
5. Неправильная настройка CORS — может открыть доступ для внешних сайтов и повысить риск атак.

#### Как Security работает внутри? [X]

1. Запрос поступает в приложение и первым делом попадает в DelegatingFilterProxy, который связывает Servlet-контейнер с Spring-контекстом.
2. DelegatingFilterProxy передает управление FilterChainProxy - главному диспетчеру фильтров Spring Security. Он определяет, какую цепочку фильтров использовать для данного URL.
3. SecurityContextPersistenceFilter проверяет сессию и либо создает новый SecurityContext, либо восстанавливает существующий (например, если пользователь уже авторизован).
4. Если требуется аутентификация, срабатывает соответствующий фильтр. В современных версиях вместо UsernamePasswordAuthenticationFilter часто используется более гибкая система аутентификации через AuthenticationManager.
5. Для авторизации используется AuthorizationFilter (в новых версиях заменяет FilterSecurityInterceptor), который проверяет права доступа на основе аннотаций @PreAuthorize или конфигурации.
6. Если доступ запрещен или требуется аутентификация, ExceptionTranslationFilter обрабатывает исключения:
    - Перенаправляет на страницу входа
    - Возвращает 403 Forbidden
    - В REST API может вернуть JSON-ошибку
7. В современных версиях DefaultLoginPageGeneratingFilter используется только если явно не отключен и не настроена своя страница входа.
8. После успешной аутентификации SecurityContext сохраняется (обычно в сессии) для последующих запросов.

![[../../../_res/Pasted image 20241002142328.png]]

#### Какие значешь фильтры в Security? [X]

1. DelegatingFilterProxy
- Роль: Мост между Servlet-контейнером и Spring-бинами.
- Действие: Передает запросы в Spring-контекст, где работает FilterChainProxy.
2. FilterChainProxy
- Роль: Центральный "диспетчер" фильтров Spring Security.
- Действие: Управляет цепочкой фильтров (выбирает нужную цепочку для URL).
3. SecurityContextPersistenceFilter
- Роль: Сохраняет и восстанавливает SecurityContext (например, из сессии).
- Действие: Читает аутентификацию пользователя между запросами.
4. UsernamePasswordAuthenticationFilter / AuthenticationManager
- Роль: Обрабатывает POST-запросы с логином/паролем (/login).
- Действие: Создает Authentication-объект и передает его AuthenticationManager.
5. DefaultLoginPageGeneratingFilter
- Роль: Генерирует стандартную HTML-страницу входа, если не настроена своя.
- Когда работает: При запросе /login (если страница не переопределена).
6. ExceptionTranslationFilter
- Роль: Обрабатывает исключения (например, AccessDeniedException).
- Действие:
    - Перенаправляет на страницу входа при `AuthenticationException`.
    - Возвращает HTTP 403 при AccessDeniedException.
7. FilterSecurityInterceptor / AuthorizationFilter
- Роль: Фильтр авторизации (проверяет права доступа).
- Действие: Сверяет роли пользователя с настройками @PreAuthorize или security.xml.

#### Основные объекты, участвующие в Spring Security [X]

- SecurityContextHolder - это хранилище, которое содержит и предоставляет доступ к SecurityContext. 
- SecurityContext - это контейнер, который хранит объект Authentication. 
- Authentication - это интерфейс, который представляет токен аутентификации и содержит: принципала (аутентифицированного пользователя), его учетные данные и список GrantedAuthority (полномочий). 
- GrantedAuthority - это интерфейс, представляющий полномочия пользователя. 
- UserDetails - это интерфейс, который содержит основные данные пользователя (логин, пароль, полномочия) и используется для создания объекта Authentication. 
- UserDetailsService - это сервис, который загружает UserDetails из хранилища (БД, памяти и т.д.).

Таким образом цепочка зависимостей выглядит так: UserDetailsService → UserDetails → Authentication (содержит GrantedAuthority) → SecurityContext → SecurityContextHolder. AuthenticationManager использует UserDetailsService для аутентификации и создания объекта Authentication, который затем помещается в SecurityContext. SecurityFilterChain работает с этими компонентами для обеспечения безопасности.

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/admin").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .formLogin(form -> form
                .loginPage("/login")
                .permitAll()
            );
        return http.build();
    }

    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails user = User.withDefaultPasswordEncoder()
            .username("user")
            .password("pass")
            .roles("USER")
            .build();
        
        UserDetails admin = User.withDefaultPasswordEncoder()
            .username("admin")
            .password("admin")
            .roles("ADMIN")
            .build();
            
        return new InMemoryUserDetailsManager(user, admin);
    }

    @RestController
    public class AuthController {
        
        @GetMapping("/current")
        public String currentUser() {
            Authentication auth = SecurityContextHolder.getContext().getAuthentication();
            return "Logged as: " + auth.getName() + 
                   " with roles: " + auth.getAuthorities();
        }
        
        @PostMapping("/login")
        public ResponseEntity<String> login(@RequestBody LoginRequest request) {
            Authentication authentication = new UsernamePasswordAuthenticationToken(
                request.username(), 
                request.password()
            );
            
            Authentication authenticated = authenticationManager().authenticate(authentication);
            SecurityContextHolder.getContext().setAuthentication(authenticated);
            return ResponseEntity.ok("Authenticated");
        }
    }
    
    record LoginRequest(String username, String password) {}
}
```

#### Что такое делегирующий прокси фильтр? [X]

Класс DelegatingFilterProxy — это класс, который реализует интерфейс javax.Servlet.Filter. Это специальный фильтр, который делегирует работу другим бинам, которые также являются фильтрами. Автоматически регистрируется Spring Boot при использовании spring-boot-starter-security. Связывает Servlet-контейнер (Tomcat/Jetty) с Spring-бинами. Делегирует вызовы фильтров в Spring-контекст.

1. Запрос приходит в DelegatingFilterProxy
2. Перенаправляется в Spring-контекст к FilterChainProxy
3. Проходит через цепочку фильтров (ваш customFilter, затем стандартные)
4. При аутентификации создается Authentication объект
5. Помещается в SecurityContext, который хранится в SecurityContextHolder

#### Что такое SecurityFilterChain? [X]

SecurityFilterChain - это интерфейс, представляющий цепочку фильтров безопасности. Основная реализация - DefaultSecurityFilterChain.

1. SecurityFilterChain настраивается через HttpSecurity с лямбда-выражениями
2. Конфигурация теперь выглядит так:  
```java
@Bean 
SecurityFilterChain securityFilterChain(HttpSecurity http) {  
	http.authorizeHttpRequests(auth -> auth.anyRequest().authenticated())...  
}
```
3. Фильтры автоматически добавляются в зависимости от конфигурации (не нужно указывать вручную)
4. Для кастомных фильтров используется addFilterBefore/addFilterAfter

Пример цепочки фильтров:

1. SecurityContextPersistenceFilter
2. HeaderWriterFilter
3. CsrfFilter
4. LogoutFilter
5. UsernamePasswordAuthenticationFilter (если используется formLogin)
6. DefaultLoginPageGeneratingFilter
7. DefaultLogoutPageGeneratingFilter
8. AuthorizationFilter
9. ExceptionTranslationFilter
#### Что такое SecurityContext ? [X]

Основной объект — это SecurityContextHolder. Это место, где хранятся детали о текущем security context, например детали принципала который в текущий момент пользуется приложением. По умолчанию для хранения используется ThreadLocal.

```java
//получение 
SecurityContext ctx = SecurityHolderContext.getContext()
```

Объект, возвращаемый методом getContext() это SecurityContext. Он позволяет получать и устанавливать объект Authentication. Authentication представляет следующие свойства:

- Коллекцию полномочий выданных принципалу
- Данные для удостоверения пользователя(логин, пароль)
- Details — доп. информация, если она нужна. Может быть равно null
- Принципал
- Authentication flag — boolean переменная, которая показывает успешно ли прошел проверку принципал

#### Что такое Principial? [X]

Principal (принципал) в Spring Security — это аутентифицированный пользователь или клиент, представленный внутри системы. Это ключевое понятие безопасности, которое хранится в объекте Authentication.

Получается через SecurityContext:

```java
Authentication auth = SecurityContextHolder.getContext().getAuthentication();
Object principal = auth.getPrincipal(); // Сам принципал
String username = auth.getName(); // Имя принципала (логин)
```

1. Для логина/пароля:
    - Principal = UserDetails (с паролем, ролями и т.д.).
2. Для JWT:
    - Principal = String (subject из токена) или кастомный DTO.
3. Для OAuth2:
    - Principal = OAuth2User (с атрибутами из провайдера).

#### Как установить перехват перехода пользователя по определенным URL? [X]

Через SecurityFilterChain

```java
@Bean 
SecurityFilterChain securityFilterChain(HttpSecurity http) {  
	http.authorizeHttpRequests(auth -> auth.anyRequest().authenticated())...  
}
```

В старых версиях (до 5.7) WebSecurityConfigurerAdapter

```java
@Override
protected void configure(HttpSecurity http) throws Exception {

      http.authorizeRequests()
       //игнорирование всех запросов на /resources
        .antMatchers("/resources/**").permitAll() 
        //для остальных запросов требуется одна из 2 ролей
        .antMatchers("/").hasAnyRole("ANONYMOUS", "USER")
        .antMatchers("/login)*").hasAnyRole("ANONYMOUS", "USER")  
        .antMatchers("/logoutr").hasAnyRole("ANONYMOUS", "USER") 
        //запрос на ресурсы ниже требуют роль ADMIN
        .antMatchers("iadmin/*").hasRole("ADMIN") 
        .antMatchers("/events/").hasRole("ADMIN")
}
```

#### Что означает * в методах antMatchers и mvcMatchers()?

Это выражение означает “любой”.

Есть 2 вида:

- `*` — перехватывает только на том уровне, на котором используется. Например, паттерн “/orders/*” проверит права пользователя, если пользователь перейдет по
    /orders/aliens или /orders/1, но не /orders/alien/1.
- `**` — перехватывает на всех уровнях.  Будут проверены любые запросы, /orders/aliens, /orders/1, /orders/alien/1.

#### Почему mvcMatcher более защищенный чем antMatcher? [X]

Потому что antMatcher(“/service”) сопоставляет путь запроса только с “/service”, в то время как mvcMatcher(“/service”) сопоставляет с “/service”, “/service.html”, “/service.abc”.

#### Spring поддерживает хэширование паролей? Что такое соль? [X]

Да, поддерживает. Для хэширования существует интерфейс PasswordEncoder, который содержит только один метод.

static PasswordEncoder createDelegatingPasswordEncoder(), который возвращает DelegatePasswordEncoder, настроенный по умолчанию.

Соль используется для вычисления хеш-значения пароля. Это последовательность рандомных чисел, которые используются для преобразования текстового пароля в хеш. Соль хранится в открытом виде рядом с хеш-паролем и может использоваться в дальнейшем при конвертации чистого пароля в хеш при новом логине пользователя.

#### Зачем нужна защита для методов? Как ее установить?

Spring Security поддерживает защиту отдельных методов в бинах(например, в контроллерах). Это дополнительный слой защиты для приложения. Ее требуется указать явно, используя аннотацию `@EnableGlobalMethodSecurity`.

#### Что делает аннотация @RolesAllowed?

Эта аннотация основана на JSR-250.  
`@RolesAllowed` позволяет настроить доступ к методам(например, в классе-контроллере) с помощью ролей.  

Пример: `@RolesAllowed(“ADMIN”)` будет пропускать только пользователей с ролью `ADMIN` Для использования нужно установить `@EnableGlobalMethodSecurity(jsr250Enabled=true)` на @Configuration классе + нужно чтобы эта аннотация была в classpath.

###### Secured?
###### Расскажите про @PreAuthorize

`@PreAuthorize` позволяет настроить доступ к методу используя SpEL.  Для использования нужно установить `@EnableGlobalMethodSecurity(prePostEnabled=true)`

###### Как реализованы аннотации @RolesAllowed, @PreAuthorize?

Используется сквозная функциональность, с помощью Spring AOP(прокси-объекты). 

#### На каких паттернах строится Spring Security? [X]

- Фабрика (Factory): Класс AuthenticationManagerFactory для создания аутентификационных менеджеров.
- Билдер (Builder): Класс HttpSecurity, который использует паттерн Builder для настройки безопасности приложения.
- Стратегия (Strategy): Интерфейс AuthenticationProvider для реализации различных стратегий аутентификации (например, DaoAuthenticationProvider, OAuth2AuthenticationProvider).
- Декоратор (Decorator): Класс SecurityContextHolder, который оборачивает контекст безопасности.
- Адаптер (Adapter): Класс WebAuthenticationDetailsSource, который адаптирует запросы для аутентификации.
- Цепочка обязанностей: цепочка фильтров Security


#### Как настроить собственный фильтр безопасности в Spring Security и в каких случаях это может быть необходимо?

- OncePerRequestFilter#doFilterInternal()
- AbstractAuthenticationToken
- SecurityConfig#securityFilterChain()

UserCases:

- Если используете токены JWT или OAuth2, и нужно проверять их вручную.
- Проверка специфических заголовков или параметров запроса. Если API требует наличия определённых заголовков (как в примере выше).
3. Добавление дополнительной логики безопасности. Проверка IP-адреса клиента, ограничение количества запросов или анализ поведения пользователя.
4. Обработка нестандартных сценариев.  Если нужно реализовать двухфакторную аутентификацию или другие сложные механизмы.
5. Логирование и мониторинг (ELK, Prometheus). Фильтр для записи информации о запросах в логи или отправки её в систему мониторинга. Добавление в Mapped Diagnostic Context - cliendId

#### Filter vs Interceptor [X]

Фильтры (Filter) работают на уровне сервлетов, до того как запрос попадет в Spring. Они видят сырой HTTP-запрос и могут его изменять, но не имеют доступа к Spring-контексту. Фильтры хороши для задач типа сжатия ответов, кеширования, базовой аутентификации. Настраиваются через web.xml или @WebFilter.

Интерцепторы (Interceptor) работают внутри Spring MVC, после DispatcherServlet. Они имеют доступ к Spring-контексту и знают, какой именно контроллер будет обрабатывать запрос. Интерцепторы могут выполнять код до и после вызова метода контроллера. Подходят для проверки прав доступа, логирования времени выполнения, добавления общих данных в модель. Настраиваются через WebMvcConfigurer.

Главные различия:

1. Уровень работы - фильтры на уровне сервлетов, интерцепторы в Spring MVC
2. Доступ к Spring - у фильтров нет, у интерцепторов есть
3. Информация о контроллере - фильтры не знают, интерцепторы знают
4. Время выполнения - фильтры срабатывают раньше
    
Фильтры универсальнее и работают для всех запросов, интерцепторы более интегрированы со Spring и видят контекст приложения. В Spring Security обычно используют фильтры для базовой аутентификации и интерцепторы для проверки аннотаций @PreAuthorize.

```java
// Пример интерцептора:
@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
    // Код, запускающийся до выполнения контроллера
    return true; // Если true, выполнение продолжит свой ход
}

@Override
public void postHandle(HttpServletRequest request, HttpServletResponse response, 
                       Object handler, ModelAndView modelAndView) {
    // Код, запускающийся после выполнения контроллера
}

// Пример фильтра:
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) 
        throws IOException, ServletException {
    // Код, работающий до запуска цепочки фильтров
    chain.doFilter(request, response); // Вызов остальных фильтров в цепочке
    // Код, работыющий после прохождения цепочки фильтров
}
```

#### Какие основные классы в Spring Security знаешь?

SecurityContextHolder

```java
Authentication auth = SecurityContextHolder.getContext().getAuthentication();
```

**`Authentication`** Представляет аутентифицированного пользователя:
- `Principal` (логин пользователя)
- `Credentials` (пароль)
- `Authorities` (роли/права)
    
**`AuthenticationManager`** Интерфейс для аутентификации:
```java
Authentication authenticate(Authentication auth) throws AuthenticationException;
```

**`UserDetailsService`** Загружает пользователя по имени (например, из БД):

```java
UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
```

Загружает пользователя по имени (например, из БД):


#### В чем разница между 401 vs 403

| Код              | Название       | Когда использовать?                                                                     | Пример                                                                          |
| ---------------- | -------------- | --------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |
| 401 Unauthorized | Не авторизован | Когда пользователь не предоставил учетные данные (логин/пароль, токен) или они неверны. | - Не отправлен заголовок `Authorization` с токеном.  <br>- Неправильный пароль. |
| 403 Forbidden    | Запрещено      | Когда пользователь авторизован, но не имеет прав на доступ к ресурсу.                   | - Обычный пользователь пытается открыть админ-панель.  <br>- Нет роли `ADMIN`.  |

#### HasRole() vs hasAuthority() в Spring Security

| Метод          | Формат        | Автоматическое преобразование           | Пример использования                     |
| -------------- | ------------- | --------------------------------------- | ---------------------------------------- |
| hasRole()      | `ROLE_<NAME>` | Автоматически добавляет префикс `ROLE_` | .hasRole("ADMIN") → Проверяет ROLE_ADMIN |
| hasAuthority() | Любая строка  | Точное совпадение                       | .hasAuthority("READ_PROFILE")            |
#### Что такое CORS?

CORS (Cross-Origin Resource Sharing) — это механизм, который позволяет веб-приложениям безопасно запрашивать ресурсы с других доменов.

1. Браузер отправляет предварительный запрос (`OPTIONS`) для проверки разрешений.
2. Сервер возвращает заголовки, указывающие, какие домены/методы разрешены.
3. Если разрешено — браузер выполняет основной запрос (GET, POST и т.д.).

CORS работает как диалог между браузером и сервером, основанный на HTTP-заголовках. Когда фронтенд-приложение (например, на сайте `frontend.com`) запрашивает данные с другого домена (`api.com`), браузер автоматически добавляет к запросу заголовок `Origin: https://frontend.com`. Этот заголовок сообщает серверу, откуда пришёл запрос.

Сервер в ответ решает, разрешать ли доступ. Если он включает в ответ заголовок `Access-Control-Allow-Origin` и указывает там адрес запроса (например, `https://frontend.com`) или символ * (разрешение для всех доменов), то браузер пропускает ответ. Если такого заголовка нет или значение не совпадает, браузер блокирует ответ — даже если сервер технически его отправил.

```java
@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
        .cors(cors -> cors.configurationSource(request -> {
            CorsConfiguration config = new CorsConfiguration();
            config.setAllowedOrigins(List.of("http://localhost:3000")); // Разрешенные домены
            config.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE")); // Разрешенные HTTP-методы
            config.setAllowedHeaders(List.of("*")); // Разрешенные заголовки
            config.setAllowCredentials(true); // Разрешить куки (если нужно)
            return config;
        }))
        // Другие настройки...
        .authorizeHttpRequests(auth -> auth.anyRequest().authenticated());
    
    return http.build();
}
```
#### Что такое CSRF?

CSRF или XSRF (Cross-Site Request Forgery) — атака на авторизованного пользователя сайта или веб-приложения, при которой злоумышленник обманом заставляет его выполнить опасное или некорректное действие. CSRF — это атака на доверие браузера к кукам, а не взлом сервера. Злоумышленник заставляет браузер жертвы выполнить вредоносный запрос к уязвимому сайту, где пользователь уже авторизован (сессионные куки отправляются автоматически).

Условия для CSRF:

1. На сайте есть важное действие (перевод денег, смена пароля).
2. Параметры запроса известны атакующему.
3. Авторизация основана только на куках (без дополнительных проверок).

```html
<img src="https://bank.com/transfer?to=hacker&amount=1000" width="0" height="0">
```

```java
@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
        .csrf(csrf -> csrf.disable()) // Отключаем CSRF для stateless API
        // Другие настройки...
        .authorizeHttpRequests(auth -> auth.anyRequest().authenticated());
    
    return http.build();
}
```
#### CORS vs CSRF

- CORS — это политика безопасности браузера, блокирующая запросы между разными доменами, если сервер явно не разрешил их.
- CSRF — это уязвимость, возникающая, когда сайт доверяет автоматически отправляемым кукам без дополнительных проверок.

Примеры

1. CORS:
    - Браузер блокирует запрос с `frontend.com` к `api.com`, если сервер не вернул `Access-Control-Allow-Origin: https://frontend.com`.
2. CSRF:
    - Пользователь авторизован на `bank.com`.
    - Злоумышленник заставляет его перейти на страницу с:
	```html
	<form action="https://bank.com/transfer" method="POST">
	  <input type="hidden" name="to" value="hacker">
	</form>
	<script>document.forms[0].submit();</script>
	```
	- Браузер автоматически отправит куки `bank.com`, и перевод выполнится.
#### Что такое Радужные таблицы?

Атака с использованием радужной таблицы — это метод взлома паролей, при котором злоумышленник использует предварительно вычисленную таблицу («радужную таблицу») для расшифровки хешей паролей из базы данных. Приложения не хранят пароли в открытом виде, а преобразуют их в хеши. При входе пользователя его пароль также хешируется, и результат сравнивается с хранимым хешем на сервере. Если хеши совпадают, пользователь получает доступ.

Радужная таблица содержит предварительно вычисленные хеши для всех возможных комбинаций символов. Если злоумышленник получает доступ к хешам паролей, он может быстро подобрать исходные пароли с помощью такой таблицы.

#### Что такое brute force?

Атака грубой силы (от англ. brute force — «грубая сила») — угроза кибербезопасности, при которой злоумышленники пытаются получить несанкционированный доступ к системе, сети или учётной записи путём систематического перебора всех возможных комбинаций паролей или ключей шифрования, пока не найдут правильную.

#### Что такое bcrypt?

bcrypt — это адаптивный алгоритм хеширования паролей, специально разработанный для безопасного хранения паролей в базах данных. Он сочетает в себе хеш-функцию на основе алгоритма Blowfish с "солью" (salt) и итерациями, что делает его устойчивым к brute force-атакам и радужным таблицам.

- Автоматически генерирует случайную строку (соль) для каждого пароля. Даже одинаковые пароли будут иметь разные хеши. Пример хеша:

```
$2a$12$N9qo8uLOickgx2ZMRZoMy.Ejaz6d8r2q7WYacp7q2l2W7J.h3Z/jK
```

- `$2a$` — версия алгоритма.
- `12` — фактор стоимости (количество итераций = 2^12).
- `N9qo8uLOickgx2ZMRZoMy.` — соль.
- `Ejaz6d8r2q7WYacp7q2l2W7J.h3Z/jK` — хеш.

```java
String password = "user123";
BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(12); // Фактор стоимости = 12
String hashedPassword = encoder.encode(password);
// Результат: $2a$12$N9qo8uLOickgx2ZMRZoMy.Ejaz6d8r2q7WYacp7q2l2W7J.h3Z/jK
boolean isMatch = encoder.matches("user123", hashedPassword); // true/false
```
#### Что такое соль?

Соль — это случайная строка данных, которая добавляется к паролю перед его хешированием. Её главная цель — сделать каждый хеш уникальным, даже если исходные пароли одинаковы, и усложнить атаки (например, перебор по радужным таблицам).

Без соли хеши одинаковых парлей (например, `123456`) будут идентичны. Соль гарантирует, что даже простые пароли дают уникальные хеши.

Типы солей

1. Общая (static salt)
    - Одна соль для всех паролей (например, строка `"abc"`).
2. Уникальная (per-user salt)
    - Своя соль для каждого пользователя.
    - Стандарт безопасности. Используется в bcrypt, PBKDF2.
3. Динамическая (pepper)
    - Дополнительный секретный ключ, общий для всех паролей (хранится отдельно от БД).
    - Пример: `hash(password + salt + pepper)`.
#### Что такое Session Management?

Session Management — это механизм, который позволяет серверу отслеживать взаимодействие с пользователем в течение одной "сессии" (например, пока пользователь авторизован на сайте).

Как это работает?

1. Создание сессии
    - Когда пользователь входит в систему (логинится), сервер создает уникальный идентификатор сессии (Session ID).
    - Этот ID сохраняется:
        - На сервере (в памяти, БД или Redis).
        - У клиента (в куки-файле или LocalStorage).
2. Подтверждение сессии
    - При каждом запросе браузер отправляет Session ID на сервер.
    - Сервер проверяет ID и "узнаёт" пользователя.
3. Завершение сессии
    - При выходе (logout) или истечении времени бездействия (timeout) сессия удаляется.

```java
@Configuration
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .sessionManagement(session -> session
                .maximumSessions(1) // 1 сессия на пользователя
                .maxSessionsPreventsLogin(false) // Новый вход завершает старую сессию
                .expiredUrl("/login?expired") // Перенаправление при истечении сессии
            )
            .logout(logout -> logout
                .logoutUrl("/logout") // URL для выхода
                .deleteCookies("JSESSIONID") // Удаление куки
                .invalidateHttpSession(true) // Очистка сессии
            );
        return http.build();
    }
}
```

#### Что такое Stateless Session Management?

Stateless Session Management — это подход, при котором сервер не хранит данные сессии (например, в памяти, БД или Redis). Вместо этого вся необходимая информация для аутентификации и авторизации передается в каждом запросе (обычно в виде токена).

✅ Масштабируемость: Серверы не зависят от общего хранилища сессий (подходит для микросервисов).  
✅ Производительность: Нет запросов к БД/Redis для проверки сессии.  
✅ Поддержка мобильных приложений: Не требует кук (используется заголовок `Authorization`).

❌ Сложность отзыва токенов: Токен валиден до истечения срока (`exp`), даже если пользователь вышел.  
❌ Риск утечки токена: Если токен украден, злоумышленник может им воспользоваться.  
❌ Увеличенный размер запросов: Токен может быть большим (особенно если содержит много данных).

### OAuth 2.0

#### Что такое OAuth?

 С его помощью вы можете разрешить приложению доступ к вашим данным или функциям другого приложения от вашего имени, не раскрывая свой пароль. OAuth 2.0 делает этот процесс удобным и безопасным, предоставляя следующие ключевые преимущества:

- Повышенная безопасность. OAuth 2.0 позволяет предоставлять доступ к данным без необходимости передачи пароля, что защищает учётные данные пользователя от компрометации.
- Ограничение прав доступа. OAuth предоставляет доступ только к необходимым данным и функциям. Например, приложение может получить доступ к контактам, но не к личным сообщениям или файлам пользователя.
- Гибкость. OAuth 2.0 поддерживает различные типы разрешений, что позволяет адаптировать его под разные приложения (веб, мобильные и серверные) и сценарии доступа.
- Централизованное управление доступом. OAuth 2.0 даёт владельцу ресурса возможность управлять списком приложений, которым предоставлен доступ, и отзывать доступ в любой момент.
- Поддержка единого входа (SSO). OAuth 2.0 легко интегрируется с решениями SSO, такими как OpenID Connect, что позволяет пользователям использовать один аккаунт для доступа ко многим сервисам, упрощая процесс входа.

#### Основные роли в OAuth [X]

- Владелец ресурса. Это пользователь, который владеет данными (такими как контакты в Gmail). Именно он решает, кому и в каком объёме предоставить доступ к своим данным. В некоторых случаях владельцем ресурса может быть не пользователь, а другой сервер, например, при взаимодействии серверов между собой.
- Клиент. Это устройство пользователя **или сервис**, которому требуется доступ к данным владельца ресурса. К примеру Facebook выступает клиентом, запрашивая доступ к контактам пользователя в Gmail для отправки приглашений.
- Сервер ресурсов. Это сервер, где хранятся защищённые данные владельца ресурса. В данном примере сервером ресурсов является сервер Gmail, на котором лежат контакты пользователя.
- Авторизационный сервер. Этот сервер отвечает за проверку прав доступа к данным. В нашем примере, авторизационный сервер – это сервер Google, который выполняет аутентификацию пользователя и выдаёт токен доступа (access token), подтверждающий разрешение на доступ к данным.

#### Что такое Access Token? [X]

Ключевая цель процесса OAuth – предоставить клиенту (к примеру Facebook) доступ к данным, не раскрывая пароля. Клиент должен получить от авторизационного сервера специальный токен доступа (access token). Этот токен позволяет запрашивать данные у сервера ресурсов, но ограничивает доступ в соответствии с заданными разрешениями.

Особенности Access Token:

- Ограниченное время жизни. Access token имеет ограниченный срок действия для повышения безопасности.
- Возможность отзыва. Если есть подозрение, что токен скомпрометирован, его можно отозвать, заблокировав дальнейший доступ.
- Отдельность от пароля. Компрометация токена не означает утечку пароля, так как из токена невозможно получить логин и пароль пользователя.
- Ограниченные права доступа (scope). Access token может предоставить доступ только к определённым данным. Например, Facebook может запросить доступ только к списку контактов, но не к сообщениям.
#### Что такое Refresh Token ? [X]

Помимо access token, авторизационный сервер может выдать клиенту и refresh token. Когда срок действия access token истекает, клиент отправляет запрос к авторизационному серверу, передавая refresh token. Авторизационный сервер проверяет его действительность и, если всё в порядке, выдаёт новый access token. Этот процесс позволяет сохранить сессию пользователя активной без необходимости повторной аутентификации.

Поскольку refresh token даёт возможность запрашивать новые access token, его потеря или компрометация представляет серьёзную угрозу. В случае утечки злоумышленник может получить долгосрочный доступ к данным. Поэтому рекомендуется хранить refresh token в защищённой среде, особенно в серверных приложениях.

#### Способы получения Access Token в OAuth 2.0 ? [X]

Существует четыре основных способа получения access token в OAuth 2.0, каждый из которых подходит для определённых сценариев:

- Authorization Code Grant. Это самый безопасный и надёжный метод. Он предполагает обмен одноразового кода авторизации на access token через серверную часть приложения, что делает его менее уязвимым к перехвату токена.

```
Браузер → /auth?response_type=code → Сервер авторизации → /callback?code=XYZ  
Сервер приложения → /token (code=XYZ + client_secret) → access_token
```

- Implicit Grant. Более простой метод, используемый для клиентских приложений без серверной части, таких как SPA (Single Page Applications). access token передаётся напрямую через URL-фрагмент, что упрощает реализацию, но снижает безопасность, так как токен может быть доступен через JavaScript.

```
Браузер → /auth?response_type=token → Сервер авторизации → /callback#access_token=ABC
```

- Resource Owner Password Credentials. Password — для "своих" клиентов, но требует доверия. В этом методе пользователь передаёт свои логин и пароль напрямую клиенту, который затем запрашивает access token у сервера авторизации. Он подходит только для доверенных клиентов, так как пользователь делится своими учётными данными с клиентом, что создаёт риск утечки.

```
POST /token  
grant_type=password&username=user&password=123&client_id=XYZ
```

- Client Credentials. Используется для межсерверного взаимодействия, когда одно серверное приложение (клиент) запрашивает access token у авторизационного сервера с использованием client_id и client_secret. Этот метод подходит для сценариев, когда доступ к ресурсам необходим от имени самого клиента, а не пользователя.

```
POST /token  
grant_type=client_credentials&client_id=XYZ&client_secret=123
```
#### Что такое Client Credentials? [X]

![](../../../_res/oauth-client-credentials.png)

Каждый клиент должен быть зарегистрирован на авторизационном сервере. В процессе регистрации клиент получает уникальные идентификаторы:

- client_id – это публичный идентификатор клиента, который передаётся в каждом запросе на авторизацию. Он позволяет авторизационному серверу определить, какое приложение запрашивает доступ.
- client_secret – это секретный ключ, который используется для проверки подлинности клиента. Он должен храниться в надёжном месте и не должен быть раскрыт третьим лицам.

Запрос токена (1). Service 1 отправляет запрос к авторизационному серверу, передавая свои client_id и client_secret. Это делается с использованием метода POST и указанием типа авторизации grant_type=client_credentials:

Здесь audience указывает целевой ресурс (Service 2), для которого будет действовать access_token. Это поле определяет, какие именно ресурсы будут доступны по этому токену. Авторизационный сервер проверяет `audience` при выдаче токена, чтобы убедиться, что запрос направлен на доступ к конкретному API. Это помогает избежать использования токена не по назначению и усиливает безопасность.

Получение access_token (2). В ответ на запрос авторизационный сервер выдаёт `access_token`, который Service 1 может использовать для обращения к Service 2:

- access_token: строка токена, которая используется для авторизации запросов к Service 2. Это временный токен доступа.
- token_type: обычно Bearer, что указывает на способ передачи токена в заголовке Authorization.
- expires_in: время действия токена в секундах (например, 86400 секунд, что соответствует 24 часам). После этого срока действия токен становится недействительным.

Обращение к Service 2 (3). Service 1 использует полученный `access_token` для отправки запросов к Service 2. Токен передаётся в заголовке `Authorization` с типом `Bearer`:

Проверка токена (4). Получив запрос с `access_token`, Service 2 должен убедиться, что токен действителен и не был отозван. Для этого существуют два подхода:

- Запрос к авторизационному серверу: Service 2 может обратиться к авторизационному серверу с помощью протокола, описанного в [RFC 7662](https://datatracker.ietf.org/doc/html/rfc7662), чтобы проверить действительность токена. Авторизационный сервер может подтвердить, что токен не истёк и не был отозван.
- Локальная проверка с использованием JWT: Если `access_token` представлен в виде JWT (JSON Web Token), Service 2 может выполнить локальную проверку токена. JWT содержит в себе закодированную информацию о клиенте и правах доступа, и Service 2 может проверить подпись токена, чтобы убедиться в его подлинности без обращения к авторизационному серверу. Это снижает нагрузку на сервер и ускоряет обработку запросов.

Вообще Client Credentials flow используется, если клиент — не человек, а машина. То есть перенаправления на страницу сервера авторизации и получения согласия живого пользователя не требуется, что упрощает flow. Наш клиент — это микросервис, который предоставляет API веб-интерфейсу. Но важно понимать, что несмотря на наличие веб-интерфейса, клиентом является именно приложение на сервере, а не в браузере.

#### Из чего состоит JWT [X]

JWT (JSON Web Token) состоит из трёх основных частей: заголовка (header), полезной нагрузки (payload) и подписи (signature).

![](../../../_res/Pasted%20image%2020250412110803.png)


Header.

Поле `typ` обозначает тип токена. Хотя некоторые приложения могут игнорировать это поле, стандарт рекомендует его включать для обеспечения совместимости.

Поле `alg` обязательно и указывает на алгоритм, используемый для подписи токена. В данном примере применяется алгоритм HMAC-SHA256 (HS256), который использует единый секретный ключ для подписи и проверки.

Payload

Полезная нагрузка — это данные, которые передаются в JWT. Стандарт предусматривает несколько зарезервированных полей, которые называют “claims”:

- `iss` — (issuer) издатель токена.
- `sub` — (subject) назначение токена.
- `aud` — (audience) аудитория, для которой предназначен токен.
- `exp` — (expire time) срок действия токена.
- `nbf` — (not before) время, до которого токен недействителен.
- `iat` — (issued at) время создания токена.
- `jti` — (JWT id) уникальный идентификатор токена.

> Эти поля не являются обязательными, но важно использовать их правильно, чтобы избежать коллизий и ошибок в обработке.

Кроме зарезервированных полей, можно передавать любые данные по договорённости между сторонами. Например, следующий `payload` содержит информацию об издателе, назначении токена, времени истечения срока действия, времени выпуска и идентификаторе пользователя:

```json
{
  "iss": "Auth Server",
  "sub": "auth",
  "exp": 1505467756869,
  "iat": 1505467152069,
  "user": 1
}
```

  
- Поскольку содержимое payload не шифруется, не рекомендуется передавать в нём чувствительные данные, такие как паспортные данные или пароли.
- Размер payload не ограничен, но его увеличение может негативно сказаться на производительности.

Signature

Подпись генерируется следующим образом: закодированные в Base64 заголовок и полезная нагрузка объединяются через точку (.). Получившаяся строка хешируется с использованием алгоритма, указанного в заголовке (header). Результат этого хеширования и есть подпись.

Другие микросервисы могут проверять JWT-токен двумя способами:

- Симметричный алгоритм (например, HS256): Все сервисы знают единый секретный ключ, который используется для подписи токенов.
- Асимметричный алгоритм (например, RS256): В этом случае сервер авторизации использует приватный ключ для подписания токенов, а другие сервисы могут проверять подпись, используя соответствующий публичный ключ. Такой подход более безопасен, так как приватный ключ остаётся только у сервера авторизации.

#### Как с помощью JWT организовать ассиметричный алгоритм аутентификации [X]

```json
header:
{
    "alg": "RS256",
    "typ": "JWT"
}
payload:
{
    "id": "1337",
    "username": "bizone",
    "iat": 1594209600,
    "role": "user"
}
signature:
YLOVSKef-paSnnM8P2JLaU2FiS8TbhYqjewLmgRJfCj1Q6rVehAHQ-lABnKoRjlEmHZX-rufHEocDxGUYiGMjMexUQ3zt-WqZITvozJ4pkvbV-mJ1nKj64NmqaR9ZkBWtmF-PHJX50eYjgo9rzLKbVOKYOUa5rDkJPHP3U0aaBXFP39zsGdOTuELv436WXypIZBeRq2yA_mDH13TvzegWCK5sjD4Gh177bCq57tBYjhGIQrDypVe4cWBPlvwFlmG8tdpWGu0uFp0GcbTAfLUlbTSuGROj88BY0XeUs0iqmGlEICES3uqNx7vEmdT5k_AmL436SLedE0VHcyxve5ypQ
```

В кодированном виде он будет выглядеть следующим образом: `eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjEzMzciLCJ1c2VybmFtZSI6ImJpem9uZSIsImlhdCI6MTU5NDIwOTYwMCwicm9sZSI6InVzZXIifQ.YLOVSKef-paSnnM8P2JLaU2FiS8TbhYqjewLmgRJfCj1Q6rVehAHQ-lABnKoRjlEmHZX-rufHEocDxGUYiGMjMexUQ3zt-WqZITvozJ4pkvbV-mJ1nKj64NmqaR9ZkBWtmF-PHJX50eYjgo9rzLKbVOKYOUa5rDkJPHP3U0aaBXFP39zsGdOTuELv436WXypIZBeRq2yA_mDH13TvzegWCK5sjD4Gh177bCq57tBYjhGIQrDypVe4cWBPlvwFlmG8tdpWGu0uFp0GcbTAfLUlbTSuGROj88BY0XeUs0iqmGlEICES3uqNx7vEmdT5k_AmL436SLedE0VHcyxve5ypQ`

Поскольку в этом случае мы используем для подписи алгоритм RS256, нам понадобятся публичный и приватный ключи.

```ssl
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnzyis1ZjfNB0bBgKFMSv
vkTtwlvBsaJq7S5wA+kzeVOVpVWwkWdVha4s38XM/pa/yr47av7+z3VTmvDRyAHc
aT92whREFpLv9cj5lTeJSibyr/Mrm/YtjCZVWgaOYIhwrXwKLqPr/11inWsAkfIy
tvHWTxZYEcXLgAXFuUuaS3uF9gEiNQwzGTU1v0FqkqTBr4B8nW3HCN47XUu0t8Y0
e+lf4s4OxQawWD79J9/5d3Ry0vbV3Am1FtGJiJvOwRsIfVChDpYStTcHTCMqtvWb
V6L11BWkpzGXSW4Hv43qa+GSYOD2QU68Mb59oSk2OB+BtOLpJofmbGEGgvmwyCI9
MwIDAQAB
-----END PUBLIC KEY-----
```

Публичный ключ

```ssl
-----BEGIN RSA PRIVATE KEY-----
MIIEogIBAAKCAQEAnzyis1ZjfNB0bBgKFMSvvkTtwlvBsaJq7S5wA+kzeVOVpVWw
kWdVha4s38XM/pa/yr47av7+z3VTmvDRyAHcaT92whREFpLv9cj5lTeJSibyr/Mr
m/YtjCZVWgaOYIhwrXwKLqPr/11inWsAkfIytvHWTxZYEcXLgAXFuUuaS3uF9gEi
NQwzGTU1v0FqkqTBr4B8nW3HCN47XUu0t8Y0e+lf4s4OxQawWD79J9/5d3Ry0vbV
3Am1FtGJiJvOwRsIfVChDpYStTcHTCMqtvWbV6L11BWkpzGXSW4Hv43qa+GSYOD2
QU68Mb59oSk2OB+BtOLpJofmbGEGgvmwyCI9MwIDAQABAoIBACiARq2wkltjtcjs
kFvZ7w1JAORHbEufEO1Eu27zOIlqbgyAcAl7q+/1bip4Z/x1IVES84/yTaM8p0go
amMhvgry/mS8vNi1BN2SAZEnb/7xSxbflb70bX9RHLJqKnp5GZe2jexw+wyXlwaM
+bclUCrh9e1ltH7IvUrRrQnFJfh+is1fRon9Co9Li0GwoN0x0byrrngU8Ak3Y6D9
D8GjQA4Elm94ST3izJv8iCOLSDBmzsPsXfcCUZfmTfZ5DbUDMbMxRnSo3nQeoKGC
0Lj9FkWcfmLcpGlSXTO+Ww1L7EGq+PT3NtRae1FZPwjddQ1/4V905kyQFLamAA5Y
lSpE2wkCgYEAy1OPLQcZt4NQnQzPz2SBJqQN2P5u3vXl+zNVKP8w4eBv0vWuJJF+
hkGNnSxXQrTkvDOIUddSKOzHHgSg4nY6K02ecyT0PPm/UZvtRpWrnBjcEVtHEJNp
bU9pLD5iZ0J9sbzPU/LxPmuAP2Bs8JmTn6aFRspFrP7W0s1Nmk2jsm0CgYEAyH0X
+jpoqxj4efZfkUrg5GbSEhf+dZglf0tTOA5bVg8IYwtmNk/pniLG/zI7c+GlTc9B
BwfMr59EzBq/eFMI7+LgXaVUsM/sS4Ry+yeK6SJx/otIMWtDfqxsLD8CPMCRvecC
2Pip4uSgrl0MOebl9XKp57GoaUWRWRHqwV4Y6h8CgYAZhI4mh4qZtnhKjY4TKDjx
QYufXSdLAi9v3FxmvchDwOgn4L+PRVdMwDNms2bsL0m5uPn104EzM6w1vzz1zwKz
5pTpPI0OjgWN13Tq8+PKvm/4Ga2MjgOgPWQkslulO/oMcXbPwWC3hcRdr9tcQtn9
Imf9n2spL/6EDFId+Hp/7QKBgAqlWdiXsWckdE1Fn91/NGHsc8syKvjjk1onDcw0
NvVi5vcba9oGdElJX3e9mxqUKMrw7msJJv1MX8LWyMQC5L6YNYHDfbPF1q5L4i8j
8mRex97UVokJQRRA452V2vCO6S5ETgpnad36de3MUxHgCOX3qL382Qx9/THVmbma
3YfRAoGAUxL/Eu5yvMK8SAt/dJK6FedngcM3JEFNplmtLYVLWhkIlNRGDwkg3I5K
y18Ae9n7dHVueyslrb6weq7dTkYDi3iOYRW8HRkIQh06wEdbxt0shTzAJvvCQfrB
jg/3747WSsf/zBTcHihTRBdAv6OmdhV4/dD5YBfLAkLrd+mX7iE=
-----END RSA PRIVATE KEY-----
```

Для предотвращения такой атаки рекомендуется:

- **Использовать белый список алгоритмов**. Разрешать только конкретные алгоритмы подписи на сервере, например, RS256. Все токены с неподдерживаемыми алгоритмами должны быть отклонены.
- **Строго разделять симметричные и асимметричные алгоритмы**. Если используется асимметричная схема, как RS256, то симметричные алгоритмы (например, HS256) не должны быть допустимы.
- **Проверка библиотеки**. Убедитесь, что библиотека для работы с JWT правильно реализует проверку подписей, и не использует публичный ключ как секретную фразу при симметричных алгоритмах.
#### Как предотвратить утечку JWT токена? [X]

- Используйте HTTPS для всех запросов, передающих JWT, чтобы предотвратить перехват токена.
- Использование HttpOnly cookie. Вместо хранения JWT в localStorage или sessionStorage, лучше использовать HttpOnly cookies. Эти cookie недоступны для JavaScript, что значительно снижает риск кражи токена через XSS-атаки 
- Не храните в JWT чувствительные данные. В полезной нагрузке стоит передавать только минимально необходимые данные, такие как обезличенные идентификаторы пользователей или данные, которые не представляют угрозу в случае утечки.
- Ограничьте срок действия JWT. Это минимизирует время, в течение которого перехваченный токен остаётся активным. Обычно рекомендуется устанавливать срок действия токена на несколько минут.
- Используйте механизм обновления токенов (refresh tokens). В случае короткого срока действия JWT можно использовать refresh-токен для безопасного получения нового JWT без необходимости повторной аутентификации. Refresh-токены также должны быть передаваемы только по защищённому соединению и иметь более строгие механизмы контроля.

#### Что такое Resource Owner Password Credential ? [X]

Эта схема авторизации является одной из самых простых, но при этом наименее безопасных. В самом стандарте OAuth 2.0 отмечено, что её использование не рекомендуется, и следует прибегать к ней только в том случае, если невозможно реализовать более безопасные схемы авторизации.

Схема Resource Owner Password Credential предполагает передачу пользователем своих учётных данных (логина и пароля) напрямую клиенту, что создаёт значительные риски для безопасности. Этот метод удобен, когда клиент и сервер авторизации находятся под контролем одной организации, однако он крайне уязвим при взаимодействии с третьими сторонами.

1. Передача логина и пароля. Владелец ресурсов (пользователь) передаёт свои логин и пароль клиенту, доверяя ему обработку этих данных. Это предполагает, что клиент является безопасным и не будет злоупотреблять полученными учётными данными.
2. Запрос токена клиентом. Клиент затем отправляет логин и пароль пользователя на авторизационный сервер вместе с `client_id` и `client_secret` для аутентификации:

```curl
curl -d "grant_type=password" \
    -d "client_id=3MVG9QDx8IKCsXTFM0o9aE3KfEwsZLvRt" \
    -d "client_secret=4826278391389087694" \
    -d "username=ryan%40ryguy.com" \
    -d "password=_userspassword__userssecuritytoken_" \
    https://as.com/oauth2/token
```

Если авторизационный сервер успешно аутентифицирует учётные данные пользователя, он возвращает `access_token`, который клиент может использовать для доступа к ресурсам:

```json
{
    "id":"https://as.com/id/00DU0000000Io8rMAC/005U0000000hMDCIA2",
    "issued_at":"1316990706988",
    "instance_url":"https://na12.salesforce.com",
    "signature":"Q2KTt8Ez5dwJ4Adu6QttAhCxbEP3HyfaTUXoNI=",
    "access_token":"00DU0000000Io8r!AQcKbNiJPt0OCSAvxU2SBjVGP6hW0mfmKH07QiPEGIX"
}
```

#### Что такое Authorization Code Grant

Authorization Code Grant – это рекомендуемый способ авторизации для OAuth 2.0, особенно в тех случаях, когда речь идёт о серверных приложениях. Он обеспечивает высокий уровень безопасности, поскольку позволяет хранить учётные данные клиента и секреты на серверной стороне, недоступной для посторонних.

Этот метод подходит для веб-приложений, где исходный код и секреты клиента остаются скрытыми от пользователей. Исключением для использования этого метода является межсерверное взаимодействие, где больше подходит схема Client Credentials.

Этот способ авторизации включает несколько этапов, обеспечивающих безопасный обмен данными между клиентом и сервером:

Пользователь на сайте нажимает кнопку авторизации (например, «Войти через Facebook»), инициируя процесс получения прав доступа. После этого происходит перенаправление пользователя на страницу авторизационного сервера, где он должен пройти аутентификацию.

Пользователь видит страницу авторизационного сервера:

1. Если у него уже есть активная сессия на авторизационном сервере, то он просто подтверждает своё согласие на предоставление доступа.
2. Если сессии нет, пользователь должен войти в свой аккаунт на авторизационном сервере.

После успешной аутентификации пользователь перенаправляется на URL-адрес, указанный клиентом в параметре `redirect_uri`. Пример авторизационного запроса выглядит следующим образом:

```curl
https://YOUR_DOMAIN/authorize
     ?response_type=code
     &client_id=YOUR_CLIENT_ID
     &redirect_uri=https://YOUR_APP/callback
     &scope=SCOPE
     &audience=API_AUDIENCE
     &state=STATE
```

- `response_type=code` – указывает, что авторизационный сервер должен вернуть одноразовый код авторизации.
- `redirect_uri` – URL-адрес, на который авторизационный сервер перенаправит пользователя после завершения авторизации. Код авторизации будет передан в параметре `code`. В настройках авторизационного сервера можно указать разрешённые адреса redirect_uri для предотвращения атак на переадресацию (redirect attacks).

Если авторизация прошла успешно, клиент получает код авторизации через HTTP-ответ 302, где в URL содержится параметр code:

```http
HTTP/1.1 302
Found Location: https://YOUR_APP/callback?code=AUTHORIZATION_CODE&state=xyzABC123
```

Код авторизации (`code`) – это одноразовый короткоживущий код, который клиент должен использовать для обмена на access_token. Он отправляется через браузер, поэтому уязвим для атак.

После получения кода авторизации, клиент отправляет POST-запрос к авторизационному серверу для обмена кода на access_token и другие токены:

```curl
curl --request POST \
    --url 'https://YOUR_DOMAIN/oauth/token' \
    --header 'content-type: application/x-www-form-urlencoded' \
    --data 'grant_type=authorization_code' \
    --data 'client_id=YOUR_CLIENT_ID' \
    --data 'client_secret=YOUR_CLIENT_SECRET' \
    --data 'code=YOUR_AUTHORIZATION_CODE' \
    --data 'redirect_uri=https://YOUR_APP/callback' 
```

Здесь указывается `grant_type=authorization_code`, который указывает на тип авторизации, и параметры `client_id`, `client_secret`, `code` и `redirect_uri` для идентификации клиента и подтверждения запроса.

Если обмен прошёл успешно, авторизационный сервер возвращает HTTP-ответ с полезной нагрузкой в формате JSON, содержащей различные токены:

```json
{
    "access_token": "eyJz93a...k4laUWw",
    "refresh_token": "GEbRxBN...edjnXbL",
    "id_token": "eyJ0XAi...4faeEoQ",
    "token_type": "Bearer",
    "expires_in": 3600
}
```

- `access_token` – используется для доступа к защищённым ресурсам.
- `refresh_token` – позволяет запросить новый access_token после его истечения.
- `id_token` – используется для передачи информации о пользователе (при использовании OpenID Connect).
- `expires_in` – срок действия access_token в секундах.

После получения access_token клиент может использовать его для авторизации запросов к защищённым API, добавляя токен в заголовок Authorization:

```curl
curl --request GET \
    --url https://myapi.com/api \
    --header 'authorization: Bearer ACCESS_TOKEN' \
    --header 'content-type: application/json' 
```

API проверяет подлинность токена и предоставляет доступ к ресурсам в зависимости от разрешений (`scope`), указанных при запросе авторизации.

#### Что такое Implicit Grant? [X]

Implicit Grant предназначен для приложений без серверной части, таких как SPA (Single Page Applications). Этот метод упрощает процесс получения access_token, но делает его менее безопасным по сравнению с другими схемами.

Принцип работы

Пользователь нажимает на кнопку авторизации на сайте (например, «Войти через Google»), что инициирует процесс авторизации. Затем пользователь перенаправляется на страницу авторизационного сервера.

Если у пользователя уже есть активная сессия, он просто подтверждает доступ. В противном случае ему нужно ввести свои логин и пароль на странице авторизационного сервера.

После успешной аутентификации пользователь перенаправляется обратно на сайт клиента, и access_token передаётся в виде фрагмента URL после символа `#`:

```
https://domain.com/back_path#access_token=8ijfwWEFFf0wefOofreW6rglk
```

Хотя `access_token` передаётся в URL, он остаётся доступен только в браузере и не отправляется на сервер при выполнении HTTP-запросов. Это связано с тем, что фрагмент предназначен исключительно для обработки на стороне клиента. JavaScript в браузере может прочитать фрагмент через `window.location.hash` и извлечь токен:

```js
const accessToken = window.location.hash.split('=')[1];
fetch('https://api.example.com/data', {
    method: 'GET',
    headers: {
        'Authorization': `Bearer ${accessToken}`
    }
});
```

Приложение использует этот токен для выполнения защищённых запросов к API, добавляя его в заголовок `Authorization`. Благодаря использованию HTTPS соединение зашифровано, и сам токен не виден в сети

```js
fetch('https://api.example.com/data', {
    method: 'GET',
    headers: {
        'Authorization': 'Bearer 8ijfwWEFFf0wefOofreW6rglk'
    }
});
```

Уязвимости передачи токена через URL

Из-за этих рисков использование Implicit Grant рекомендуется ограничивать, особенно в случаях, когда возможна реализация более защищённых методов авторизации

Доступность фрагмента в браузере. Хотя фрагменты URL не передаются на сервер, они доступны в JavaScript. Это делает токен уязвимым для межсайтового скриптинга (XSS), когда злонамеренные скрипты могут извлечь access_token из URL и передать его злоумышленнику

Сохранение в истории браузера и закладках. URL с access_token может быть случайно сохранён в истории браузера или закладках. Это создаёт риск утечки токена, если пользователь случайно поделится таким URL с другими или если на устройстве установлено вредоносное ПО, которое может получить доступ к истории браузера.

Неправильная настройка redirect_uri. Если redirect_uri не проверяется строго и злоумышленник указывает свой собственный URI, он может получить access_token. В этом случае пользователь будет перенаправлен на страницу, контролируемую злоумышленником, с токеном в URL-фрагменте, что позволит злоумышленнику с помощью JavaScript считать этот токен

Проблемы с перенаправлениями (redirects). Если redirect_uri неправильно настроен и не проверяется должным образом, злоумышленники могут подставить собственный URI и перехватить access_token. Это может привести к утечке токена, если сервер авторизации перенаправляет пользователя на контролируемый злоумышленником сайт

#### Что такое OpenID Connect? [X]

OAuth 2.0 — это протокол, предназначенный для авторизации, который позволяет одному приложению предоставлять доступ к своим данным и функциям другому приложению, без необходимости делиться учётными данными пользователя.

Однако OAuth 2.0 сам по себе не решает задачу аутентификации — подтверждения личности пользователя. Чтобы добавить эту возможность, был разработан OpenID Connect (OIDC) — слой, который дополняет OAuth 2.0, делая его полноценным решением для аутентификации.

![](../../../_res/id-authent-author.png)

OpenID Connect — это расширение протокола OAuth 2.0, которое добавляет возможность проверять личность пользователя, входящего в систему. Оно добавляет функциональность аутентификации, что позволяет приложениям не только получать доступ к данным пользователя, но и узнавать, кто именно вошёл в систему.

Таким образом, OIDC предоставляет возможность реализовать единую аутентификацию (SSO) — сценарии, при которых один и тот же логин может использоваться для доступа к нескольким приложениям.

Поток авторизации в OpenID Connect очень похож на стандартный поток OAuth 2.0, но с некоторыми важными дополнениями:

Использование специального `scope`. В запросе на авторизацию клиент указывает `scope=openid`, что сообщает серверу авторизации, что требуется не только доступ к данным, но и информация о пользователе. Дополнительно могут указываться другие `scope`, например, `profile` или `email`, чтобы запросить более детальную информацию о пользователе.

Вместе с access_token клиент получает ещё и **id_token**. id_token представляет собой [JSON Web Token (JWT)](https://struchkov.dev/blog/ru/what-is-jwt/), который содержит информацию о пользователе: его уникальный идентификатор, имя, время аутентификации и срок действия токена. В отличие от access_token, который используется для доступа к API, id_token предназначен для подтверждения личности пользователя. Он позволяет клиенту убедиться, что пользователь успешно прошёл аутентификацию.

Клиент может проверять подлинность и целостность id_token самостоятельно, не обращаясь к серверу. Это достигается благодаря тому, что JWT подписывается на стороне сервера авторизации. Клиент может расшифровать JWT с помощью публичного ключа сервера и убедиться, что токен не был изменён, а также проверить его срок действия и другие параметры.

Если access_token был запрошен вместе с openid, клиент также может использовать его для получения дополнительных сведений о пользователе с помощью UserInfo Endpoint. Этот специальный эндпоинт на сервере авторизации позволяет запрашивать данные, такие как адрес электронной почты, имя пользователя, аватар и другую профильную информацию.

#### Чем отличаются OpenID и OAuth? [X]

OpenID предназначен для аутентификации — то есть для того, чтобы понять, что этот конкретный пользователь является тем, кем представляется. Например, с помощью OpenID некий сервис Ололо может понять, что зашедший туда пользователь, это именно Рома Новиков с Mail.Ru. При следующей аутентификации Ололо сможет его опять узнать и понять, что, это тот же Рома, что и в прошлый раз.  
  
OAuth же является протоколом авторизации, то есть позволяет выдать права на действия, которые сам Ололо сможет производить в Mail.Ru от лица Ромы. При этом Рома после авторизации может вообще не участвовать в процессе выполнения действий, например, Ололо сможет самостоятельно заливать фотографии на Ромин аккаунт.
### Resources

- [Что такое JWT токен?](https://struchkov.dev/blog/ru/what-is-jwt/)
- [Реализация JWT в Spring Boot](https://struchkov.dev/blog/ru/jwt-implementation-in-spring/)
- [Как работает OAuth 2.0 и OpenID Connect](https://struchkov.dev/blog/ru/how-oauth2-works/)
- [OAuth 2 Authorization Code Flow. Пример на Spring Boot](https://sysout.ru/oauth-2-authorization-code-flow-primer-na-spring-boot/)
- [Иллюстрированное руководство по OAuth и OpenID Connect](https://habr.com/ru/companies/flant/articles/475942/)
- [Строим свой SSO сервер используя Spring Authorization Server](https://habr.com/ru/articles/737548/)
- [OAuth в мобильных приложениях](https://habr.com/ru/companies/kts/articles/654029/)