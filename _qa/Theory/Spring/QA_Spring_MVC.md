> 1. MVC это аббревиатура специального паттерна. Что это за паттерн и для чего он нужен?

MVC — это специальный шаблон. Он делит программу на 3 вида компонентов:

- Model — модель отвечает за хранение данных.
- View — отвечает за вывод данных на фронтенде.
- Controller — отвечает за обмен данными с view. Он оперирует моделями.

> 2. Что такое DispatcherServlet и где он используется?

Это одна из главных частей MVC для обмена данными. Это главный сервлет, распределяющий запросы между обычными сервлетами.

- Он получает запросы и отправляет их зарегистрированным обработчикам
- Обрабатывает views, сопоставляя их имена с объектами ViewResolver
- Обрабатывает возникающие исключения

![[../../../_res/Pasted image 20241002134814.png]]

[[../../../_inforage/Spring/DispatcherServlet]]

> 3.  Какой жизненный цикл у запроса?

1. Запрос приходит в DispatcherServlet
2. DispatcherServlet отправляет запрос на один из контроллеров, основываясь на URL из запроса
3. Контроллер обрабатывает запрос, делегирует выполнение бизнес-логике бизнес-слою (как правило это классы с аннотацией `@Service`), и создает модель с данными, которую и отправляет обратно в DispatcherServlet
4. DispatcherServlet отправляет модель на фронт для вью, основываясь на интерфейсе ViewResolver(подробнее об этом ниже)

> 4. Как происходит создание DispatcherServlet’а?

DS создается перед созданием ApplicationContext’а.  
Начиная со Spring 3.2 используется реализация интерфейса WebApplicationInitializer под названием AbstractAnnotationConfigDispatcherServletInitialize.

AbstractAnnotationConfigDispatcherServletInitializer создает и DispatcherServlet и ContextLoaderListener.

Настроить DS можно двумя способами:

- Определив специальные свойства в web.xml
- Переопределив AbstractAnnotationConfigDispatcherServletInitializer

> 5. Что такое WebApplicationContext? Какие дополнительные скоупы он привносит?

Это специальный контекст для веб-приложения.  
У него есть все возможности обычного ApplicationConext(т.к. он наследуется от него), но у него также есть методы для стандартного Servlet API.

| Scope         | Описание                                                                |
| ------------- | ----------------------------------------------------------------------- |
| `Request`     | Область видимости — 1 HTTP запрос. На каждый запрос создается новый бин |
| `Session`     | Область видимости — 1 сессия. На каждую сессию создается новый бин      |
| `Application` | Область видимости — жизненный цикл ServletContext                       |
| `WebSocket`   | Область видимости — жизненный цикл WebSocket                            |
> 6. Зачем нужен session scope?

Session scoped bean это бин который существует пока существует сессия. Он может использоваться при создании корзины в интернет-магазине, и т.п.

> 7. Какая область видимости в MVC используется по умолчанию?

Также как в Spring без MVC — singleton.

> 8. Зачем используется аннотация @Controller?

Аннотация [Controller](https://habr.com/ru/users/controller/) используется для регистрации обработчиков http-запросов. Это class-level аннотация, которая содержит аннотацию [Component](https://habr.com/ru/users/component/). Класс-контроллер выглядит как обычный POJO, с методами-обработчиками и аннотациями.

> 9. Как входящие запросы сопоставляются с методами-обработчиками?

1. DispatcherServlet получает запрос
2. DS содержит список классов, реализующих интерфейс `HandlerMapping`
3. Находит там метод обработчик и отправляет запрос к нему в класс-контроллер
4. Метод-обработчик выполняет запрос

> 10. Какие параметры могут принимать методы-обработчики?

Методы в классе-контроллере могут использовать некоторые типы объектов в качестве принимаемых аргументов. Тогда Spring автоматически внедрит их. Например, нужный объект HttpSession, Security, и т.п.

```java
@GetMapping public User getUserById(HttpSession session) {     //some logic         
	//у вас будет объект нужной сессии 
} 
```

![[../../../_res/Pasted image 20241002140547.png]]


> 11. Какие еще существуют аннотации для использования рядом с параметрами метода?

- `@MatrixVariable` — Указывает, что параметр должен быть связан с парой имя-значение из URI.
- `@RequestHeader` — Указывает, что параметр должен быть связан с заголовком веб-запроса.
- `@CookieValue` — Указывает, что параметр должен быть связан с куки. Параметр может быть объявлен как тип [Cookie](https://docs.oracle.com/javaee/7/api/javax/servlet/http/Cookie.html?is-external=true) или как тип значения cookie (String, int и т.д.).
- `@ModelAttribute` — Указывает, что параметр связан с именованным атрибутом модели, доступным для view.
- `@SessionAtribute` — Указывает, что параметр связан с атрибутом из сессии.

> 12. Что может возвращать метод контроллера?

![[../../../_res/Pasted image 20241002140737.png]]

> 13. Что такое View?

View используется для отображения данных приложения пользователю. Spring MVC поддерживает несколько поставщиков View(они называются шаблонизаторы) — JSP, JSF, Thymeleaf, и т.п.  
Интерфейс View преобразует объекты в обычные сервлеты.

> 14. Как выбирается View в фазе рендеринга? Как отображается View?

DispatcherServlet содержит список специальных "отображателей" для view, которые основываясь на конфигурации сервлета будут содержать бины реализующие интерфейс [ViewResolver](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/servlet/ViewResolver.html).

Процесс отображения view:

1. Контроллер возвращает имя view в DispactherServlet
2. Имя сопоставляется с именами во `ViewResolver`
3. Если находится подходящий `ViewResolver`, он возвращает View который должен использоваться при рендеринге.
4. DS передает модель с данными во View и отображает вывод(html-страницу)

> 15. Что такое Model?

Это объект класса который реализует интерфейс Model и представляет коллекцию пар ключ-значение.  Содержимое модели используется для отображения данных во View.  

Например, если View выводит информацию об объекте `Customer`, то она может ссылаться к ключам модели, например `customerName`, `customerPhone`, и получать значения для этих ключей.  Объекты-значения из модели также могут содержать бизнес-логику.

16. Какие Content-Type используются (например, при отправке формы)?

- JSON (application/json): передача данных в формате JSON.
- XML (application/xml): для передачи данных в формате XML.
- URL-encoded (application/x-www-form-urlencoded): для отправки данных простой формы.
- Multipart (multipart/form-data): для отправки данных формы с файлами.
- Text (text/plain): для передачи простого текста.

17. В чем отличие Repository, Service, Component

**`@Repository`** добавляет автоматическую обработку исключений, связанных с базой данных, **`@Service`** — это чисто для обозначения бизнес-логики, а **`@Component`** — базовая аннотация для общего назначения.

#### Что представляет из себя Spring MVC

- Model View Controller

![[../../../_res/Pasted image 20240926141242.png]]

###### @Controller vs @RestController

- Если мы хотим серилизовать какой-то объект в примеру json, то мы также должны использовать @ResponseBody в методе
- @RestController - уже имеет @ResponseBody


#### Как Spring и Spring Boot поддерживают реактивное программирование? Что такое WebFlux?

#### Разницу между статусами 200 vs 204

- 200 OK — Успешный запрос + есть тело ответа.
- 204 No Content — Успех, но тело пустое (например, после DELETE).


#### 301 vs 302 vs 307 vs 308
    
- 301 Moved Permanently — Ресурс навсегда перемещен.
- 302 Found — Временный редирект (старое поведение: меняет метод на GET).
- 307 Temporary Redirect — Временный редирект (сохраняет метод).
- 308 Permanent Redirect — Постоянный редирект (сохраняет метод).

#### Какие http статус группы знаешь?

1. 1xx (100-199): Информационные коды. Указывают на промежуточный статус обработки запроса.  
    - 100 Continue — Сервер готов принять тело запроса.
    - 102 Processing — Запрос в обработке (используется для длительных операций).
2. 2xx (200-299): Успешные коды. Запрос выполнен корректно.  
    - 200 OK — Стандартный код успешного ответа.
    - 201 Created — Ресурс успешно создан (например, после POST).
    - 204 No Content — Сервер выполнил запрос, но тело ответа пустое.
3. 3xx (300-399): Коды перенаправления. Требуют дополнительных действий от клиента.  
    - 301 Moved Permanently — Ресурс permanently перемещен.
    - 302 Found — Временное перенаправление.
    - 304 Not Modified — Контент не изменился (кеширование).
4. 4xx (400-499): Ошибки клиента. Запрос некорректен или не может быть выполнен.  
    - 400 Bad Request — Невалидный синтаксис запроса.
    - 401 Unauthorized — Требуется аутентификация.
    - 403 Forbidden — Доступ запрещен (нет прав).
    - 404 Not Found — Ресурс не существует.
5. 5xx (500-599): Ошибки сервера. Запрос валиден, но сервер не может его обработать.  
    - 500 Internal Server Error — Общая ошибка сервера.
    - 502 Bad Gateway — Прокси-сервер получил невалидный ответ.
    - 503 Service Unavailable — Сервис временно недоступен.
