#### Что такое АОП?

Аспектно-ориентированное программирование (АОП) — это парадигма программирования являющейся дальнейшим развитием процедурного и объектно-ориентированного программирования (ООП). Идея АОП заключается в выделении так называемой сквозной функциональности.

AOP — это парадигма программирования для разделения сквозной функциональности (cross-cutting concerns) от бизнес-логики. Аналогично DI (Dependency Injection), которая разделяет зависимости между объектами, AOP отделяет общие аспекты (логирование, безопасность) от основного кода.

#### Проблемы, решаемые AOP

1. Дублирование кода: Одна функциональность (например, логирование) повторяется в разных классах.
2. Сложность поддержки: Изменения в сквозной функциональности требуют правок во многих местах.
3. Загромождение бизнес-логики: Код смешивается с техническими деталями (транзакции, безопасность).

```java
// Без AOP
public class PaymentService {
    public void processPayment() {
        log.info("Начало обработки платежа"); // Дублирование
        // Бизнес-логика
        log.info("Платеж обработан"); // Дублирование
    }
}
```


#### Что такое сквозная функциональность (Cross-Cutting Concerns)

Общая функциональность, распределенная по разным модулям приложения:

1. Логирование
2. Безопасность (аутентификация, авторизация)
3. Транзакции
4. Кеширование
5. Обработка ошибок

Проблема без AOP:

- Код становится спагетти (логика перемешана со служебными функциями).
- Сложно тестировать и масштабировать.
#### Что такое Join point?

это точки наблюдения, присоединения к коду, где планируется введение функциональности. Какой-то метод, на который может быть применен аспект. Место на котором происходит срез и перехват для встройки функционала

```java
package by.bob.service;

class MyServiceUtil {

	void toDoSometing() {
		System.out.println("todo")
	}
}
```
#### Что такое Pointcut

Pointcut — это срез, запрос точек присоединения, — это может быть одна и более точек. Условие выборки.

Pointcut — это выражение, которое определяет, какие join points должны быть перехвачены аспектом. Например, можно указать, что аспект должен работать только для методов определённого класса или для методов с конкретной аннотацией. В Spring это часто делается с использованием аннотаций, таких как `@Pointcut`.

```java
@Pointcut("execution(* by.bob.service.*.*(..))") public void serviceMethods() { }
```

#### Что такое Advice?

Advice — набор инструкций выполняемых на точках среза (Pointcut). Инструкции можно выполнять по событию разных типов:  
  
| **Тип**               | **Описание**                                 | **Использование**              |
| --------------------- | -------------------------------------------- | ------------------------------ |
| **`@Before`**         | Выполняется **до** метода.                   | Валидация, безопасность.       |
| **`@After`**          | Выполняется **после** метода (успех/ошибка). | Очистка ресурсов.              |
| **`@AfterReturning`** | Только после **успешного** выполнения.       | Логирование результата.        |
| **`@AfterThrowing`**  | Только при **исключении**.                   | Обработка ошибок, нотификации. |
| **`@Around`**         | Обертка **вокруг** метода (полный контроль). | Транзакции, замер времени.     |
  
на один Pointcut можно «повесить» несколько Advice разного типа.

Advice — это код, который выполняется в определённой точке (join point) программы. Advice определяет, что должно быть сделано, когда срабатывает pointcut. 

```java
@Before("serviceMethods()") 
public void logBefore(JoinPoint joinPoint) {
	System.out.println("Перед вызовом: " + joinPoint.getSignature().getName()); 
}

@AfterReturning("serviceMethods()") 
public void logAfter(JoinPoint joinPoint) { 
	System.out.println("После успешного вызова: " + joinPoint.getSignature().getName()); 
}

@AfterThrowing("serviceMethods()") 
public void logException(JoinPoint joinPoint) { 
	System.out.println("Ошибка в методе: " + joinPoint.getSignature().getName()); 
}

@Around("serviceMethods()") 
public Object measureTime(ProceedingJoinPoint pjp) throws Throwable { 
	long start = System.currentTimeMillis(); Object result = pjp.proceed();
	System.out.println("Время выполнения: " + (System.currentTimeMillis() - start) + "ms"); 
	return result; 
}
```

#### Аргументы Advice

- **`JoinPoint`:**  
Доступен в `@Before`, `@After`, `@AfterReturning`, `@AfterThrowing`.  
Содержит информацию о методе: имя, аргументы, сигнатуру.

```java
@Before("execution(* Service.*(..))")
public void log(JoinPoint jp) {
    System.out.println("Вызов метода: " + jp.getSignature().getName());
}
```

- **`ProceedingJoinPoint`:**  
    Только для `@Around`. Позволяет вызвать целевой метод через `proceed()`.

#### Библиотеки AOP

1. AspectJ:
    - Полнофункциональная (compile-time/load-time weaving).
    - Поддерживает все типы Join Points.
2. Spring AOP:
    - Простая интеграция с Spring.
    - Ограничена прокси-подходом.
3. JBoss AOP:
    - Устаревшая (не рекомендуется).

#### Типы Weaving

1. Compile-time: Аспекты встраиваются в байт-код при компиляции (AspectJ).
2. Load-time: Аспекты применяются при загрузке классов в JVM (требует `-javaagent`).
3. Runtime: Динамические прокси (Spring AOP).
#### Что такое  Aspect

Сейчас приведу пример и окончательно все встанет (или почти все) на свои места. Все знаем про логирование кода который пронизывает многие модули, не имея отношения к бизнес коду, но тем не менее без него нельзя. И так отделяю этот функционал от бизнес кода.
Это модули, которые содержат функциональность, которая применяется к различным частям программы.

```java
@Aspect 
@Component 
public class LoggingAspect { }
```

#### Реализация AOP в Spring

Spring использует динамические прокси для внедрения аспектов:

1. Создает прокси-объект, оборачивающий целевой бин.
2. Перехватывает вызовы методов и применяет Advice.
3. Типы прокси:
    - JDK Dynamic Proxy — для бинов, реализующих интерфейсы.
    - CGLIB Proxy — для бинов без интерфейсов (наследуется от класса).

```java
Клиент → Прокси → Advice → Целевой метод
```


#### Ограничения прокси в Spring AOP

| Тип прокси        | Ограничения                                                                                                           |
| ----------------- | --------------------------------------------------------------------------------------------------------------------- |
| JDK Dynamic Proxy | - Только публичные методы.  <br>- Требует интерфейса.  <br>- Не проксирует внутренние вызовы (`this.method()`).       |
| CGLIB             | - Не работает для `final` классов/методов.  <br>- Только публичные/защищенные методы.  <br>- Медленнее инициализация. |

- Spring AOP не применяется к вызовам внутри бина (например, `this.internalCall()`).
- Для полного контроля используйте AspectJ (поддержка приватных методов, конструкторов).


### Resources

- [Три типа аспектов на примере AspectJ](https://www.youtube.com/watch?v=S-LrdkfDSCU)
- [Spring Boot, AspectJ.](https://vaiti.io/spring-boot-aspectj-vvedenie-v-aspektno-orientirovannoe-programmirovanie/)
- 