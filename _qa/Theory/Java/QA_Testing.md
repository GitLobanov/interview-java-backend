#### Зачем нужно тестирование? [X]

Тестирование нужно, чтобы находить ошибки до релиза, проверять соответствие требованиям, улучшать качество и безопасность, оптимизировать производительность и снижать риски. Это экономит время и деньги, предотвращая проблемы у пользователей. Без тестирования выпуск ПО — лотерея с непредсказуемыми последствиями.

Оптимизация производительности. Нагрузочное и стресс-тестирование помогают проверить, как система ведет себя под высокой нагрузкой (например, при большом числе пользователей).

Поддержка регрессионных изменений При внесении новых функций или исправлений тестирование проверяет, не сломали ли изменения уже работающую функциональность.

#### Что такое junit ? [X]

JUnit — это фреймворк для модульного тестирования (unit-тестов) Java-приложений. Он позволяет автоматизировать проверку работы отдельных классов и методов.

- Аннотации (`@Test`, `@BeforeEach`, `@AfterAll` и др.) для управления тестами.
- Assertions (утверждения) для проверки ожидаемых результатов (`assertEquals`, `assertTrue` и т.д.).
- Параметризованные тесты (запуск одного теста с разными входными данными).
- Интеграция с инструментами сборки (Maven, Gradle) и CI/CD (Jenkins).

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class CalculatorTest {
    @Test
    void testAdd() {
        Calculator calc = new Calculator();
        assertEquals(5, calc.add(2, 3)); // Проверка: 2 + 3 = 5
    }
}
```

#### Как протестировать объект, который имеет соединение к БД ? [X]

- h2

```java
@DataJpaTest
@ActiveProfiles("test")
public class UserRepositoryTest {

    @Autowired
    private UserRepository userRepository;

    @Test
    void saveUser_ShouldReturnSavedUser() {
        User user = new User("John");
        User savedUser = userRepository.save(user);
        assertNotNull(savedUser.getId());
    }
}
```

- Testcontainers

```java
@Testcontainers
@SpringBootTest
public class UserServiceIntegrationTest {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15");

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }

    @Autowired
    private UserService userService;

    @Test
    void getUser_ShouldReturnUserFromRealDb() {
        User user = userService.findUserById(1L);
        assertNotNull(user);
    }
}
```

- Mockito для мокирования репозиториев/сервисов

#### Для чего использовать моки ? [X]

Моки (Mock-объекты) используются в тестировании для изоляции тестируемого кода от зависимостей (например, БД, внешних API, сервисов), чтобы:

- Моки не выполняют реальные запросы к БД или API, поэтому тесты работают мгновенно.
- Проверяем только логику класса, без влияния внешних систем.
- Можем замокать сервис, который находится в разработке, чтобы не ждать его готовности.

- Mockito – стандарт для Java (простота + мощь).
- WireMock – мокирование HTTP-запросов.
- MockK – для Kotlin.

#### Должны ли мы писать тесты к private методам ? [X]

Нет, не стоит писать тесты к private-методам. Они являются деталями реализации, и их следует проверять через публичные методы. Тестирование приватных методов нарушает инкапсуляцию, усложняет рефакторинг и увеличивает связанность кода. Исключение — сложная логика в private-методах, которую трудно проверить через публичный интерфейс. В таком случае лучше вынести её в отдельный класс. Основная цель тестов — проверка публичного поведения, а не внутренней реализации. Если private-метод критически важен, его тестирование может быть оправдано, но это скорее крайний случай, чем правило.

#### Что такое testcontainers и как с помощью этой библиотеки написать интеграционные тесты ? [X]

- Поднятие реальной БД - PostgreSQL/MySQL в тестах.
- Тестирование интеграции с Redis, Kafka, S3 и другими сервисами.
- Запуск зависимостей (например, Elasticsearch) без ручной настройки.

```java
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

@Testcontainers
@SpringBootTest
class UserRepositoryIntegrationTest {

    @Container
    private static final PostgreSQLContainer<?> postgres = 
        new PostgreSQLContainer<>("postgres:15-alpine")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test");

	@Container
	static KafkaContainer kafka = new KafkaContainer(DockerImageName.parse("confluentinc/cp-kafka:7.0.0"));

    @Autowired
    private UserRepository userRepository;

    @Test
    void testSaveAndFindUser() {
        User user = new User("John");
        userRepository.save(user);

        User found = userRepository.findByName("John");
        assertEquals("John", found.getName());
    }
}
```

#### Что делает аннотация @Testcontainers ? [X]

Автоматическое управление жизненным циклом контейнеров. Позволяет JUnit 5 (Jupiter) автоматически:
- Запускать контейнеры перед выполнением тестового класса.
- Останавливать контейнеры после завершения всех тестов.

Без этой аннотации контейнеры придётся запускать/останавливать вручную через `container.start()` и `container.stop()`.

#### Что делает аннотация @Container ? [X]

Аннотация **`@Container`** в библиотеке TestContainers используется для управления Docker-контейнерами в тестах. Вот что она делает:

Помечает контейнер для автоматического управления. Указывает TestContainers, что это поле (объект контейнера) нужно:
- Запустить перед тестами.
- Остановить после завершения тестов.

Определяет режим работы контейнера. Поведение зависит от того, статическое (`static`) поле или нет:

| **Тип поля** | **Когда запускается**        | **Когда останавливается** | **Использование**                                    |
| ------------ | ---------------------------- | ------------------------- | ---------------------------------------------------- |
| `static`     | Один раз перед всеми тестами | После всех тестов         | Общие ресурсы (например, БД для всех тестов класса). |
| Не-`static`  | Перед каждым тестом          | После каждого теста       | Изолированные контейнеры для каждого теста.          |
Без этой аннотации контейнер не запустится автоматически.

#### Как тестировать приложения в Spring/Spring Boot ? [X]

Unit-тесты (Модульные тесты). Проверить отдельные классы (сервисы, утилиты) в изоляции от зависимостей (БД, HTTP-запросов и т.д.).
- JUnit 5 – основа для тестов.
- Mockito – для мокирования зависимостей.

```java

import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

@ExtendWith(MockitoExtension.class)
public class UserServiceTest {

    @Mock
    private UserRepository userRepository;

    @InjectMocks
    private UserService userService;

    @Test
    void getUserById_ShouldReturnUser() {
        when(userRepository.findById(1L)).thenReturn(new User(1L, "Alice"));
        User user = userService.getUserById(1L);
        assertEquals("Alice", user.getName());
        verify(userRepository, times(1)).findById(1L);
    }
}
```

Интеграционные тесты. Проверить взаимодействие компонентов (например, Spring-бинов, JPA-репозиториев, REST-контроллеров) с реальными или тестовыми БД и сервисами.

- @SpringBootTest – поднимает полный контекст Spring (как в реальном приложении).
- @DataJpaTest – тестирует только JPA-репозитории (использует встроенную H2 или Testcontainers).
- @WebMvcTest – тестирует контроллеры без поднятия всего контекста.
- @Testcontainers – для запуска реальных БД (PostgreSQL, MySQL) в Docker.

#### Нужно ли поднимать весь контекст Spring приложения для тестирования отдельного сервиса ? [X]

1. Если сервис не зависит от других бинов Spring или их можно замокать (Mockito).
2. Для проверки логики работы самого сервиса (без интеграции с БД, внешними сервисами).
3. Если не нужны Spring-специфичные фичи (транзакции, AOP, кэширование).
4. Не используйте @SpringBootTest для unit-тестов — это антипаттерн.
5. Мокируйте всё, что не относится к тестируемому сервису (Mockito — ваш друг).
6. Для JPA-тестов — @DataJpaTest + TestEntityManager.
7. Полный контекст — только для интеграционных/E2E-тестов.

#### На чем пишутся тесты ? [X]

- Unit-тесты: В основном используются фреймворки JUnit для написания модульных тестов в Java.
- Интеграционные тесты: Используют Spring Test, Testcontainers для интеграционного тестирования с базами данных и внешними системами.
- Mocking: Фреймворки, такие как Mockito применяются для создания заглушек (mock-объектов) в unit-тестах.
- UI-тесты: Для тестирования интерфейсов часто используют Selenium.
- Performance тесты: Инструменты вроде JMeter.

#### Что такое модульное тестирование ? [X]

 процесс в программировании, позволяющий проверить на корректность отдельные модули исходного кода программы. Идея состоит в том, чтобы писать тесты для каждой нетривиальной функции или метода.

- тесты состояния (state based), проверяющие что вызываемый метод объекта отработал корректно, проверяя состояние тестируемого объекта после вызова метода.
- тесты взаимодействия (interaction tests), в которых тестируемый объект производит манипуляции с другими объектами. Применяются, когда требуется удостовериться, что тестируемый объект корректно взаимодействует с другими объектами.

#### Что такое «интеграционное тестирование» ? [X]

тестирование, проверяющие работоспособность двух или более модулей системы в совокупности — то есть нескольких объектов как единого блока. В тестах взаимодействия же тестируется конкретный, определенный объект и то, как именно он взаимодействует с внешними зависимостями.

#### Примеры интеграционных тестов [X]

- Проверить взаимодействие между контроллером, сервисом и БД.
- Убедиться, что репозиторий корректно сохраняет/извлекает данные.
- Проверить бизнес-логику с поднятым контекстом Spring. (Отдельного сервиса при запущенном контексте)
- Проверить @Cachable, @Transactional

#### Чем интеграционное тестирование отличается от модульного ? [X]

| **Критерий**            | **Unit-тесты**            | **Интеграционные тесты**                |
| ----------------------- | ------------------------- | --------------------------------------- |
| **Что тестируют?**      | Отдельные методы, классы  | Взаимодействие компонентов              |
| **Зависимости?**        | Заменяются mock-объектами | Используются реальные сервисы (БД, API) |
| **Скорость выполнения** | 🟢 Быстро (миллисекунды)  | 🔴 Медленно (секунды и больше)          |
| **Пример**              | `Calculator.add(2, 3)`    | `UserService` работает с `Database`     |
#### Какие существуют виды тестовых объектов ? [X]

пустышка (dummy) - объект, который обычно передается в тестируемый класс в качестве параметра, но не имеет поведения: с ним ничего не происходит и никакие его методы не вызываются.

> Примером dummy-объектов являются new object(), null, «Ignored String» и т.д.

фальшивка (fake object) применяется в основном для ускорения запуска ресурсоёмких тестов и является заменой тяжеловесного внешнего зависимого объекта его легковесной реализацией.

> Основные примеры — эмулятор базы данных (fake database) или фальшивый web-сервис.

заглушка (test stub) используется для получения данных из внешней зависимости, подменяя её. При этом заглушка игнорирует все данные, поступающие из тестируемого объекта, возвращая заранее определённый результат.

> Тестируемый объект использует чтение из конфигурационного файла? Тогда передаем ему заглушку `ConfigFileStub` возвращающую тестовые строки конфигурации без обращения к файловой системе.

шпион (test spy) - разновидность заглушки, которая умеет протоколировать сделанные к ней обращения из тестируемой системы, чтобы проверить их правильность в конце теста. При этом фиксируется количество, состав и содержание параметров вызовов.

> Если существует необходимость проверки, что определённый метод тестируемого класса вызывался ровно 1 раз, то шпион - именно то, что нам нужно.

фикция (mock object) похож на шпиона, но обладает расширенной функциональностью, заранее заданными поведением и реакцией на вызовы, если реакция не переопределена, вернеться дефолтное значение

#### Какие внутренние методы, аннотации юнит тестов ты знаешь?

[Подробнее](../../../_inforage/Тестирование/JUnit.md)

#### Spy. Как работает ? [X]

Spy – это объект, который ведет себя как настоящий объект, но позволяет подменить поведение некоторых методов или проверить, были ли вызваны методы.

- Позволяет сохранять реальное поведение объекта, но при этом можно подменить отдельные методы или проверить, как часто методы были вызваны.
- Используется, когда вы хотите тестировать реальный объект, но в какой-то момент вам нужно изменить его поведение.

- Spy сохраняет реальные данные и действия объекта, но при этом позволяет переопределять отдельные методы.
- В отличие от Mock, где вы полностью контролируете и ответственны за поведение, Spy позволяет тестировать и фактическую логику, и при этом подменять метод, если это необходимо.

#### Каким образом проверяются результаты тестов ? [X]

✅ 1. Проверка значений (Assertions)
📌 Используется `assertEquals`, `assertTrue`, `assertFalse` и др.

```java
assertEquals(5, calculator.add(2, 3)); // Проверка, что результат 5
assertTrue(user.isActive()); // Проверка, что юзер активен
```

✅ 2. Проверка вызовов Mock (Mockito)
📌 Проверяем, вызывался ли метод и сколько раз.

```java
verify(mockRepo, times(1)).findNameById(1);
```

✔ Убедимся, что метод `findNameById(1)` был вызван **ровно 1 раз**.

✅ 3. Проверка исключений
📌 Проверяем, выбросил ли метод нужное исключение.

```java
assertThrows(IllegalArgumentException.class, () -> service.findUser(-1));
```

✔ Проверяем, что при передаче `-1` выбрасывается `IllegalArgumentException`.

#### Приведи дубликатов тестов [X]

- Stubs - предоставляют готовые ответы на вызовы, сделанные во время теста. Используется для тестирования состояния (мокаем репозиторий, чтобы они имитировал работы базы, а возвращаемые результаты как-то используем для тестов)  
- Spy - вид стаба, который оборачивает настоящий объект  
- Mock - вид стаба, методы которого изначально пустые. Мы должны вручную определить то, что они будут возвращать. Используется для тестирования поведения (проверить был ли вызван метод)
- Dummy - объекты передаются, но никогда не используются. Используются только для заполнения списка параметров  

```java
User dummyUser = new User("John", 25);  // Этот объект будет просто передан, но не использован
userService.addUser(dummyUser);  // Вызов метода с "dummy" объектами
verify(dummyRepository).save(dummyUser); // Проверка, что метод был вызван (но объекты не использованы)
```

- Fake - объекты имеют рабочую реализацию, но обычно непригодны для производства. Пример - InMemory база данных H2

#### Mock vs Spy [X]

- stub используется как заглушка сервисов, методов, классов и т.д. с заранее запрограммированным ответом на вызовы.
- mock использует подмену результатов вызова, проверяет сам факт взаимодействия, протоколирует и контролирует его.

|**Критерий**|**Mock**|**Spy**|
|---|---|---|
|**Описание**|Полностью имитирует поведение объекта. Вы задаёте ожидаемые ответы на вызовы методов.|Реальный объект, но с возможностью “шпионить” за вызовами методов.|
|**Подход**|Заменяет объект, тестируется только взаимодействие (behavior verification).|Используется реальный объект, но вы можете подменять результаты вызовов его методов.|
|**Когда использовать**|Когда необходимо полностью изолировать тестируемый объект от зависимости.|Когда хотите протестировать реальный объект, но также отследить вызовы его методов.|
|**Пример использования**|Проверка взаимодействия с внешней зависимостью, например, базой данных.|Проверка поведения конкретного метода объекта, оставаясь близко к реальной логике.|
|**Типы подмен**|Вы задаёте возвращаемые значения для всех методов объекта.|Реальные методы объекта выполняются, если не настроена их подмена.|

#### Какие аннотации порядка выполнения существуют в JUnit ? [X]

- `@BeforeClass` - определяет код, который должен единожды выполниться перед запуском набора тестовых методов.
- `@AfterClass` - код, выполняемый один раз после исполнения набора тестовых методов.
- `@Before` - определяет код, который должен выполняться каждый раз перед запуском любого тестового метода.
- `@After` - код, выполняемый каждый раз после исполнения любого тестового метода.

#### Для чего в JUnit используется аннотация `@Ignore`?

`@Ignore` указывает JUnit на необходимость пропустить данный тестовый метод.

#### Как расшифруешь абревиатуру F.I.R.S.T [X]

1. Fast - юнит тесты должны быть быстрыми, так как они часто запускаются и их много  
2. Isolated - они должны быть изолированы друг от друга и не использовать общее состояние. Это может сломать тесты при изменении порядка их выполнения.  
3. Repeatable - результат должен быть один и тот же, сколько бы раз он ни был запущен  
4. Self-validated - должно быть очевидно, что тест прошел, либо же зафейлился. Не должно быть промежуточных состояний, которые нужно проверять вручную, чтобы убедиться в успешности теста  
5. Timely - тесты должны писаться и выполняться вовремя

#### Как работают параметризированные тесты [X]

Параметризированные тесты позволяют запускать один и тот же тестовый метод с разными входными данными. Это избавляет от дублирования кода и упрощает проверку множества сценариев.

Для параметризированных тестов в JUnit 5 используются:
- `@ParameterizedTest` — заменяет `@Test`, указывает, что тест параметризированный.
- `@MethodSource`, `@CsvSource`, `@ValueSource` и др. — задают источники данных.

```java
@ParameterizedTest
@ValueSource(ints = {1, 2, 3, 4, 5})
void testWithParameters(int number) {
    assertTrue(number > 0);
}
```

#### Типы параметризованных тестов в JUnit 5

| **Аннотация**    | **Описание**                                            |
| ---------------- | ------------------------------------------------------- |
| `@ValueSource`   | Передаёт фиксированные наборы данных (массив значений). |
| `@CsvSource`     | Передаёт данные в формате CSV.                          |
| `@CsvFileSource` | Загружает данные из файла CSV.                          |
| `@MethodSource`  | Использует метод для предоставления набора данных.      |
| `@EnumSource`    | Передаёт значения перечислений (enums).                 |
| @ArgumenSource   |                                                         |
#### В чем плюсы и минусы использования ин мемори и тестконтейнеров [X]

In-Memory (H2, SQLite)

Плюсы:
- Быстрые - не требуют Docker или внешних сервисов
- Простая настройка - встроены в Spring Boot
- Хороши для unit-тестов - проверка логики без зависимостей
Минусы:
- Не совместимы на 100% с продакшен-БД (PostgreSQL, MySQL)
- Ложные срабатывания - тест может пройти на H2, но упасть на реальной БД
- Ограниченная функциональность - нет специфичных фич (например, ON CONFLICT DO UPDATE в Postgres)
    
Testcontainers (PostgreSQL, MySQL в Docker)

Плюсы:
- Полная совместимость - тестируетесь на реальной БД, как в продакшене
- Покрытие специфичных фич - JSON, GIS, хранимые процедуры
- Надёжность - ошибки выявляются на этапе тестов, а не в production
Минусы:
- Медленнее - требует запуска Docker-контейнеров
- Сложнее в настройке - нужен Docker и CI/CD с поддержкой контейнеров
- Хрупкость - зависят от внешних сервисов (сеть, Docker)

Когда что использовать?

- In-Memory подходит для:
    - Быстрых юнит-тестов
    - Проверки базовой логики
    - Сценариев без специфичных SQL-фич
- Testcontainers необходим для:
    - Интеграционных тестов
    - Проверки SQL-специфики
    - Тестов, где важна полная совместимость с продакшеном

#### Что такое пирамида тестирования ? [X]

Пирамида тестирования — это модель, которая показывает оптимальное соотношение разных типов тестов в проекте. Она помогает распределить усилия по тестированию: больше простых и быстрых тестов, меньше сложных и медленных.

1. Unit-тесты (основа)
    - Что тестируют: Отдельные классы/методы в изоляции.
    - Инструменты: JUnit, TestNG, Mockito.
    - Объём: ~70% всех тестов.
    - Скорость: Мгновенные (миллисекунды на тест).
    - Пример: Проверка, что метод `calculateDiscount()` корректно вычисляет скидку.
2. Интеграционные тесты
    - Что тестируют: Взаимодействие между компонентами (например, Spring-бины + БД).
    - Инструменты: `@SpringBootTest`, Testcontainers.
    - Объём: ~20% тестов.
    - Скорость: Средняя (секунды на тест).
    - Пример: Проверка, что `UserService` сохраняет данные в PostgreSQL через `UserRepository`.
3. UI/E2E-тесты (верхушка)
    - Что тестируют: Полный поток работы приложения (от интерфейса до БД).
    - Инструменты: Selenium, Cypress, Postman.
    - Объём: ~10% тестов.
    - Скорость: Медленные (минуты на тест).
    - Пример: Проверка регистрации пользователя через веб-интерфейс.
###### Как реализовать параметризованные тесты в JUnit 5?

###### Какие подходы и методологии могут быть использованы для тестирования ПО в микросервисной архитектуре?

###### Что такое TDD и для чего оно используется?

###### Можешь ли описать цикл "Красный-Зеленый-Рефактор" в контексте TDD?

###### На каком этапе нужно поднятие контекста? Для чего? Порядок запуска тестов важен? 

###### Какие есть аннотации для тестов в Spring? 

#### Что знаете о @InjectMock и @MockBean

| **Критерий**               | **`@InjectMocks`**          | **`@MockBean`**                          |
| -------------------------- | --------------------------- | ---------------------------------------- |
| **Контекст**               | Без Spring (чистый Mockito) | В Spring Context                         |
| **Где применяется**        | Unit-тесты                  | Интеграционные тесты (`@SpringBootTest`) |
| **Зависимости**            | Требует `@Mock`             | Создает мок самостоятельно               |
| **Типичное использование** | Тесты сервисов/утилит       | Тесты контроллеров, REST-эндпоинтов      |

###### Чем отличаются тесты функциональные и нефункциональные?

###### Можете пример привести, что вы там в тестах пишите? теорию я знаю, можете конкретный пример привести?

