1. Как реализовать алгоритм сортировки подсчетом на Java?  

- [[../../../_inforage/Алгоритмы/Storage/Сортировка подсчетом]]

2. Какие стратегии оптимизации могут быть применены к алгоритму быстрой сортировки?  
- [[../../../_inforage/Алгоритмы/Storage/Быстрая сортировка#Оптимизация]]

3. Опишите процесс реализации алгоритма поиска в глубину на графе.

- [[../../../_inforage/Алгоритмы/Storage/Depth-First Search, DFS#1. Поиск в графах]]

101. Как можно оценить пространственную сложность алгоритма?  

- [[../../../_inforage/Алгоритмы/Storage/Пространственная сложность алгоритма]]

102. Каковы основные различия между сложностью О(n log n) и О(n^2)? Приведите примеры алгоритмов.  

Основные различия между сложностью **O(n log n)** и **O(n²)** — это скорость роста времени выполнения алгоритма в зависимости от размера входных данных `n`. Чем больше значение `n`, тем существеннее становится разница между ними.

Основные различия

- **Скорость роста времени выполнения:**
    - **O(n log n)**: Растет медленнее, чем O(n²). Алгоритмы с такой сложностью обычно быстрее для больших входных данных.
    - **O(n²)**: Время выполнения возрастает квадратично, т.е., при увеличении `n` затраты времени растут значительно быстрее. Это делает алгоритмы O(n²) медленными для больших `n`.

- O(n log n)

1. **Сортировка слиянием (Merge Sort):**
    - Делит массив на половины, сортирует каждую рекурсивно и затем объединяет.
    - Средняя и худшая сложность: `O(n log n)`.
2. **Быстрая сортировка (Quick Sort):**
    - Выбирает "опорный элемент", делит массив на меньшие части и сортирует каждую часть.
    - Средняя сложность: `O(n log n)`; худшая: `O(n²)` (в неудачном случае выбора опорного элемента).

- O(n²)

1. **Сортировка пузырьком (Bubble Sort):**
    - Каждый элемент сравнивается с последующим и перемещается, если он больше.
    - Средняя и худшая сложность: `O(n²)`.
2. **Сортировка вставками (Insertion Sort):**
    - Последовательно вставляет каждый элемент на нужное место в отсортированной части массива.
    - Средняя и худшая сложность: `O(n²)`.
3. **Поиск всех пар элементов (двойной цикл):**
    - Например, поиск всех пар чисел, сумма которых равна заданному значению.
    - Использует два вложенных цикла, проверяя каждую возможную пару элементов массива.
    - Сложность: `O(n²)`.

103. Как влияет структура данных на временную сложность алгоритма? Приведите пример.

Структура данных сильно влияет на временную сложность алгоритма, потому что разные структуры данных организуют данные по-разному и определяют, как быстро можно выполнять операции — например, добавление, удаление и поиск.

Пример 1: Поиск элемента

Представьте, что нужно найти элемент в массиве и в хеш-таблице:

- **Массив**: Чтобы найти нужный элемент, в худшем случае нужно пройти по всем элементам — это будет **O(n)**.
- **Хеш-таблица**: Она использует хеш-функцию для быстрого доступа к данным, поэтому поиск занимает **O(1)** (в среднем случае), независимо от размера данных.

Пример 2: Упорядочивание данных

Допустим, нужно постоянно вставлять данные в отсортированном порядке:

- **Связный список**: В связном списке вставка элемента занимает O(1), но чтобы найти место для вставки, нужно просмотреть все элементы, что займет O(n). В итоге, вставка в нужное место в связном списке будет занимать **O(n)**.
- **Сбалансированное бинарное дерево (например, AVL)**: Позволяет вставлять элементы в отсортированном порядке за **O(log n)**, так как дерево остается сбалансированным.

#### В чем разница бинарных и красно-черных деревьев?

- **BST** может быть разбалансированным, что ухудшает производительность.
- **RBT** всегда сбалансировано, обеспечивая O(log⁡n)O(\log n)O(logn) для операций вставки, удаления и поиска.
- **RBT**:
	- Каждый узел либо красный, либо черный.
	- Корень всегда черный.
	- Все пути от корня до листьев содержат одинаковое количество черных узлов.
	- Красный узел не может иметь красных детей ("правило двух красных").
	- Новые узлы всегда добавляются как красные, с последующим ребалансированием.

#### Какие алгоритмы поиска знаешь?

- **Линейный поиск** (`O(n)`) — перебор элементов.
- **Бинарный поиск** (`O(log n)`) — для отсортированных массивов.
- **Поиск в хеш-таблицах** (`O(1)` в среднем) — по ключу.
- **Поиск в деревьях**:
    - Двоичное дерево (`O(n)` в худшем случае).
    - AVL/Красно-черное дерево (`O(log n)`).
- **Поиск в графах**:
    - BFS (поиск в ширину).
    - DFS (поиск в глубину).

#### Что такое красно-черное дерево

- [[../../../_inforage/Java/Core/data structure/Красно-черное дерево|Красно-черное дерево]]

#### Что такое двоичное дерево поиска и каковы его основные свойства?

- В двоичном дереве поиска элементы расположены не в последовательной памяти, как в массиве, а в виде узлов с указателями на потомков. Поиск в BST основан на сравнении элементов с текущим узлом и переходе влево или вправо.
- Двоичное дерево поиска полезно, когда ты часто выполняешь вставку, удаление и поиск по значению. Оно поддерживает порядок элементов и позволяет находить их за **O(log n)** (если дерево сбалансировано), иначе за O(n).

#### Опишите принцип алгоритма сортировки пузырьком?

- [[../../../_inforage/Алгоритмы/Storage/Пузырьковая сортировка]]

#### Объясните, как работает линейный поиск.

Линейный поиск — это алгоритм поиска элемента в списке или массиве, при котором каждый элемент проверяется последовательно, начиная с первого, пока не будет найден нужный или не завершится перебор всех элементов. O(n).

#### Какова основная идея бинарного поиска?

- В любой момент мы рассматриваем только подмассив, т.е. часть массива между индексами (включительно);
- Уменьшение диапазона поиска вдвое на каждой итерации;
- Сложность O(log n);
- Требует, чтобы массив или список был отсортирован;
- Меньше итераций — меньше затрат на вычисления.

#### Что такое О-нотация?

- Математический способ описания предельной сложности алгоритмов, который позволяет оценивать, как время выполнения или потребление памяти алгоритма зависит от размера входных данных;

- O(1): Константное время (независимо от n).
- O(log n): Логарифмическое время (например, бинарный поиск).
- O(n): Линейное время (поиск в массиве).
- O(n log n): Линейно-логарифмическое время (например, алгоритмы сортировки, такие как быстрая сортировка).
- O(n²): Квадратичное время (например, сортировка пузырьком).
- O(2^n): Экспоненциальное время (например, некоторые алгоритмы перебора).

- Помогает разработчикам и исследователям сравнивать эффективность различных алгоритмов и выбирать наиболее подходящий для конкретной задачи.

#### Какова временная сложность алгоритма линейного поиска в худшем случае?

- Временная сложность алгоритма **линейного поиска** в худшем случае составляет **O(n)**, где **n** — это количество элементов в массиве или списке.

#### Приведите пример временной сложности алгоритма, которая является линейной.

- Метод: `List.contains()`
- Метод: `Stream.sum()`
- Метод: `Set.add()`

64. Как реализуется алгоритм поиска в глубину на графе и для каких задач он обычно используется?
- [[../../../_inforage/Алгоритмы/Storage/Depth-First Search, DFS]]
97. Объясните, как работает алгоритм двоичного поиска и в каких условиях он наиболее эффективен.
- [[../../../_inforage/Алгоритмы/Storage/Binary search]]
98. Какова асимптотическая сложность алгоритма сортировки вставками? 
- [[../../../_inforage/Алгоритмы/Storage/Асимптотическая сложность]]
- [[../../../_inforage/Алгоритмы/Storage/Сортировка методом вставки#Асимптотическая сложность]]
99. Опишите принцип алгоритма сортировки слиянием.
- [[../../../_inforage/Алгоритмы/Storage/Сортировка слиянием]]
100.  В чем преимущество алгоритма быстрой сортировки по сравнению с другими алгоритмами сортировки?
- [[../../../_inforage/Алгоритмы/Storage/Быстрая сортировка#Преимущества быстрой сортировки]]
101. Как изменится временная сложность алгоритма сортировки массива, если количество элементов в массиве удвоится?
- Для алгоритмов с квадратичной сложностью $(O(n^2))$ время выполнения увеличится примерно в 4 раза при удвоении количества элементов;
- Для алгоритмов с линейно-логарифмической сложностью $(O(n log n))$ время выполнения увеличится немного больше, чем в 2 раза (так как log(2n) = log n + log 2);
- Для алгоритмов с линейной сложностью (O(n)) время выполнения увеличится в 2 раза.
102. Что такое амортизационный анализ временной сложности алгоритма?
- [[../../../_inforage/Алгоритмы/Storage/Амортизационный анализ]]
#### Чем отличается временная сложность в худшем случае от средней временной сложности?

- **Худший случай** — оценивает максимальное время на самом сложном входе.
- **Средний случай** — оценивает время на случайных входах, что дает более реалистичную картину производительности.

#### Опишите, как реализуется и используется алгоритм Дейкстры для поиска кратчайшего пути на взвешенном графе.  
- [[../../../_inforage/Алгоритмы/Storage/Алгоритм Дейкстры]]

#### Какие существуют методы балансировки двоичных деревьев поиска и в чем заключается их необходимость?

- [[../../../_inforage/Алгоритмы/Storage/Двоичное дерево поиска#Балансировка]]