### Java

#### Что такое Java?

#### Что появлялось нового в версиях Java?

[Java Versions](../../../../_inforage/Java/Core/Java%20Versions.md)

### ООП

#### Что такое ООП? [X]

Это подход к написанию программ, при котором **структура строится вокруг объектов** — элементов, которые обладают свойствами и могут выполнять действия.

Пример использования ООП — создание программы для управления библиотекой. Вместо того чтобы писать множество функций для работы с книгами, читателями и транзакциями, в ООП можно создать классы «Книга», «Читатель» и «Транзакция», которые будут содержать данные и методы для работы с ними.
#### Принципы ООП [X]

- Инкапсуляция – это принцип скрытия внутренней реализации объекта и предоставления интерфейса для взаимодействия с ним. Распределять по пакетам, настраивать модификаторы доступа, инкапсулировать реализацию
- Наследование – это свойство системы, позволяющее описать новый класс на основе уже
существующего с частично или полностью заимствующейся функциональностью. 
- Полиморфизм – дает возможность использовать одинаковые контракты для объектов разных типов. Суть в полиморфном состоянии класса, свойства которого могут переопределяться, перезагружаться или содержать параметризированные типы. 
- Абстракция – это способ выделить набор общих характеристик объекта, исключая взаимодействия с реализацией напрямую

#### ООП vs Функциональное программирование vs Процедурное программирование [?]

- **ООП (Объектно-Ориентированное Программирование)** основывается на моделировании мира через объекты, которые объединяют данные и методы. Основные принципы: инкапсуляция, наследование, полиморфизм, абстракция.
- **Функциональное программирование** ориентировано на использование функций как основных строительных блоков. Принципы: неизменяемость данных, функции высшего порядка, чистые функции, лямбда-выражения.
- **Процедурное программирование** фокусируется на последовательном выполнении шагов и операции над данными. Основной акцент на действиях и изменении состояния программы.

#### SOLID [X]

- [SOLID](../../../../_inforage/Java/Рефакторинг/SOLID.md)
- Принцип единственной ответственности. Класс должен быть ответственен лишь за что-то одно. Если мы хотим поменять логику сбора метрик, мы не должны менять бизнес логику.
- Принцип открытости-закрытости. Программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для модификации.
- Принцип подстановки Барбары Лисков. Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов. 
- Принцип разделения интерфейса. Создание узкоспециализированных интерфейсов, предназначенных для конкретного клиента. Клиенты не должны зависеть от интерфейсов, которые они не используют.
- Принцип инверсии зависимостей. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

#### Назови нарушения Liskov Substitution [X]

- Заглушать контракт исключением, потому что он не нужен для наследника/реализации
- Возвращать unmodifiable вместо обычной коллекции/объекта. Может быть также следствием нарушения разделения интерфейса
- Обобщать тип объекта Child child != new Parent(); 
- Возвращать null, вместо пустой коллекции
#### Ассоциация, агрегация, композиция [X]

- Ассоциация - наследование. Класс является (is a) наследником другого класса.  
- Агрегация и композиция - Класс содержит, агрегирует, композирует (has a) внутри себя другой класс.  
- Агрегация подразумевает такой тип отношений, в которых дочерняя структура может существовать независимо от родительской. Пример: Если `Address` будет удалён, `Student` всё равно продолжит существовать.  
  
```java
    private Address address; // Агрегация: Address не зависит от Student  
  
    public Student(String name, Address address) {  
        this.name = name;  
        this.address = address;  
    }  
```
  
- Композиция подразумевает такой тип отношений, в которых дочерняя структура не может существовать отдельно от родительской. Пример: `House` (родительский класс) и `Room` (дочерний класс). `Room` не существует отдельно от `House`.  
  
```java
    private Room room;  
    public House(String roomName) {  
	    // Композиция: Room создаётся внутри House
        this.room = new Room(roomName); 
    }
```

#### Статическое и динамическое связывание [X]

- Статическое на этапе запуска кода
- Динамическое во время исполнения кода - runtime.
- * Для всех методов Java используется механизм позднего (динамического) связывания, если только метод не был объявлен как final (приватные методы являются final по умолчанию).

### Object

#### Что такое Object ?[X]

В Java определен специальный класс Object. По умолчанию он считается суперклассом всех остальных классов. Иными словами, все классы являются подклассами, производными от класса Object. 

Это означает, что переменная ссылки на объект типа Object может ссылаться на объект любого класса. Более того, переменная ссылки на объект типа Object может также ссылаться на любой массив, поскольку массивы реализованы в виде классов.
#### Какие методы есть у класса Object (перечислить все)? Что они делают? [X]

Любой класс наследуется от Object и, соответственно, наследуют его методы:
- public boolean equals(Object obj) – служит для сравнения объектов по значению;
- int hashCode() – возвращает hash-код для объекта;
- String toString() – возвращает строковое представление объекта;
- Class getClass() – возвращает класс объекта во время выполнения;
- protected Object clone() – создает и возвращает копию объекта;
- void notify() – возобновляет поток, ожидающий монитор;
- void notifyAll() – возобновляет все потоки, ожидающие монитор;
- void wait() – остановка вызвавшего метод потока до момента, пока другой поток не вызовет метод notify() или notifyAll() для этого объекта;
- void wait(long timeout) – остановка вызвавшего метод потока на определенное время или пока другой поток не вызовет метод notify() или notifyAll() для этого объекта;
- void wait(long timeout, int nanos) – остановка вызвавшего метод потока на определенное время или пока другой поток не вызовет метод notify() или notifyAll() для этого объекта;
- protected void finalize() – может вызываться сборщиком мусора в момент удаления объекта при сборке мусора.

#### Что за модификатор native, который используется в Object. [X]

- Java Native Interface (JNI) используется для вызова нативного кода и операций, которые не могут быть выполнены чисто на Java, обычно на C/C++.
- Реализация этих методов происходит в нативных библиотеках, а вызовы через JNI выполняются на уровне JVM.
- Методы, требующие взаимодействия с нативной системой. Например, методы для работы с памятью, операциями на уровне ОС, доступом к файлам и другим низкоуровневым ресурсам.
- **`public native int hashCode();`** — Метод `hashCode()` в классе `Object` реализован нативным кодом, потому что он требует оптимального доступа к памяти и процессам, специфичным для платформы.
- **`public native void wait(long timeout) throws InterruptedException;`** — Этот метод синхронизации связан с нативной реализацией ожидания потока.
#### Какие методы объекта нативные [X]

`getClass`, `hashCode()`, `wait(long timeoutMillis)`, `notify()`, `notifyAll()` и `clone()`
#### Свойства/контракт equals() [X]

- Рефлексивность: для любой ссылки на значение x, x.equals(x) вернет true;
- Симметричность: для любых ссылок на значения x и y, x.equals(y) должно вернуть true, тогда и только тогда, когда y.equals(x) возвращает true.
- Транзитивность: для любых ссылок на значения x, y и z, если x.equals(y) и y.equals(z) возвращают true, тогда и x.equals(z) вернет true;
- Непротиворечивость: для любых ссылок на значения х и у, если несколько раз вызвать х.equals(y), постоянно будет возвращаться значение true либо постоянно будет возвращаться значение false при условии, что никакая информация, используемая при сравнении объектов, не поменялась;
-  Совместимость с hashCode(): два тождественно равных объекта должны иметь одно и то же значение hashCode().

При переопределении equals() обязательно нужно переопределить метод hashCode().
Равные объекты должны возвращать одинаковые хэш коды.
#### Каким образом реализованы методы hashCode() и equals() в классе Object? [X]

- Реализация метода Object.equals() сводится к проверке на равенство двух ссылок:

```
public boolean equals(Object obj) {
	return (this == obj);
}
```

- Реализация метода Object.hashCode() описана как native, т. е. определенной не с помощью Java-кода и обычно возвращает адрес объекта в памяти: `public native int hashCode();`

#### Правила переопределения и контракт между HashCode и Equals.

1. Если `a.equals(b)` → `a.hashCode() == b.hashCode()`.
2. Если по хэш коду равны, не обязательно равны по equals

#### Контракт compareTo

- Рефлексивность: для любого ненулевого ссылочного значения `x`, `x.compareTo(x)` должно возвращать `0`.
- Анти-симметричность : для любых ненулевых ссылочных значений `x` и `y`, результат `x.compareTo(y)` имеет противоположный знак от `y.compareTo(x)`, если оба вызова возвращают ненулевые значения.
- Транзитивность: для любых ненулевых ссылочных значений `x`, `y` и `z`:
    - Если `x.compareTo(y) <= 0` и `y.compareTo(z) <= 0`, то `x.compareTo(z) <= 0`.
    - Если `x.compareTo(y) >= 0` и `y.compareTo(z) >= 0`, то `x.compareTo(z) >= 0`.
- Согласованность с `equals` : для любых ненулевых ссылочных значений `x` и `y`, если `x.compareTo(y) == 0`, то `x.equals(y)` должно возвращать `true`.
- Ненулевое значение : для любых ненулевых ссылочных значений `x` и `y`, если `x.compareTo(y)` возвращает ненулевое значение, то `x.equals(y)` должно возвращать `false`.

#### Согласованность/контракт между equals и compareTo

- Если два объекта равны по `equals`, они должны быть равны по `compareTo` (т.е., `compareTo` должен возвращать `0`).
- Если два объекта не равны по `equals`, `compareTo` должен возвращать ненулевое значение.

#### Правила переопределения метода Object.equals() [X]

- Использование оператора == для проверки, является ли аргумент ссылкой на указанный объект. Если является, возвращается true. Если сравниваемый объект == null, должно вернуться false.
- Использование оператора instanceof и вызова метода getClass() для проверки, имеет ли аргумент правильный тип. Если не имеет, возвращается false.
- Приведение аргумента к правильному типу. Поскольку эта операция следует за проверкой instanceof она гарантированно будет выполнена.
- Обход всех значимых полей класса и проверка того, что значение поля в текущем объекте и значение того же поля в проверяемом на эквивалентность аргументе соответствуют друг другу. Если проверки для всех полей прошли успешно, возвращается результат true, в противном случае – false.
- По окончанию переопределения метода equals() следует проверить: является ли порождаемое отношение эквивалентности рефлексивным, симметричным, транзитивным и непротиворечивым? Если ответ отрицательный, метод подлежит соответствующей правке.

#### Правила переопределения метода hashcode() [X]

1. Если хеш-коды разные, то и входные объекты гарантированно разные.
2. Если хеш-коды равны, то входные объекты не всегда равны.
3. При вычислении хеш-кода следует использовать те же поля, которые сравниваются в equals и которые не вычисляются на основе других значений.

#### Могут ли у разных объектов быть одинаковые hashCode()? [X]

Да, могут. Метод hashCode() не гарантирует уникальность возвращаемого значения.
Ситуация, когда у разных объектов одинаковые хеш-коды называется коллизией.
Вероятность возникновения коллизии зависит от используемого алгоритма генерации хеш-кода.

#### Почему метод clone() объявлен в классе Object, а не в интерфейсе Cloneable? [X]

Метод `clone()` был введен в язык Java в ранних версиях, до появления интерфейса `Cloneable`. Изначально `Object` предоставил метод `clone()` как часть основного класса, обеспечивая базовую поддержку клонирования для всех объектов. Интерфейс `Cloneable` был добавлен позже для пометки классов, которые поддерживают клонирование.

Метод clone() объявлен в классе Object с указанием модификатора native, чтобы обеспечить
доступ к стандартному механизму поверхностного копирования объектов. Одновременно он
объявлен и как protected, чтобы нельзя было вызвать этот метод у не переопределивших его
объектов. Непосредственно интерфейс Cloneable является маркерным (не содержит
объявлений методов) и нужен только для обозначения самого факта, что данный объект
готов к тому, чтобы быть клонированным. Вызов переопределенного метода clone() у не
Cloneable объекта вызовет выбрасывание CloneNotSupportedException. 

При вызове someObject.clone() (или super.clone()), нативная реализация Object.clone() внутри себя проверяет, реализует ли класс объекта интерфейс Cloneable. Эта проверка является встроенной частью логики Object.clone() и использует информацию о типах из JVM.

### Клонирование объектов

#### Какие способы клонирования объектов существуют в Java?
    
- Интерфейс `Cloneable`.
- Переопределение метода `clone()` в классе.
- Использование конструктора копирования.
- Сериализация и десериализация.

#### Что такое глубокое и поверхностное клонирование?

- Поверхностное клонирование (shallow copy): Копируется только ссылка на вложенные объекты. Изменения вложенных объектов через копию отражаются и в оригинале.

```java
@Override
protected Object clone() throws CloneNotSupportedException {        
	MyClass cloned = (MyClass) super.clone();
    return cloned;
}
```

- Глубокое клонирование (deep copy): Копируются все вложенные объекты. Изменения вложенных объектов через копию не отражаются в оригинале.

```java
@Override
protected Object clone() throws CloneNotSupportedException {        
	MyClass cloned = (MyClass) super.clone();
    cloned.nested = (Nested) nested.clone(); // Предполагается, что Nested также реализует Cloneable
    return cloned;
}
```
### Типы данных

#### Какие типы классов есть в Java? [X]

- Top level class (обычный класс):
	- Abstract class (абстрактный класс);
	- Final class (финализированный класс).
- Interfaces (интерфейс);
- Enum (перечисление);
- Record;
- Nested class (вложенный класс):
	- Static nested class (статический вложенный класс);
	- Member inner class (простой внутренний класс);
	- Local inner class (внутри метода класса);
	- Anonymous inner class (к примеру переопределение евента на клик).

#### Что имеет более высокий уровень абстракции – класс, абстрактный класс или интерфейс? [X]

Интерфейс.

#### Что такое «анонимные классы»? [X]

Это вложенный локальный класс без имени, который разрешено декларировать в любом
месте обрамляющего класса, разрешающем размещение выражений. Создание экземпляра
анонимного класса происходит одновременно с его объявлением. 

Анонимные классы имеют несколько ограничений:

-  использование разрешено только в одном месте программы – месте его создания;
-  применение возможно только в том случае, если после порождения экземпляра нет необходимости на него ссылаться;
- реализует лишь методы своего интерфейса или суперкласса, т. е. не может объявлять каких-либо новых методов, так как для доступа к ним нет поименованного типа.

#### Где применяются анонимные классы? [X]

- создания объекта функции (function object), например, реализация интерфейса Comparator;
- создания объекта процесса (process object), такого как экземпляры классов Thread, Runnable и подобных;
- в статическом методе генерации;
- инициализации открытого статического поля final, которое соответствует сложному перечислению типов, когда для каждого экземпляра в перечислении требуется отдельный подкласс.
#### Особенности Enum-классов [X]

- Конструктор всегда private или default.
- Могут имплементировать интерфейсы.
- Не могут наследовать класс.
- Можно переопределить toString().
- Нет public конструктора, поэтому нельзя создать экземпляр вне Enum.
- При equals() выполняется ==
- ordinal() возвращает порядок элементов.
- Может использоваться в TreeSet и TreeMap, т. к. Enum имплементирует Comparable.
- compareTo() имитирует порядок элементов, предоставляемый ordinal().
- Можно использовать в Switch Case.
- values() возвращает массив всех констант.
- Легко создать потокобезопасный singleton без double check volatile переменных.

#### Может ли enum наследоваться от другого класса или другой класс наследоваться от него и почему? [X]

Каждый enum тип в Java неявно наследуется от абстрактного класса java.lang.Enum. Поскольку Java не поддерживает множественное наследование классов, enum уже "занял" свое место в иерархии наследования и не может наследоваться от другого класса или быть родителем для другого класса (кроме неявного наследования его константами, если они определяют свои тела).

#### Чем интерфейсы отличаются от абстрактных классов? [X]

- Интерфейсы описывают поведение объектов через методы, но не содержат состояний (кроме `public static final` полей). Они могут быть реализованы любым количеством классов, независимо от их связи. Интерфейсы могут наследовать другие интерфейсы и включать как абстрактные методы, так и `default`-методы с реализацией по умолчанию. Их основная задача — выражать семантику класса и создавать структуры типов без жесткой иерархии.
- Абстрактные классы , напротив, используются для создания отношений "is-a" (класс-наследник расширяет базовый абстрактный класс). Они могут содержать как абстрактные методы, так и частичную реализацию, которую подклассы дополняют или переопределяют. Абстрактные классы подходят для ситуаций, когда нужно объединить общую логику между похожими классами, избегая повторения кода. Однако они ограничивают возможность множественного наследования, так как Java позволяет наследовать только один класс.
### Модификаторы

#### Можем ли мы сужать возвращаемый тип предка в наследнике? [X]

В наследнике можно только _сужать_ (уточнять) возвращаемый тип, но _нельзя расширять_ (делать более общим).

К примеру мы можем делать Parent parent = new Child();
Но не можем делать так: Child child = new Parent();

####  Можно ли сузить уровень доступа возвращаемого значения при переопределении метода? [X]

При переопределении метода нельзя сузить модификатор доступа к методу (например, с public до private), но можно расширить.
#### Что можно изменить в сигнатуре метода при переопределении? [X]

- При переопределении метода сужать модификатор доступа не разрешается, т. к. это приведет к нарушению принципа подстановки Барбары Лисков. Расширение уровня доступа возможно.
- Можно изменять все, что не мешает компилятору понять, какой метод родительского класса имеется в виду:
- Поэтому в сигнатуре (имя + параметры) менять ничего нельзя, но возможно расширение уровня доступа.
- Изменять тип возвращаемого значения при переопределении метода разрешено только в сторону сужения типа (вместо родительского класса-наследник).
- Секцию throws метода можно не указывать, но стоит помнить, что она остается действительной, если уже определена у метода родительского класса. Можно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения RuntimeException. Порядок следования таких элементов при переопределении значения не имеет.

#### Что означает модификатор final? К чему он может быть применим? [X]

Модификатор final может применяться к переменным, параметрам методов, полям и методам класса или самим классам.

- класс не может иметь наследников;
- метод не может быть переопределен в классах-наследниках;
- поле не может изменить свое значение после инициализации;
- параметры методов не могут изменять свое значение внутри метода;
- для локальных переменных примитивного типа это означает, что однажды присвоенное значение не может быть изменено;
- для ссылочных переменных это означает, что после присвоения объекта нельзя изменить ссылку на данный объект (ссылку изменить нельзя, но состояние объекта изменять можно).

#### Можно ли объявить метод абстрактным и статическим одновременно? [X]

Нет. В таком случае компилятор выдаст ошибку: "Illegal combination of modifiers: ‘abstract’ and
‘static’". Модификатор abstract говорит, что метод будет реализован в другом классе, а static
наоборот указывает, что этот метод будет доступен по имени класса.

### Загрузчики классов

#### Что такое загрузчик классов [X]

Под загрузчиком классов подразумевается динамическая загрузка классов из их бинарного представления в память, для дальнейшего исполнения в JVM.
#### Какие бывают загрузчики классов [X]

| Загрузчик                         | До JDK 8                      | С JDK 9+                                                                                                                |
| --------------------------------- | ----------------------------- | ----------------------------------------------------------------------------------------------------------------------- |
| Bootstrap                         | Загружал `rt.jar`, `i18n.jar` | Загружает базовые модули java.* (например, java.base, java.xml) из boot layer.                                          |
| Extension -> Platform ClassLoader | `ExtClassLoader` из `lib/ext` | Переименован в Platform ClassLoader. Загружает модули jdk.* (например, jdk.compiler, jdk.httpserver) из platform layer. |
| System/Application                | Работал только с `classpath`  | Поддерживает модули (module-info.java)                                                                                  |
#### Основные принципы загрузчиков классов [X]

1. Делегирование загрузки более высокому загрузчику (Delegation Model)
2. Иерархическая структура загрузчиков (Hierarchy Model)
3. Изоляция классов (ClassLoader Isolation)
4. Реиспользование загруженных классов (Class Reuse)
5. Ограничение видимости загруженных классов (Visibility)

#### Этап работы загрузки классов [X]

- Загрузка (loading) — поиск и импорт бинарных данных для типа по его имени, создание класса или интерфейса из этого бинарного представления.
- Связывание, линковка (linking):  
    - Верификация (verification) — проверка корректности импортируемого типа.
    - Подготовка (preparation) — выделение памяти для статических переменных класса и инициализация памяти значениями по умолчанию.
    - Разрешение (resolution) — преобразование символьных ссылок типов в прямые ссылки.
- Инициализация (initialization) — вызов Java-кода, который инициализирует переменные класса их правильными начальными значениями.

#### Как нам узнать каким лоадером загрузился класс [X]

- getClassLoader  
- если вызвать для классов из модулей java.\*, вернется null, так как платформ/bootstrap загрузчик написан на С и его представления нету в джаве

### Рефлексия и аннотации

#### Что такое рефлексия? [X]

Reflection - механизм, позволяющий программе анализировать метаданные и изменять поведение классов, методов, полей во время исполнения.
#### Что такое аннотация? [X]

Аннотация в Java — это специальная форма метаданных (данных о данных), которую можно добавлять в исходный код. Она не изменяет логику работы программы напрямую, но может использоваться компилятором, инструментами разработки или во время выполнения для генерации кода, анализа, конфигурации или других целей.

#### Какие минусы у использования рефлексии? [X]

- Нарушение инкапсуляции (когда получаем доступ к private полю);
- Исполнение методов через invoke, происходит медленнее.
#### Как защититься от рефлексии?

- Использовать модульную систему Jigsaw
- Кодировать данные
- Агенты JVM для дополнительных проверок
#### Как изменить значение private field при помощи рефлексии? [X]

```java
Field field = MyClass.class.getDeclaredField("privateField");
field.setAccessible(true);
field.set(myInstance, "new value");
```

#### Как создать аннотацию? Что нужно указать?

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface MyCustomAnnotation {
    String value() default "default value";
    int priority() default 1;
}
```

#### Какие есть ElementType у Target? [X]

- `ElementType.TYPE`: Классы, интерфейсы, перечисления.
- `ElementType.FIELD`: Поля класса.
- `ElementType.METHOD`: Методы.
- `ElementType.PARAMETER`: Параметры методов.
- `ElementType.CONSTRUCTOR`: Конструкторы.
- `ElementType.LOCAL_VARIABLE`: Локальные переменные.
- `ElementType.ANNOTATION_TYPE`: Другие аннотации.
- `ElementType.PACKAGE`: Пакеты.

#### Над чем мы не можем поставить аннотацию?

 Примитивные Типы:
    - Например, `int`, `double`, `boolean` и другие.
    - Причина: Примитивные типы не являются объектами и не могут содержать метаданные.
Литералы
    - Например, `10`, `"Hello"`, `true`.
    - Причина: Литералы являются константными значениями и не могут содержать аннотации.
Типы Возвращаемого Значения Метода:
    - Например, `String` в `public String methodName()`.
    - Причина: Аннотации не могут быть применены к типам возвращаемых значений методов.
Типы Параметров Метода:
    - Например, `String` в `public void methodName(String param)`.
    - Причина: Аннотации не могут быть применены к типам параметров методов.

#### Какие есть RetentionPolicy в Retention?  [X]

- `SOURCE` - доступна во время компиляции, не попадает в .class. Пример: @Data - нужно для генерации кода при компиляции;
- `CLASS` - доступна во время компиляции и загрузки класса. Пример: @FieldDefaults(level = AccessLevel.PRIVATE). Не видна через рефлексию, но обрабатывается Lombok'ом при работе с байт-кодом;
- `RUNTIME` - доступна во время компиляции, загрузки класса и для reflection api в runtime. @RequestMapping / @GetMapping / @PostMapping. Spring MVC использует рефлексию, чтобы найти методы, помеченные этими аннотациями, и связать их с URL-адресами.
#### Что такое @Repeatable [X]

Позволяет использовать одну и ту же аннотацию несколько раз для одного элемента.
#### Какие способы обработки аннотации знаешь? [X]

| Способ                             | Retention поддерживается | Когда используется             | Примеры                       |
| ---------------------------------- | ------------------------ | ------------------------------ | ----------------------------- |
| 1. Annotation Processing (APT)     | `SOURCE`,`CLASS`         | На этапе компиляции            | Lombok, Dagger, MapStruct     |
| 2. Рефлексия (`java.lang.reflect`) | `RUNTIME`                | Во время выполнения            | Spring, Jackson               |
| 3. ASM / Byte Buddy / Javassist    | `CLASS`,`RUNTIME`        | При работе с байт-кодом        | Lombok, Hibernate, Mockito    |
| 4. Инструменты сборки / IDE        | `SOURCE`,`CLASS`         | Для генерации кода или анализа | ErrorProne, Checker Framework |

### Garbage Collector

#### Что такое Garbage Collector? [X]

Garbage Collector это механизм автоматического управления памятью, который обнаруживает и освобождает память, занятую объектами, которые больше не используются программой
#### Виды ссылок в Java [X]

- StrongReference.  Создаем объект при помощи new. Object obj = new Object();
- SoftReference. Отказывается от объекта при отсутствии памяти.

```java
Object object = new Object();
SoftReference<Object> softRef = new SoftReference<>(object);
object = null;
```

- WeakReference. Мгновенно освобождает объект после ухода последней строгой ссылки.

```java
Object object = new Object();
WeakReference<Object> weakRef = new WeakReference<>(object);
object = null;
```

- PhantomReference имеет условие удаления аналогичное `WeakReference` — объект собирается, если на него нет сильных ссылок. Разница в том, что `PhantomReference` позволяет отслеживать факт удаления объекта через `ReferenceQueue`. При этом метод `get()` всегда возвращает `null`, так как объект уже считается недостижимым .  GC **удаляет объект** , а в `ReferenceQueue` попадает сама `PhantomReference` для нотификации.

```java
ReferenceQueue<Object> queue = new ReferenceQueue<>();
WeakReference<Object> weakRef = new WeakReference<>(new Object(), queue);

// get() всегда возвращает null
System.out.println(pr.get()); // null

// Где-то в другом потоке проверяем очередь
Reference<? extends MyObject> ref = queue.poll();
if (ref != null) {
    System.out.println("Объект собран GC");
}
```

- [Подробнее](../../../../_inforage/Java/Core/Виды%20ссылок.%20Weak,%20Soft,%20Phantom.md)
#### Какие структуры данных в Java используют несильные ссылки (weak, soft, phantom)

- java.util.WeakHashMap<K,V> [X]

```java
WeakHashMap<Object, String> map = new WeakHashMap<>();
Object key = new Object();
map.put(key, "value");

key = null; // Теперь ключ может быть удален сборщиком мусора
```

- java.lang.ref.ReferenceQueue
- ManagedConcurrentWeakHashMap (apache.tomcat)

#### Какие поколения в heap знаешь? [X]

Heap в JVM разделен на несколько поколений:

- Young Generation — ново созданные объекты, которые часто удаляются.
- Old Generation — старые объекты, которые пережили несколько сборок мусора.
- Permanent Generation (или Metaspace в Java 8+) — хранит метаданные классов.
#### Как GC понимает что объект живой [X]

- Производиться трассировка из GC roots (thread, static fields and etc.)
- Если на объект нет ссылок (он недостижим), он считается мертвым.
#### Что значит "пережить сборку мусора"? [X]

- Объект считается **"живым"** , если из корневых ссылок (локальные переменные, статические поля, активные потоки) можно достичь этого объекта по цепочке сильных ссылок.
- Если таких путей нет — объект становится **кандидатом на удаление GC** .
- Если же такая ссылка есть — объект **переживает** текущий запуск GC.

#### Какие GC roots/руты знаешь? [X]

- локальные переменные и параметры методов;
- потоки;
- статические переменные;
- ссылки из JNI;
- System class;
- объект является synchronization монитором.

- Самое простое java-приложение будет иметь корневые точки:
	- локальные переменные внутри метода main() и параметры метода main();
	- поток, который выполняет main();
	- статические переменные класса, внутри которого находится метод main().

![](../../../../_res/Pasted%20image%2020250225154230.png)
#### Какие разновидности сборщиков мусора знаешь? [X]

- `Sun Classic (JDK 1.1–1.2) - Sun JVM, далее HotSpot JVM  
В JDK 1.0–1.1 использовался Classic VM  
В JDK 1.2 появился HotSpot JVM, который стал основным  
HotSpot заменил Classic

- Serial GC (JDK 1.3) – по умолчанию в старых клиентских JVM  
Serial GC — однопоточный, существовал с JDK 1.3  
Использовался по умолчанию в клиентских JVM

- Parallel GC (JDK 1.3) – по умолчанию в JDK 5–8  
Parallel Scavenge (Parallel GC) — многопоточный, появился в JDK 1.3  
С JDK 5 стал по умолчанию в серверных JVM  
Оставался таким до JDK 8 включительно

- CMS GC (JDK 1.4, удалён в JDK 14)  
CMS (Concurrent Mark Sweep) — появился в JDK 1.4  
Устарел в JDK 9, удалён в JDK 14  
Предназначен для низких пауз при сборке мусора

- G1 GC (JDK 7) – по умолчанию в JDK 9+  
G1 (Garbage-First) — появился как экспериментальный в JDK 6, стабильный в JDK 7  
С JDK 9 стал GC по умолчанию

- Epsilon GC (JDK 11)  
Epsilon GC — "no-op" GC, не освобождает память  
Полезен для тестирования производительности или short-lived приложений  
Добавлен в JDK 11

- ZGC (JDK 11)  
Z Garbage Collector — появился в JDK 11  
Цель: масштабируемость под гигантские кучи (до нескольких терабайт)  
Подходит для низких задержек (<10 мс)

- Shenandoah GC (JDK 12)  
Shenandoah — добавлен в OpenJDK 12  
Разработан Red Hat’ом  
Аналог ZGC, тоже для низких пауз

#### Опиши стандартный алгоритм работы сборщика мусора в виртуальной машине HotSpot без поколений. [X]

1. **Mark (маркировка)**. На первом этапе GC сканирует все объекты и помечает живые (объекты, которые все еще используются). На этом шаге выполнение программы приостанавливается. Поэтому этот шаг также называется "Stop the World" .
2. **Sweep (очистка)**. На этом шаге освобождается память, занятая объектами, не отмеченными на предыдущем шаге.
3. **Compact (уплотнение)**. Объекты, пережившие очистку, перемещаются в единый  непрерывный блок памяти. Это уменьшает фрагментацию кучи и позволяет проще и быстрее размещать новые объекты.

[Подробнее](../../../../_inforage/Java/Core/guts/gc/Garbage%20Collector.md#Сборка%20мусора%20процесс)

### JVM

#### Что такое JVM? [X]

Java Virtual Machine (JVM) — это виртуальная машина, которая выполняет байт-код Java-программ. Она обеспечивает работу программ на разных платформах, то есть позволяет запускать Java-приложения на различных устройствах и операционных системах, где установлена эта программа.

#### JDK, JRE, JVM - что для чего [X]

- JDK (Java Development Kit) — набор инструментов для разработки программ на Java, включает компилятор (javac), библиотеки, JVM.
- JRE (Java Runtime Environment) — среда выполнения Java-программ, включает JVM и стандартные библиотеки.
- JVM (Java Virtual Machine) — виртуальная машина Java, которая исполняет байт-код Java-программ, обеспечивая платформонезависимость.

#### Какие области памяти знаешь?

- Heap;
- Stack;
- MetaSpace (before 8 - PermGen);
- CodeCache (JIT оптимизированный код).

#### Что такое Heap- и Stack-память в Java? [X]

- Heap (куча) используется Java Runtime для выделения памяти под объекты и классы. Создание нового объекта также происходит в куче. Она же является областью работы сборщика мусора. Любой объект, созданный в куче, имеет глобальный доступ и на него могут ссылаться из любой части приложения.
- Stack (стек) – на каждый поток отдельный стэк. Всякий раз, когда вызывается метод, в памяти стека создается новый блок (фрейм вызова метода), который содержит примитивы и ссылки на другие объекты в методе. Как только метод заканчивает работу, блок перестает использоваться, тем самым предоставляя доступ для следующего метода. Стек в Java работает по схеме LIFO (последний-зашел-первый-вышел).

#### Как формируется стек в JVM? [X]

- Каждый поток имеет свой приватный стек;
- Хранит фреймы вызова методов (локальные переменные, ссылки, операндный стек);
- Фрейм создаётся при вызове метода и удаляется после его завершения;
- Размер стека ограничен и задаётся параметрами JVM (`-Xss`).
#### Различия между Heap и Stack памятью? [X]

- куча используется всеми частями приложения, в то время как стек используется только одним потоком исполнения программы;  
- всякий раз, когда создается объект, он всегда хранится в куче, а в памяти стека содержится лишь ссылка на него, память стека содержит только локальные переменные примитивных типов и ссылки на объекты в куче;  
- объекты в куче доступны из любой точки программы, в то время как стековая память не может быть доступна для других потоков;  
- стековая память существует лишь какое-то время работы программы, а память в куче живет с самого начала до конца работы программы;  
- если память стека полностью занята, то Java Runtime бросает исключение java.lang.StackOverflowError, если заполнена память кучи, то бросается исключение java.lang.OutOfMemoryError;  
- размер памяти стека намного меньше памяти в куче (java 9+ макс: стэк - 1MB, можно задать через -Xss; heap - 1/4 системной);  
- из-за простоты распределения памяти стековая память работает намного быстрее кучи.

#### Верно ли утверждение, что примитивные типы данных всегда хранятся в стеке, а экземпляры ссылочных типов данных – в куче? [X]

Примитивное поле экземпляра класса хранится не в стеке, а в куче. Любой
объект (все, что явно или неявно создается при помощи оператора new) хранится в куче.
#### Что храниться в MetaSpace [X]

В Java 8 , `PermGen` была полностью удалена и заменена на Metaspace , который физически отделён от кучи и расположен в нативной памяти.

- Метаданные классов (Class metadata):
    - Структуры классов (имена, методы, поля, аннотации);
    - Bytecode методов;
    - Таблицу символов и другую метаинформацию.
- Использует **нативную память** (не ограничена `-Xmx`).
- Лимит задаётся флагами:
    -XX:MaxMetaspaceSize=256m  # Максимальный размер
    -XX:MetaspaceSize=64m      # Начальный размер
#### Какие есть особенности класса String? [X]

• это неизменяемый (immutable) и финализированный тип данных;
• объекты класса, те, которые создаются как строковые литералы или через метод JVM хранит в пуле строк;
• объект класса String можно получить, используя двойные кавычки;
• можно использовать оператор + для конкатенации строк;
• начиная с Java 7, строки можно использовать в конструкции switch.

#### Что такое «пул строк»? [X]

Пул строк – это набор строк, хранящийся в Heap. Начиная с Java 7 , `String Pool` был перемещён из `PermGen` в обычную кучу (heap) .

• пул строк возможен благодаря неизменяемости строк в Java и реализации идеи интернирования строк;
• если для создания строки используются ", то сначала ищется строка в пуле с таким же значением, если находится, то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка на нее;
• при использовании оператора new создается новый объект String, затем при помощи метода intern() эту строку можно поместить в пул или же получить из пула ссылку на другой объект String с таким же значением;
• пул строк является примером паттерна «Приспособленец» (Flyweight).

```
String str1 = "Hello";
String str2 = "Hello";

// str1 и str2 указывают на одну строку в пуле строк
System.out.println(str1 == str2); // true

// Создание строк с помощью оператора new
String str3 = new String("Hello");
String str4 = new String("Hello");

// str3 и str4 — разные объекты в памяти
System.out.println(str3 == str4); // false

// Использование метода intern() для интернирования строк
String str5 = str3.intern();
String str6 = str4.intern();

// После интернирования str5 и str6 ссылаются на строку в пуле
System.out.println(str5 == str6); // true

// Показать ссылки на строки в пуле
System.out.println(str1 == str5); // true
```

#### В какой области храниться StringPool? [X]

- В Java начиная с Java 7 , пул строк (`String Pool`) хранится в куче (heap) .
- Раньше, в Java 6 и ниже, он хранился в PermGen (постоянной генерации)

#### Как работает .intern()? [X]

- Проверяет, есть ли такая строка в внутренней таблице (native StringTable)
- Если есть — возвращает ссылку.
- Если нет — добавляет и возвращает ссылку.

#### Что такое дедупликация строк и зачем она нужна? [X]

Автоматическое интренирование строк, оптимизации ссылки одинаковых строк на один объект.

Процесс дедупликации: создав два объекта с помощью _new,_ мы получили два разных объекта с разными идентификационными хешами для массивов байт. Запустив сборщик мусора и подождав некоторое время (дедупликация не происходит мгновенно), мы видим, что хеши для двух объектов стали одинаковы (ссылаются на один и тот же массив).

В отличие от пула строк, который применим только для строк, интернированных командой _intern()_, или строковых литералов, но не применим для строк, созданных динамически во время жизни приложения, дедупликация строк применима для строк, созданных всеми этими способами. Дедупликация была добавлена в Garbage Collector G1.

[Why String Deduplication when we have String Pool](https://stackoverflow.com/questions/42911701/why-string-deduplication-when-we-have-string-pool)

#### Почему не рекомендуется изменять строки в цикле? Что рекомендуется использовать?

Строка – неизменяемый класс, поэтому растет потребление ресурсов при редактировании,
т. к. при каждой итерации будет создаваться новый объект строки. Рекомендуется
использовать StringBuilder.

#### Почему String неизменяемый и финализированный класс?

- Пул строк возможен только потому, что строка неизменяемая, таким образом виртуальная машина сохраняет больше свободного места в Heap, поскольку разные строковые переменные указывают на одну и ту же переменную в пуле. Если бы строка была изменяемой, то интернирование строк не было бы возможным, потому что изменение значения одной переменной отразилось бы также и на остальных переменных, ссылающихся на эту строку.
- Если строка будет изменяемой, тогда это станет серьезной угрозой безопасности приложения. Например, имя пользователя базы данных и пароль передаются строкой для получения соединения с базой данных и в программировании сокетов реквизиты хоста и порта передаются строкой. Так как строка неизменяемая, ее значение не может быть изменено, в противном случае злоумышленник может изменить значение ссылки и вызвать проблемы в безопасности приложения.
- Неизменяемость позволяет избежать синхронизации: строки безопасны для многопоточности, и один экземпляр строки может быть совместно использован различными потоками.
- Строки используются classloader, и неизменность обеспечивает правильность загрузки класса.
- Поскольку строка неизменяемая, ее hashCode() кешируется в момент создания и нет необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в HashMap, т. к. его обработка происходит быстрее.
#### Что такое пул интов? [?]

В классе-обертке Integer есть внутренний класс IntegerCache – пул (pool) целых чисел в
промежутке [-128; 127], так как это самый часто встречающийся диапазон. Он объявлен как
private static. В этом внутреннем классе кешированные объекты находятся в массиве cache[].
Кеширование выполняется при первом использовании класса-обертки. После первого
использования вместо создания нового экземпляра (кроме использования конструктора),
используются кешированные объекты, JVM берет их из пула.

#### Можно ли изменить размер пула Integer? [?]

`-Djava.lang.Integer.IntegerCache.high=1000`

#### Какие есть пулы примитивов? [X]

У всех целочисленных и char, но размеры изменять нельзя, можно только у int.

- `Integer`: значения от -128 до 127.  
- `Byte`: кешируются все значения (от -128 до 127, так как `Byte` — это 8 бит).
- `Character`: кешируются значения от 0 до 127.
- `Short`: кешируются значения от -128 до 127.
- `Boolean`: кешируются значения `true` и `false`.
#### JIT компилятор - можешь обьяснить его функции и чем он отличается от AOT компилятора.

- **JIT (Just-in-Time) компилятор** компилирует байт-код в машинный код прямо во время выполнения программы. Он может оптимизировать код в реальном времени.
- **AOT (Ahead-of-Time) компиляция** происходит до выполнения программы, когда весь код компилируется в машинный код заранее.
#### AOT компиляция происходит до рантайма?

Да, AOT компиляция происходит до выполнения программы.
#### Есть обьекты в Java - как они представлены в памяти?

- Header - Mark Word (identityHashCode, биты блокировки, флаги, возраст объекта), Klass Pointer - указатель на метаданные класса, содержит информацию о типе
- Поля экзмпляра
- Пустые байты для кратности 8 (оптимизация для CPU)
#### StringPool

String Pool — это специальная область памяти, где хранятся строки, созданные через литералы (например, "Hello"). Строки с одинаковыми значениями в пуле ссылаются на один и тот же объект.
#### Если мы не передаем компаратор как при преобразование в кчд, в мапе сортируются элементы?

```java
int cmp = System.identityHashCode(a) - System.identityHashCode(b);
```

#### Структура самого обьекта в памяти: Header обьекта - что в нем находится и для чего он?

![](../../../../_res/Pasted%20image%2020250401151612.png)

- identity_hashcode — хеш объекта, который появляется лениво. Если у объекта будет впервые вызов System.identityHashCode(obj), то этот хеш будет рассчитан и записан в заголовок объекта.  
    В других состояниях, когда за объект конкурируют различные потоки, identity_hashcode будет храниться уже не в заголовке объекта, а в мониторе объекта.
- age — количество пережитых сборок мусора. Когда age достигает числа max-tenuring-threshold,  
    объект перемещается в область хипа old generation.
- biased_lock — содержит 1, если biased locking включено для этого объекта, иначе 0.
- lock — содержит код состояние блокировки. 00 — Lightweight Locked, 01 — Unlocked or Biased, 10 — Heavyweight Locked, 11 — Marked for Garbage Collection.

![](../../../../_res/Pasted%20image%2020250401152713.png)

#### Lock in header 

- Режим Biased Locked (biased_lock = 1, lock = 01)
	- thread — в режиме biased блокировки предполагается, что объектом преимущественно владеет какой-то конкретный поток, в поле хранится id этого потока.
	- epoch содержит некоторый временной индикатор владения объектом потоком, id которого сохранено в thread
- Режим Lightweight Locked (lock = 00)
	- В этом режиме предполагается, что время захвата данным объектом разными потоками не пересекается вообще или пересекается незначительно. В этом режиме вместо тяжеловесных блокировок операционной системы, JVM использует атомики.
	- ptr_to_lock_record — для установки/ожидания блокировки используется CAS (compare and set) внутри цикла spin loop.  Для справки, минимальное время блокировки ОС будет в районе порядка 10 мс, при помощи атомиков поток не засыпает, а продолжает молотить небольшой цикл, и как только ресурс освободится, цикл с атомиком закончится, и поток тут же захватит этот объект.

- Режим Heavyweight Locked (lock = 10)
	- ptr_to_heavyweight_monitor — если время захвата данным объектом различными потоками будет значительно пересекаться, то lightweight lock будет заменена на heavyweight lock. В ptr_to_heavyweight_monitor будет записан указатель на монитор. Используется блокировка ОС.
#### ClassPointer - к какому базовому классу он относится

###### Переменная не помечена словом final, то изменяться она не может?

###### Хорошо ли делать длинную цепочку наследования на классах?

###### Как модификатор по умолчанию?
### Generics
#### Что такое generics?

Generics – это технический термин, обозначающий набор свойств языка, позволяющих
определять и использовать обобщенные типы и методы. Обобщенные типы или методы
отличаются от обычных тем, что имеют типизированные параметры.

Примером использования обобщенных типов может служить _Java Collection Framework_. Так, класс `LinkedList<E>` - типичный обобщенный тип. Он содержит параметр `E`, который представляет тип элементов, которые будут храниться в коллекции. Создание объектов обобщенных типов происходит посредством замены параметризированных типов реальными типами данных. Вместо того, чтобы просто использовать `LinkedList`, ничего не говоря о типе элемента в списке, предлагается использовать точное указание типа `LinkedList<String>`, `LinkedList<Integer>` и т.п.

#### Можно ли в рантайме узнать тип параметра T?

```java
public abstract class GenericClass<T> {
    private Class<T> type;

    @SuppressWarnings("unchecked")
    protected GenericClass() {
        Type superClass = getClass().getGenericSuperclass();
        if (superClass instanceof ParameterizedType) {
            ParameterizedType parameterizedType = (ParameterizedType) superClass;
            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
            if (actualTypeArguments.length > 0) {
                type = (Class<T>) actualTypeArguments[0];
            }
        }
    }

    public Class<T> getType() {
        return type;
    }
}

class SubGenericClass extends GenericClass<String> {
    // Класс без дополнительной логики
}
```

#### Возможно ли ограничить тип двумя классами/интерфейсами?

Двумя интерфейсами можно, потому что в java поддерживается множественная имплементация.

Двумя классами нет, класс не может наследовать от нескольких классов.

#### Что такое raw type (сырой тип)?

Raw-types are ancient history of the Java language. In the beginning there were `Collections` and they held `Objects` nothing more and nothing less. Every operation on `Collections` required casts from `Object` to the desired type.

Это имя интерфейса без указания параметризованного типа:
`List list = new ArrayList(); // raw type`
`List<Integer> listIntgrs = new ArrayList<>(); // parameterized type`

#### Что такое стирание типов?

Суть заключается в том, что внутри класса не хранится никакой информации о типе-
параметре. Эта информация доступна только на этапе компиляции и стирается (становится
недоступной) в runtime.

#### А всегда ли Object при стирании типов?

- **Нет**, дженерики стираются до `Object` (или верхней границы, например, `Number` для `T extends Number`).

#### Что такое Heap Pollution

Как мы упомянули ранее, присваивание ссылки на Raw тип переменной параметризованного типа, приводит к предупреждению «Unchecked assignment». Если мы проигнорируем его, то возможна ситуация под названием "`Heap Pollution`" (загрязнение кучи). Вот пример:  

```java
static List<String> t() {
   List l = new ArrayList<Number>();
   l.add(1);
   List<String> ls = l; // (1)
   ls.add("");
   return ls;
}
```

#### Можем ли мы типизировать статическое поле, статический метод?

- **Нет**, дженерики работают только для экземпляров.
- **Но** можно использовать параметризованный метод:

```java
static <T> T doSomething(T input) { ... }
```

#### Что такое Type Inference?

**Type Inference** — это способность компилятора Java **автоматически определять тип данных** из контекста, чтобы программисту не приходилось явно указывать его. Это делает код короче и удобнее для чтения.

- Можно ли сделать внутри метода класс?
Обычный класс нет, допустимо создание вложенного класса или анонимного
- Как получить доступ к переопределенным методам родительского класса?
Чтобы получить доступ к переопределённому методу родительского класса, используется ключевое слово `super`
- Расскажите про вложенные классы. В каких случаях они применяются?
Вложенные классы — это классы, объявленные внутри другого класса.
Типы вложенных классов:
- Статические вложенные классы : Независимы от экземпляра внешнего класса.
- Нестатические (внутренние) вложенные классы : Связаны с экземпляром внешнего класса.
- Локальные классы : Объявлены внутри метода.
- Анонимные классы : Без имени, используются для реализации интерфейсов или абстрактных классов.
Когда использовать:
- Для инкапсуляции логики, связанной с внешним классом.
- Для создания вспомогательных классов, используемых только внутри одного класса.
- Для реализации сложных алгоритмов, где нужен доступ к внутреннему состоянию.

- Каким образом из вложенного класса получить доступ к полю внешнего класса?
Из внутреннего (нестатического) вложенного класса можно получить доступ к полям внешнего класса напрямую, без использования `this`

#### Что такое PECS?

Producer Extends Consumer Super - принцип, который используется при копировании элементов из одной коллекции в другую.  

List\<? extends Number> - producer. Из него можно читать в переменную типа Number и выше по иерархии. Записать в коллекцию ничего нельзя, кроме null.  

```java
List<? extends Number> numbers = new ArrayList<Integer>();
Number num = numbers.get(0); // OK
numbers.add(10); // Ошибка компиляции
numbers.add(null); // OK
```

List\<? super Number> - consumer. В него можно писать все, что наследуется от Number. Читать из него можно только в переменную типа Object.

```java
List<? super Number> numbers = new ArrayList<Object>();
numbers.add(10); // OK
numbers.add(3.14); // OK
Object obj = numbers.get(0); // OK
Number num = numbers.get(0); // Ошибка компиляции
```

- [Подробнее](../../../../_inforage/Java/Core/generics/Wildcard.md#PECS)

#### Разница между super и extends?

```java
<? extends T> обозначает, что класс должен быть наследником T. 
Ограничение сверху.
<? super T> обозначает, что класс должен быть предком T. Ограничение снизу.
```
#### Какие преимущества использования generics? List<'Number> list = new ArrayList<>(); List<'Integer> intList = new ArrayList<>(); list = intList;
- **Типобезопасность** : Компилятор проверяет корректность типов.
- **Отсутствие приведений типов** (casts).
- **Улучшенная читаемость кода** .

#### Можно ли получить в рантайме инфомацию о типах генерика?

Нет, **в рантайме информация о типах генериков теряется** из-за **type erasure** .

#### В чем разница инвариантность, ковариантность, контрвариантность 

- Инвариантность ([[../../../../_inforage/Java/Core/generics/Generics]]) : `Запись List<Number> list = new ArrayList<Integer>() не скомпилируется.`
- Ковариантность (upper constrains): `List<Integer> можно присвоить в переменную типа List<? extends Number> (как будто он наследник List<Number>).`

```java
Reader<String> strR = ...
Reader<Object> objR = strR;
Object data = objR.read();
```

- Контрвариантность (below constrains): `в качестве типа Comparator<? super Number> может быть передан Comparator<Object> (как будто он родитель Comparator<Number>)`

```java
Writer<Object> objW = ...
Writer<String> strW = objW;
strW.write(new String());
```

#### Что такое синтетический мост

![[../../../../_res/Pasted image 20241003220834.png]]

Дело в том, что после компиляции все дженерики затираются и если мы используем параметризованный метод базового класса в классе наследнике, то у нас будет несоответствие возвращаемых типов, хотя синтаксически все будет верно, то есть по сути метод в классе наследнике будет методом подставкой. Для таких методов компилятором в классе наследнике генерируется синтетический метод, который имеет такой же возвращаемый тип, как у метода базового класса. Данный метод будет вызывать метод класса наследника и возвращать тип класса родителя. 

Синтетический мост — это класс, генерируемый компилятором Java для обеспечения совместимости типов при использовании дженериков. Он помогает сохранять правильное поведение методов в иерархии классов и обеспечивает полиморфизм.

- Синтетические мосты не видны в исходном коде, так как они создаются на этапе компиляции.
- Они помогают сохранить правильное поведение программ, когда используются дженерики и наследование.

Синтетические мосты создаются в случаях, когда методы с одинаковым именем имеют разные типы параметров из-за использования дженериков и типов, которые связаны с наследованием. Например, если у вас есть базовый класс с обобщённым методом, и производный класс переопределяет этот метод с конкретным типом, компилятор создаёт синтетический мост для того, чтобы разрешить вызовы методов с правильными типами.

#### Есть ли среди примитивов беззнаковые типы?

Беззнаковый значит, только положительный, char — это единственный примитивный тип, который является беззнаковым. Он используется для представления символов Unicode и может хранить значения от 0 до 65535.






###### Что такое immutable класс в Java?  Как создать? 

Mutable объекты могут изменять свое состояние после создания. 
Примеры из JDK: StringBuilder, Date.  
Immutable называются объекты, чье состояние не изменяется после создания. 

Примеры из JDK: String, Integer. Достоинства:  
• Просты в создании, тестировании, использовании  
• Автоматически потокобезопасны, не нуждаются в синхронизации  
• Не нужны конструктор копирования, и имплементация клонирования  
• Значение hashCode может быть кэшировано  
• Хорошо подходят как ключи Map и элементы Set  

Чтобы сделать класс Immutable:  
• Запретить перегрузку класса - сделать его final или использовать статическую фабрику и сделать конструктор private  
• Поля должны быть private и final  
• Создавать объект за один шаг, в отличие от идеологии JavaBeans (используя конструктор без аргументов и последовательность вызовов сеттеров)  
• Не описывать никаких методов (даже сеттеров), которые изменяют состояние объекта любым способом  
• Если класс имеет любые mutable поля – они должны защищенно копироваться (defensive copying) при передаче между классом и вызывающим его

###### Пример immutable класса

```java
public final class Planet {
	private final Double mass;			//immutable field
	private final String name;			//immutable field
	private final Date dateOfDiscovery;	//mutable field

	public Planet(Double mass, String name, Date dateOfDiscovery) {
		this.mass = mass;
		this.name = name;
		//this.dateOfDiscovery = dateOfDiscovery; 					//this is NOT private copy
		//this.dateOfDiscovery = dateOfDiscovery.clone();			//private copy
		this.dateOfDiscovery = new Date(dateOfDiscovery.getTime());	//private copy
	}
	public Double getMass() { return mass; }
	public String getName() { return name; }
	public Date getDateOfDiscovery() {
		return new Date(dateOfDiscovery.getTime());		//defensive copy of field
	}
}
```

###### Зачем String сделали immutable, что при этом декларировалось разработчиками?

[http://tlazarenko.blogspot.com/2013/10/string-java.html](http://tlazarenko.blogspot.com/2013/10/string-java.html)  
Безопасность и String pool - основные причины неизменяемости строк в Java.  

Безопасность объекта неизменяемого класса String обусловлена такими фактами:  
= потокобезопасность - вы можете передавать строку между потоками и не беспокоиться, что она будет изменена  
= нет проблем с синхронизацией (не нужно синхронизировать операции со String)  
= отсутствие утечек памяти  
= в Java строки используются для передачи параметров для авторизации, открытия файлов и т.д. - неизменяемость позволяет избежать проблем с доступом  
= класс String кэширует хэш-код, что улучшает производительность хеш-коллекций, использующих String  

String pool позволяет экономить память и не создавать новые объекты для каждой повторяющийся строки. В случае с изменяемыми строками - изменение одной приводило бы к изменению всех строк одинакового содержания.

###### Что такое автоупаковка (autoboxing) и автораспаковка (unboxing) в Java?  

- **Автоупаковка (autoboxing)**: Примитивный тип автоматически преобразуется в соответствующий объект-обертку, когда это необходимо.
- **Автораспаковка (unboxing)**: Обратно, объект-обертка автоматически преобразуется в примитивный тип.

112. Какие типы данных поддерживают операции автоупаковки и автораспаковки в Java?  

- `int` ↔ `Integer`
- `double` ↔ `Double`
- `float` ↔ `Float`
- `long` ↔ `Long`
- `short` ↔ `Short`
- `byte` ↔ `Byte`
- `char` ↔ `Character`
- `boolean` ↔ `Boolean`

113. Какие существуют типы исключений в Java?  

- [[../../../../_inforage/Java/Core/исключения/Java исключения]]

114. Что такое статическое связывание в Java?  

**Статическое связывание** в Java — это процесс, при котором компилятор определяет, какой метод или переменная будет использоваться, на этапе компиляции, а не во время выполнения программы. Это связано с тем, что статически связанный код не зависит от конкретных объектов, а работает с типами данных, известными на момент компиляции.

Статическое связывание происходит для методов, которые **не переопределяются** (например, `static` методы, `private` методы и методы класса, которые не являются полиморфными).

115. Как тестировать статические методы?
- [PowerMock(+Mockito) +TestNG и имитация вызова (mock) статических методов]([PowerMock(+Mockito) +TestNG и имитация вызова (mock) статических методов / Хабр](https://habr.com/ru/articles/185834/))
116. Как тестировать feign client?
- [WireMock – швейцарский нож в арсенале тестировщика. Часть 1 / Хабр](https://habr.com/ru/companies/rostelecom/articles/679276/)
- [Offical Docs. Mockoon](https://mockoon.com/docs/latest/gui-cheat-sheet/))
- [Youtube. Mockoon - локальная работа с моками](https://www.youtube.com/watch?v=ZVsqeoWqSlU))
- ApiDog
- Postman
- SoapUI
117. Сколько вмещается байт и размерность в примитивы

- **byte** — целые числа в пределах -128 до 127, весит **1 байт**; 
- **short** — целые числа в пределах -32768 до 32767, весит **2 байта**; 
- **int** — целые числа -2147483648 до 2147483647, весит **4 байта**;
- **long** — целые числа в пределах 9223372036854775808 до 9223372036854775807, весит **8 байтов**; 
- **float** — числа с плавающей запятой в пределах -3.4E+38 до 3.4E+38, весит **4 байта**; 
- **char** — одиночные символы в UTF-16, весит **2 байта**;
- **boolean** — значения true/false, весит **1 байт**. 




###### Можно ли запустить GC из кода?

```java
System.gc();
```

###### Что храниться в метаданных?

###### Какие есть итераторы в Java , их типы? (более абстрактно, fail fast,fail save)

- **`Fail-fast`**: `ArrayList`, `HashMap` (бросают `ConcurrentModificationException` при изменении во время итерации).
- **`Fail-safe`**: `ConcurrentHashMap`, `CopyOnWriteArrayList` (итератор по копии).
###### Может ли быть примитив null?

- **Нет**, только объекты.
- **Обертки**: `Integer i = null` (но `int` — не может).
###### Если super то что можем прочитать?

- **Чтение**: Можно читать только `Object` (безопасность типов).
- **Запись**: Можно добавлять `T` и его подтипы.
###### Разница unmodifiable collection vs immutable?

- unmodifiable collection - Collections.unmodifiableList() - оборачивает исходную, посути дает иммутабельное чтение, поверх исходной, но если изеняем исходную отразится в обертке
-  immutable collection - List.of, Set.of()

###### В чем разница orElse vs orElseGet

- **`orElse`**: Вычисляется всегда (даже если `Optional` не пуст).
- **`orElseGet`**: Ленивый (`Supplier` выполняется только при пустом `Optional`).

**Remember (from the Javadoc) that the Supplier method passed as an argument is only executed when *an Optional* value is not present.**
###### В чем разница Optional.of vs Optional.ofNullable()

- Если Optional.of попадет null, будет NPE
- Если Optional.ofNullable() попадет null, будет возращено Optional.empty()

**String** nullableName = null;
**Optional**<**String**> optionalNullableName = **Optional**.ofNullable(nullableName);
###### можно ли создать объекты абстрактных классов и интерфейсов 

- **Абстрактные классы**: Нельзя создать экземпляр абстрактного класса напрямую. Однако можно создать объект класса, который наследуется от абстрактного класса, если он реализует все абстрактные методы. Или воспользовать анонимными классами и лямбдой:
	- Анонимные классы: AbstractClass obj = new AbstractClass() { ... };
	- Лямбды (для интерфейсов с одним методом): Runnable r = () -> System.out.println("Hello");
- **Интерфейсы**: Нельзя создать объект интерфейса напрямую. Интерфейс может быть реализован классом, и именно этот класс можно инстанцировать. Интерфейсы служат для задания контракта, который должен реализовать класс.
###### что такое сериализация данных

Сериализация данных — это процесс преобразования объекта в последовательность байтов для хранения или передачи (например, через сеть). Этот процесс позволяет сохранить состояние объекта, чтобы позже можно было его восстановить. В Java сериализация осуществляется с помощью интерфейса `Serializable`. При десериализации объект восстанавливается из байтовой последовательности.
###### как исключить поле из сериализации (ключевое слов transient)

- private **transient** String password;

###### плюсы и минусы джавы

**Плюсы Java**:
- **Кросс-платформенность**: Java программы могут работать на разных платформах благодаря JVM (Java Virtual Machine).
- **Мощная экосистема**: Java имеет огромную экосистему библиотек и фреймворков для решения различных задач, включая разработку веб-приложений (например, Spring, Hibernate).
- **Безопасность**: Java имеет встроенные механизмы для защиты от многих видов уязвимостей, таких как управление памятью.
- **Многозадачность**: Java поддерживает многозадачность и многопоточность, что важно для производительных и масштабируемых приложений.
- **Производительность**: С развитием JVM и оптимизацией Just-In-Time компиляции, Java демонстрирует хорошую производительность для крупных приложений.

**Минусы Java**:

- **Большой объем памяти**: Java-программы могут потреблять больше памяти из-за работы JVM и особенностей сборщика мусора.
- **Сложность и громоздкость**: Java может показаться более громоздким по сравнению с более легкими языками, такими как Python или Ruby, особенно при написании коротких программ.
- **Быстродействие старта**: Программы на Java могут иметь более медленное время старта из-за необходимости запуска JVM.

#### Garbage Collector быстрее когда объектов для очистки больше или меньше?

Коллектор ищет живые объект через roots, а не мертвые, поэтому чем меньше живых, тем короче его поиск, поэтому когда мертвых объектов больше, очистка быстрее

### API и конструкции языка Java

#### Что такое явное и неявное приведение типов? В каких случаях в java нужно использовать явное приведение?

- Тождественное (identity). Преобразование выражения любого типа к точно такому же типу всегда допустимо и происходит автоматически.
- Расширение (повышение, upcasting) примитивного типа (widening primitive). Означает, что
осуществляется переход от менее емкого типа к более емкому. Например, от типа byte
(длина 1 байт) к типу int (длина 4 байта). Такие преобразование безопасны в том смысле, что
новый тип всегда гарантировано вмещает в себя все данные, которые хранились в старом
типе, и таким образом не происходит потери данных. Этот тип приведения всегда допустим и
происходит автоматически.
- Сужение (понижение, downcasting) примитивного типа (narrowing primitive). Означает, что
переход осуществляется от более емкого типа к менее емкому. При таком преобразовании
есть риск потерять данные. Например, если число типа int было больше 127, то при
приведении его к byte значения битов старше восьмого будут потеряны. В Java такое
преобразование должно совершаться явным образом, при этом все старшие биты, не
умещающиеся в новом типе, просто отбрасываются – никакого округления или других
действий для получения более корректного результата не производится.
- Расширение объектного типа (widening reference). Означает неявное восходящее
приведение типов или переход от более конкретного типа к менее конкретному, т. е. переход
от потомка к предку. Разрешено всегда и происходит автоматически.
- Сужение объектного типа (narrowing reference). Означает нисходящее приведение, то
есть приведение от предка к потомку (подтипу). Возможно только если исходная переменная
является подтипом приводимого типа. При несоответствии типов в момент выполнения
выбрасывается исключение ClassCastException. Требует явного указания типа.
Преобразование к строке (to String). Любой тип может быть приведен к строке, т. е. к
экземпляру класса String.
- Запрещенные преобразования (forbidden). Не все приведения между произвольными
типами допустимы. Например, к запрещенным преобразованиям относятся приведения от
любого ссылочного типа к примитивному и наоборот (кроме преобразования к строке). 

#### В чем разница Optional.of(), Optional.ofNullable()

Если Optional.ofNullable() пулучит null она вернет empty Optional, but if we use Optional.of(null), this throw NullPointerException.

- [Guide To Java Optional](https://www.baeldung.com/java-optional)

#### Что такое StringJoiner?

Класс StringJoiner используется, чтобы создать последовательность строк, разделенных
разделителем с возможностью присоединить к полученной строке префикс и суффикс:

```java
StringJoiner joiner = new StringJoiner(".", "prefix-", "-suffix");
for (String s : "Hello the brave world".split(" ")) {
	joiner.add(s);
}
System.out.println(joiner); //prefix-Hello.the.brave.world-suffix
```
#### Каковы основные операции, которые можно выполнить с массивами?

- Чтение элемента — доступ по индексу: `array[i]`
- Запись элемента — изменение значения по индексу: `array[i] = value`
- Итерация — перебор элементов: `for` или `for-each`
- Добавление элемента — для фиксированных массивов создаётся новый массив: `Arrays.copyOf()`
- Удаление элемента — для фиксированных массивов создаётся новый массив: `System.arraycopy()` или вручную.
- Сортировка — упорядочивание элементов: `Arrays.sort(array)`
- Поиск элемента — нахождение индекса: `Arrays.binarySearch()` (если массив отсортирован) или `for` loop для линейного поиска.

#### Что такое autoboxing («автоупаковка») в Java и каковы правила упаковки примитивных типов в классы-обертки?

**Autoboxing** — автоматическая конвертация примитивных типов в соответствующие классы-обертки и обратно.
### IO

#### Что такое сериализация?

Serialization in Java is the process of converting an object into a byte stream, which can then be saved to a file or sent over a network. This process is crucial when you need to send objects over a network or store them in files for later retrieval

#### Опишите процесс сериализации/десериализации с использованием Serializable

Step 1: Implement Serializable Interface

The `Serializable` interface is a marker interface (it has no methods or fields) and serves to inform the JVM that the class can be serialized.

Step 2: Serialize the Object

Next, we need to serialize the object. This can be done using `FileOutputStream` and `ObjectOutputStream`.

```java
Employee e = new Employee();
e.name = "John Doe";
e.department = "Engineering";

FileOutputStream fileOut = new FileOutputStream("employee.ser");
ObjectOutputStream out = new ObjectOutputStream(fileOut);
out.writeObject(e);
out.close();
fileOut.close();
```

Step 3. Deserialize the Object

Serialization in Java is the process of converting the state of an object into a byte stream. This byte stream can then be saved to a file or sent over a network. When needed, the byte stream can be converted back into an object, a process known as deserialization.

```java
FileInputStream fileIn = new FileInputStream("employee.ser");
ObjectInputStream in = new ObjectInputStream(fileIn);
Employee e = (Employee) in.readObject();
in.close();
fileIn.close();
```

#### Для чего нам serialVersionUID?

The reason is clear that serialVersionUID of the previous class and new class are different. Actually if the class doesn’t define serialVersionUID, it’s getting calculated automatically and assigned to the class. Java uses class variables, methods, class name, package etc to generate this unique long number.

#### Как изменить стандартное поведение сериализации/десериализации?

In some cases, you may want to control the serialization process. This is where custom serialization comes into play. You can define the `writeObject()` and `readObject()` methods in your class to control what data is serialized and how.

Определяем методы, JVM проверяет если есть такие методы, и вызывает их. Должны быть объявлены в классе, который помочен как Serializable. 

```java
public class Employee implements Serializable {  
  
    private static final long serialVersionUID = -6470090944414208496L;  
  
    private String name;  
    private int id;  
    transient private int salary;  
    private String password;  
  
    @Serial  
    private void writeObject(ObjectOutputStream oos) throws IOException {  
        oos.defaultWriteObject();  
        oos.writeObject(password);  
    }  
  
    @Serial  
    private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException {  
        ois.defaultReadObject();  
        this.password = (String) ois.readObject();  
    }

	...
}
```

#### Зачем аннотация @Serial ?

Она используется только для документации и анализа кода .  JVM её не обрабатывает , но она помогает: понять, что метод или поле относится к сериализации .

Применяется только к:

- Методам сериализации : `writeObject()`, `readObject()`, `readObjectNoData()`, `writeReplace()`, `readResolve()`
- Полю `serialVersionUID`
#### Как работать с Serialization в распределенной системе?

```java
// Server side
ServerSocket serverSocket = new ServerSocket(9000);
Socket socket = serverSocket.accept();
ObjectOutputStream out = new ObjectOutputStream(socket.getOutputStream());
out.writeObject(employee);

// Client side
Socket socket = new Socket("localhost", 9000);
ObjectInputStream in = new ObjectInputStream(socket.getInputStream());
Employee employee = (Employee) in.readObject();
```

#### Что такое Externalizable?

Иногда мы хотим скрыть данные объекта, чтобы сохранить его целостность. Этого можно достичь, реализовав интерфейс `java.io.Externalizable`, и предоставив собственную реализацию методов `_writeExternal()_` и `_readExternal()_`, которые будут использоваться при процессе сериализации.

- Интерфейс `Externalizable` является более специализированным и используется для сериализации объектов в Java. Он расширяет интерфейс `Serializable` и дает программисту больше контроля над процессом сериализации и десериализации объекта.
- **Основные методы**:
    - `writeExternal(ObjectOutput out)`: позволяет объекту записать свои данные в поток (сериализация).
    - `readExternal(ObjectInput in)`: позволяет объекту восстановить свои данные из потока (десериализация).

#### Что такое InputStream и OutputStream? Какие подклассы вы знаете?

**InputStream** и **OutputStream** — абстрактные классы для работы с потоками байтов.

Подклассы InputStream:

- `FileInputStream`
- `ByteArrayInputStream`
- `BufferedInputStream`
- `DataInputStream`
- `ObjectInputStream`

Подклассы OutputStream:

- `FileOutputStream`
- `ByteArrayOutputStream`
- `BufferedOutputStream`
- `DataOutputStream`
- `ObjectOutputStream`

#### Что такое Reader и Writer и какие подклассы вы знаете? Для чего они предназначены?

**Reader** и **Writer** — это абстрактные классы в Java, используемые для работы с символьными данными (текстом). Они являются частью пакета `java.io` и предоставляют простой и удобный интерфейс для чтения и записи текстовых данных. Давайте подробно рассмотрим эти классы и их подклассы.

-  Подклассы Reader:

- `FileReader`
- `CharArrayReader`
- `BufferedReader`
- `InputStreamReader`

- Подклассы Writer:

- `FileWriter`
- `CharArrayWriter`
- `BufferedWriter`
- `OutputStreamWriter`

#### В чем разница использования Reader и Writer vs InputStream и OutputStream

InputStream/OutputStream:
 - Тип Данных: Работают с байтовыми данными (`byte`).
Reader/Writer:
- Тип Данных: Работают с символьными данными (`char`), что упрощает работу с текстом.
#### В чем разница между IO пакетом и NIO пакетом в Java?

| Хар-ка                 | IO                     | NIO                                                        |
| ---------------------- | ---------------------- | ---------------------------------------------------------- |
| **Потоки**             | Блокирующие            | Неблокирующие (non-blocking)                               |
| **Буферы**             | Нет                    | Есть (Buffer, Channel, Selector)                           |
| **Каналы**             | Нет                    | Есть (Channel)                                             |
| **Производительность** | Ниже                   | Выше, особенно при работе с большим количеством соединений |
| **Работа с файлами**   | Производится построчно | Может работать с буферами и каналами                       |

Примеры Классов

IO:

`FileInputStream`,`FileOutputStream`,`BufferedReader`,`BufferedWriter`

NIO: 

`FileChannel`,`ByteBuffer`,`Selector`
#### Что такое “каналы”?

Каналы (Channels) — это объекты, которые позволяют читать и писать данные в потоках, но **не блокируют выполнение программы** , если данные ещё не готовы.

Основные типы:

- `FileChannel`
- `SocketChannel`
- `ServerSocketChannel`
- `DatagramChannel`
## Resources

- [Array vs. Linked List](https://www.happycoders.eu/algorithms/array-vs-linked-list/)
- [Java Interview Q & A ](https://andrei-punko.github.io/java-interview-faq-n-answers/#q-1972963652)
- [A categorized list of all Java and JVM features since JDK 8 to 21](https://advancedweb.hu/a-categorized-list-of-all-java-and-jvm-features-since-jdk-8-to-21/)
- [Вилкой в глаз, или ForkJoinPool в Java](https://habr.com/ru/articles/565924/)

### JVM

- [Руководство по String pool в Java](https://topjava.ru/blog/rukovodstvo-po-string-pool-v-java)
- 
### Generics

- [Background: how we got the generics we have](https://cr.openjdk.org/~briangoetz/valhalla/erasure.html)
### IO

- [Serialization in Java: A Detailed Guide with Examples](https://ioflood.com/blog/serialization-in-java/)
- [Serialization in Java - Java Serialization](https://www.digitalocean.com/community/tutorials/serialization-in-java#java-externalizable-interface)
- 