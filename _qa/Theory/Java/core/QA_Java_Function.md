## QA

###### Что такое функциональный интерфейс? 

Функциональный интерфейс – интерфейс с одним абстрактным методом. Помимо одного абстрактного, может содержать любое количество статических и дефолтных методов.

###### Для чего нужна аннотация `@FunctionalInterface` 

Для гарантии того, что интерфейс является функциональным. Она не даст создать еще один абстрактный метод. Компилятор начнет ругаться

###### Какие встроенные функциональные интерфейсы вы знаете? 

- `Predicate<T>` – принимает объект типа T и проверяет соблюдение некоторого условия и возвращает результат типа Boolean
- `BiPredicate<T, U>` - принимает два объекта типов T и U и проверяет соблюдение некоторого условия и возвращает результат типа Boolean
- `Consumer<T>` - принимает объект, совершает некоторые действия, но при этом ничего не возвращает.
- `BiConsumer<T, U>` - принимает два объекта типов T и U, совершает некоторые действия, но при этом ничего не возвращает.
- `Supplier<T>` - не принимает никаких аргументов, но возвращает некоторый объект T.
- `Function<T, R>` - принимает аргумент T и приводит его к объекту типа R, который и возвращается как результат.
- `BiFunction<T, U, R>` - принимает два аргумента типа T и U и приводит их к объекту типа R, который и возвращается как результат
- `UnaryOperator<T>` - принимает в качестве параметра объект T, выполняет над ним некоторые операции и возвращает результат операций в виде объекта того же типа.
- `BinaryOperator<T>` – принимает два аргумента типа T и возвращает объект того же типа.

###### Что такое ссылка на метод? 

_Ссылка на метод_ - сокращенная запись для лямбда-выражений, которая позволяет ссылаться на уже существующий метод и использовать его как функциональный интерфейс

`String::valueOf`

###### Что такое лямбда выражение? Чем его можно заменить? 

_Лямбда_ – набор инструкций, которые можно выделить в отдельную переменную и затем многократно использовать. Являются сокращённой формой внутренних анонимных классов.

_**Чем его можно заменить?**_
1. Анонимным классом
2. Обычным классом, реализующим интерфейс
3. Ссылкой на метод (method reference)

_**Анонимный класс vs лямбда**_

Это два способа реализации интерфейсов или создания компактного кода в Java. Они имеют сходства, но различаются по способу использования, синтаксису и некоторым ограничениям.

_Анонимный класс_ — это локальный класс без имени, который объявляется и создаётся одновременно.

_Лямбда_ — это краткий способ объявления реализации функционального интерфейса (интерфейса с одним методом).

| **Критерий**                 | **Анонимный класс**                      | **Лямбда-выражение**                               |
| ---------------------------- | ---------------------------------------- | -------------------------------------------------- |
| **Синтаксис**                | Более громоздкий                         | Краткий и лаконичный                               |
| **Совместимость**            | Любой интерфейс или класс                | Только функциональный интерфейс                    |
| **Использование `this`**     | Ссылается на экземпляр анонимного класса | Ссылается на экземпляр внешнего класса             |
| **Многометодные интерфейсы** | Можно переопределять несколько методов   | Не поддерживается (только один метод)              |
| **Поддержка переменных**     | Может содержать свои переменные и методы | Не может содержать свои методы или поля            |
| **Производительность**       | Более ресурсоёмкий (создаёт новый класс) | Оптимизирован JVM (не создаёт новый объект класса) |
#### Какова структура и особенности использования лямбда-выражения?

Лямбда представляет собой набор инструкций, которые можно выделить в отдельную
переменную и затем многократно вызвать в различных местах программы.
Основу лямбда-выражения составляет лямбда-оператор, который представляет стрелку ->.
Этот оператор разделяет лямбда-выражение на две части: левая часть содержит список
параметров выражения, а правая представляет тело лямбда-выражения, где выполняются
все действия.
Лямбда-выражение не выполняется само по себе, а образует реализацию метода,
определенного в функциональном интерфейсе. При этом важно, что функциональный
интерфейс должен содержать только один единственный метод без реализации.
По факту лямбда-выражения являются в некотором роде сокращенной формой внутренних
анонимных классов, которые ранее применялись в Java.

#### К каким переменным есть доступ у лямбда-выражений?

Доступ к переменным внешней области действия из лямбда-выражения очень схож с доступом из анонимных объектов. Можно ссылаться на:
- неизменяемые (effectively final – не обязательно помеченные как final) локальные
переменные;
- поля класса;
- статические переменные.
К методам по умолчанию реализуемого функционального интерфейса обращаться внутри
лямбда-выражения запрещено.

#### Что делает Интерфейс Function

`java.util.function.Function` - это встроенный функциональный интерфейс, добавленный в Java SE 8.

Принимает значение в качестве аргумента одного типа и возвращает другое значение. Часто используется для преобразования одного значения в другое:

```java
@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);
}
```

#### Как можно использовать лямбда-выражения для реализации интерфейсов?

- Лямбда-выражение позволяет реализовать функциональный интерфейс, т. е. интерфейс с одним абстрактным методом. Лямбда выражение фактически реализует этот метод и передаёт его логику.

#### Сигнатура функционального интерфейса Predicate, в каких методах используется?

```java
@FunctionalInterface
public interface Predicate<T> {
    boolean test(T t);
}
```

Используется в `Stream.filter()`, `Collection.removeIf()`.
## Resources

