#### Что такое «коллекция»? [X]

«Коллекция» - это структура данных, набор каких-либо объектов. Данными (объектами в наборе) могут быть числа, строки, объекты пользовательских классов и т.п.

#### Опишите иерархию интерфейсов в Collections [X]

На вершине иерархии в Java Collection Framework располагаются 2 интерфейса: `Collection` и `Map`. Эти интерфейсы разделяют все коллекции, входящие во фреймворк на две части по типу хранения данных: простые последовательные наборы элементов и наборы пар «ключ — значение» соответственно. Над Collection также находиться интерфейс Iterable.

[Иерархия коллекции](../../../../_inforage/Java/Core/data%20structure/Иерархия%20коллекции.md)

Интерфейс `Collection` расширяют интерфейсы:

- `List` (список) представляет собой коллекцию, в которой допустимы дублирующие значения. Элементы такой коллекции пронумерованы, начиная от нуля, к ним можно обратиться по индексу. Реализации:
    - `ArrayList` - инкапсулирует в себе обычный массив, длина которого автоматически увеличивается при добавлении новых элементов.
    - `LinkedList` (двунаправленный связный список) - состоит из узлов, каждый из которых содержит как собственно данные, так и две ссылки на следующий и предыдущий узел.
    - `Vector` — реализация динамического массива объектов, методы которой синхронизированы.
    - `Stack` — реализация стека LIFO (last-in-first-out).
- `Set` (сет) описывает неупорядоченную коллекцию, не содержащую повторяющихся элементов. Реализации:
    - `HashSet` - использует HashMap для хранения данных. В качестве ключа и значения используется добавляемый элемент. Из-за особенностей реализации порядок элементов не гарантируется при добавлении.
    - `LinkedHashSet` — гарантирует, что порядок элементов при обходе коллекции будет идентичен порядку добавления элементов.
    - `TreeSet` — предоставляет возможность управлять порядком элементов в коллекции при помощи объекта `Comparator`, либо сохраняет элементы с использованием «natural ordering».
- `Queue` (очередь) предназначена для хранения элементов с предопределённым способом вставки и извлечения FIFO ( first-in-first-out):
    - `PriorityQueue` — предоставляет возможность управлять порядком элементов в коллекции при помощи объекта `Comparator`, либо сохраняет элементы с использованием «natural ordering».
    - `ArrayDeque` — реализация интерфейса `Deque`, который расширяет интерфейс `Queue` методами, позволяющими реализовать конструкцию вида LIFO (last-in-first-out).

Интерфейс `Map` реализован классами:

- `Hashtable` — хэш-таблица, методы которой синхронизированы. Не позволяет использовать `null` в качестве значения или ключа и не является упорядоченной.
- `HashMap` — хэш-таблица. Позволяет использовать `null` в качестве значения или ключа и не является упорядоченной.
- `LinkedHashMap` — упорядоченная реализация хэш-таблицы.
- `TreeMap` — реализация, основанная на красно-чёрных деревьях. Является упорядоченной и предоставляет возможность управлять порядком элементов в коллекции при помощи объекта `Comparator`, либо сохраняет элементы с использованием «natural ordering».
- `WeakHashMap` — реализация хэш-таблицы, которая организована с использованием _weak references_ для ключей (сборщик мусора автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ этого элемента нет жёстких ссылок).

#### Почему `Map` — это не `Collection`, в то время как `List` и `Set` являются `Collection`? [X]

`Collection` представляет собой совокупность некоторых элементов. `Map` - это совокупность пар «ключ-значение». Если бы Map стали реализовывать на основе Collection, это бы нарушало заданный контракт, к примеру метод `add()` требовал бы не только значение, но ключ.
#### В чем разница между классами `java.util.Collection` и `java.util.Collections`? [X]

`java.util.Collections` - набор статических методов для работы с коллекциями.
`java.util.Collection` - один из основных интерфейсов Java Collections Framework.

#### Что такое «fail-fast поведение»? [X]

**fail-fast поведение** означает, что при возникновении ошибки или состояния, которое может привести к ошибке, система немедленно прекращает дальнейшую работу и уведомляет об этом. Использование fail-fast подхода позволяет избежать недетерминированного поведения программы в течение времени.

В Java Collections API некоторые итераторы ведут себя как fail-fast и выбрасывают `ConcurrentModificationException`, если после его создания была произведена модификация коллекции, т.е. добавлен или удален элемент напрямую из коллекции, а не используя методы итератора.

Реализация такого поведения осуществляется за счет подсчета количества модификаций коллекции (modification count / modCount):

- при изменении коллекции счетчик модификаций так же изменяется;
- при создании итератора ему передается текущее значение счетчика;
- при каждом обращении к итератору сохраненное значение счетчика сравнивается с текущим, и, если они не совпадают, возникает исключение.

#### Какая разница между fail-fast и fail-safe? [X]

В противоположность fail-fast, итераторы fail-safe не вызывают никаких исключений при изменении структуры, потому что они работают с клоном коллекции вместо оригинала.

#### Приведите примеры итераторов, реализующих поведение fail-safe [X]

Итератор коллекции `CopyOnWriteArrayList` и итератор представления `keySet` коллекции `ConcurrentHashMap` являются примерами итераторов fail-safe.

#### Чем различаются `Enumeration` и `Iterator` [X]

Хотя оба интерфейса и предназначены для обхода коллекций между ними имеются существенные различия:

- с помощью `Enumeration` нельзя добавлять/удалять элементы;
- в `Iterator` исправлены имена методов для повышения читаемости кода (`Enumeration.hasMoreElements()` соответствует `Iterator.hasNext()`, `Enumeration.nextElement()` соответствует `Iterator.next()` и т.д);
- `Enumeration` присутствуют в устаревших классах, таких как `Vector`/`Stack`, тогда как `Iterator` есть во всех современных классах-коллекциях.
- `Enumeration` не выкидывает `ConcurrentModificationException` при модификации коллекции во время итерации, не отслеживает изменения коллекции после создания `Enumeration`

#### Как между собой связаны `Iterable` и `Iterator`? [X]

Интерфейс `Iterable` имеет только один метод - `iterator()`, который возвращает `Iterator`

#### Сравните `Iterator` и `ListIterator` [X]

- `ListIterator` расширяет интерфейс `Iterator`
- `ListIterator` может быть использован только для перебора элементов коллекции `List`;
- `Iterator` позволяет перебирать элементы только в одном направлении, при помощи метода `next()`. Тогда как `ListIterator` позволяет перебирать список в обоих направлениях, при помощи методов `next()` и `previous()`;
- `ListIterator` не указывает на конкретный элемент: его текущая позиция располагается между элементами, которые возвращают методы `previous()` и `next()`.
- При помощи `ListIterator` вы можете модифицировать список, добавляя/удаляя элементы с помощью методов `add()` и `remove()`. `Iterator` не поддерживает данного функционала.

#### Что произойдет при вызове `Iterator.next()` без предварительного вызова `Iterator.hasNext()`? [X]

Если итератор указывает на последний элемент коллекции, то возникнет исключение `NoSuchElementException`, иначе будет возвращен следующий элемент.

#### Сколько элементов будет пропущено, если `Iterator.next()` будет вызван после 10 вызовов `Iterator.hasNext()`? [X]

Нисколько - `hasNext()` осуществляет только проверку наличия следующего элемента.

#### Как поведёт себя коллекция, если вызвать `iterator.remove()`? [X]

Если вызову `iterator.remove()` предшествовал вызов `iterator.next()`, то `iterator.remove()` удалит элемент коллекции, на который указывает итератор, в противном случае будет выброшено `IllegalStateException()`.

#### Как поведёт себя уже инстанциированный итератор для `collection`, если вызвать `collection.remove()`? [X]

При следующем вызове методов итератора будет выброшено `ConcurrentModificationException`.

#### Как избежать `ConcurrentModificationException` во время перебора коллекции? [X]

- Попробовать подобрать другой итератор, работающий по принципу fail-safe. К примеру, для `List` можно использовать `ListIterator`.
- Использовать `ConcurrentHashMap` и `CopyOnWriteArrayList`.
- Преобразовать список в массив и перебирать массив.
- Блокировать изменения списка на время перебора с помощью блока `synchronized`.
#### Какая коллекция реализует дисциплину обслуживания FIFO? [X]

FIFO, First-In-First-Out («первым пришел-первым ушел») - по этому принципу построена коллекция `Queue`.

#### Какая коллекция реализует дисциплину обслуживания FILO? [X]

FILO, First-In-Last-Out («первым пришел, последним ушел») - по этому принципу построена коллекция `Stack`.

#### Чем отличается `ArrayList` от `Vector`? [X]

- Методы класса `Vector` синхронизированы, а `ArrayList` - нет;
- По умолчанию, `Vector` удваивает свой размер, когда заканчивается выделенная под элементы память. `ArrayList` же увеличивает свой размер только на половину (x 1.5).

#### Чем отличается `ArrayList` от `LinkedList`? В каких случаях лучше использовать первый, а в каких второй? [X]

`ArrayList` это список, реализованный на основе массива, а `LinkedList` — это классический двусвязный список, основанный на объектах с ссылками между ними.

`ArrayList`:

- доступ к произвольному элементу по индексу за _константное_ время _O(1)_;
- доступ к элементам по значению за _линейное_ время _O(N)_;
- вставка в конец в среднем производится за _константное_ время _O(1)_;
- удаление произвольного элемента из списка занимает значительное время т.к. при этом все элементы, находящиеся «правее» смещаются на одну ячейку влево (реальный размер массива (capacity) не изменяется);
- вставка элемента в произвольное место списка занимает значительное время т.к. при этом все элементы, находящиеся «правее» смещаются на одну ячейку вправо;
- минимум накладных расходов при хранении.

`LinkedList`:

- на получение элемента по индексу или значению потребуется _линейное_ время _O(N)_;
- на добавление и удаление в начало или конец списка потребуется _константное_ _O(1)_;
- вставка или удаление в/из произвольного место _константное_ _O(1)_;
- требует больше памяти для хранения такого же количества элементов, потому что кроме самого элемента хранятся еще указатели на следующий и предыдущий элементы списка.

В целом, `LinkedList` в абсолютных величинах проигрывает `ArrayList` и по потребляемой памяти, и по скорости выполнения операций. `LinkedList` предпочтительно применять, когда нужны частые операции вставки/удаления или в случаях, когда необходимо гарантированное время добавления элемента в начало или конец.

#### Какое худшее время работы метода `contains()` для элемента, который есть в `LinkedList` или `ArrayList`? [X]

_O(N)_. Время поиска элемента линейно пропорционально количеству элементов в списке.

#### Какое худшее время работы метода `add()` для `LinkedList`? [X]

_O(N)_. Добавление в начало/конец списка осуществляется за время _O(1)_.

#### Какое худшее время работы метода `add()` для `ArrayList`? [X]

_O(N)_. Вставка элемента в конец списка осуществляется за время _O(1)_, но если вместимость массива недостаточна, то происходит создание нового массива с увеличенным размером и копирование всех элементов из старого массива в новый. Копирование осуществляется блоками, при помощи нативной реализации `System.arraycopy`, поэтому это более оптимизированной чем линейная итереация через O (n)

#### Необходимо добавить 1 млн. элементов, какую структуру вы используете? [X]

Однозначный ответ можно дать только исходя из информации о том в какую часть списка происходит добавление элементов, что потом будет происходить с элементами списка, существуют ли какие-то ограничения по памяти или скорости выполнения.

Но если будет добавление только в начало или конец, пойдет какая-нибудь очередь или односвязный список. Однако стоит учитывать что LinkedList состоит из связанных нод объектов, разбросанных по памяти, когда ArrayList содержит единый массив.

#### Как происходит удаление элементов из `ArrayList`? Как меняется в этом случае размер `ArrayList`? [X]

При удалении произвольного элемента из списка, все элементы, находящиеся «правее» смещаются на одну ячейку влево и реальный размер массива (его емкость, capacity) не изменяется никак. Механизм автоматического «расширения» массива существует, а вот автоматического «сжатия» нет, можно только явно выполнить «сжатие» командой `trimToSize()`.

#### Сколько необходимо дополнительной памяти при вызове `ArrayList.add()`? [X]

Если в массиве достаточно места для размещения нового элемента, то дополнительной памяти не требуется. Иначе происходит создание нового массива размером в 1,5 раза превышающим существующий (это верно для JDK выше 1.7, в более ранних версиях размер увеличения иной).

#### Сколько выделяется дополнительно памяти при вызове `LinkedList.add()`? [X]

Создается один новый экземпляр вложенного класса `Node`.

#### Оцените количество памяти на хранение одного примитива типа `byte` в `LinkedList`?

Каждый элемент `LinkedList` хранит ссылку на предыдущий элемент, следующий элемент и ссылку на данные.

```java
private static class Node<E> {
        E item;
        Node<E> next;
        Node<E> prev;
//...
}
```

Для 32-битных систем каждая ссылка занимает 32 бита (4 байта). Сам объект (заголовок) вложенного класса `Node` занимает 8 байт. 4 + 4 + 4 + 8 = 20 байт, а т.к. размер каждого объекта в Java кратен 8, соответственно получаем 24 байта. Примитив типа `byte` занимает 1 байт памяти, но в JCF примитивы упаковываются: объект типа `Byte` занимает в памяти 16 байт (8 байт на заголовок объекта, 1 байт на поле типа `byte` и 7 байт для кратности 8). Также напомню, что значения от -128 до 127 кэшируются и для них новые объекты каждый раз не создаются. Таким образом, в x32 JVM 24 байта тратятся на хранение одного элемента в списке и 16 байт - на хранение упакованного объекта типа `Byte`. Итого 40 байт.

Для 64-битной JVM каждая ссылка занимает 64 бита (8 байт), размер заголовка каждого объекта составляет 16 байт (два машинных слова). Вычисления аналогичны: 8 + 8 + 8 + 16 = 40 байт и 24 байта. Итого 64 байта.

#### Оцените количество памяти на хранение одного примитива типа `byte` в `ArrayList`?

`ArrayList` основан на массиве, для примитивных типов данных осуществляется автоматическая упаковка значения, поэтому 16 байт тратится на хранение упакованного объекта и 4 байта (8 для x64) - на хранение ссылки на этот объект в самой структуре данных. Таким образом, в x32 JVM 4 байта используются на хранение одного элемента и 16 байт - на хранение упакованного объекта типа `Byte`. Для x64 - 8 байт и 24 байта соответственно.

#### Для `ArrayList` или для `LinkedList` операция добавления элемента в середину (`list.add(list.size()/2, newElement)`) медленнее? [X]

Для `ArrayList`:

- проверка массива на вместимость. Если вместимости недостаточно, то увеличение размера массива и копирование всех элементов в новый массив (_O(N)_);
- копирование всех элементов, расположенных правее от позиции вставки, на одну позицию вправо (_O(N)_);
- вставка элемента (_O(1)_).

Для `LinkedList`:

- поиск позиции вставки (_O(N)_);
- вставка элемента (_O(1)_).

В худшем случае вставка в середину списка эффективнее для `LinkedList`. В остальных - скорее всего, для `ArrayList`, поскольку копирование элементов осуществляется за счет вызова быстрого системного метода `System.arraycopy()`.

#### В реализации класса `ArrayList` есть следующие поля: `Object[] elementData`, `int size`. Объясните, зачем хранить отдельно `size`, если всегда можно взять `elementData.length`? [X]

Размер массива `elementData` представляет собой вместимость (capacity) `ArrayList`, которая всегда больше переменной `size` - реального количества хранимых элементов. При необходимости вместимость автоматически возрастает.

#### Сравните интерфейсы `Queue` и `Deque`

#### Кто кого расширяет: `Queue` расширяет `Deque`, или `Deque` расширяет `Queue`? [X]

`Queue` - это очередь, которая обычно (но необязательно) строится по принципу FIFO (First-In-First-Out) - соответственно извлечение элемента осуществляется с начала очереди, вставка элемента - в конец очереди. Хотя этот принцип нарушает, к примеру, `PriorityQueue`, использующая «natural ordering» или переданный `Comparator` при вставке нового элемента.

`Deque` (Double Ended Queue) расширяет `Queue` и согласно документации, это линейная коллекция, поддерживающая вставку/извлечение элементов с обоих концов. Помимо этого реализации интерфейса `Deque` могут строиться по принципу FIFO, либо LIFO.

Реализации и `Deque`, и `Queue` обычно не переопределяют методы `equals()` и `hashCode()`, вместо этого используются унаследованные методы класса Object, основанные на сравнении ссылок.

#### Почему `LinkedList` реализует и `List`, и `Deque`? [X]

`LinkedList` позволяет добавлять элементы в начало и конец списка за константное время, что хорошо согласуется с поведением интерфейса `Deque`.

#### `LinkedList` — это односвязный, двусвязный или четырехсвязный список? [X]

`Двусвязный`: каждый элемент `LinkedList` хранит ссылку на предыдущий и следующий элементы.

#### Как перебрать элементы `LinkedList` в обратном порядке, не используя медленный `get(index)`? [X]

Для этого в `LinkedList` есть обратный итератор, который можно получить вызова метод `descendingIterator()`.
#### Что позволяет сделать `PriorityQueue`? [X]

Особенностью `PriorityQueue` является возможность управления порядком элементов. По умолчанию, элементы сортируются с использованием «natural ordering», но это поведение может быть переопределено при помощи объекта `Comparator`, который задаётся при создании очереди. Данная коллекция не поддерживает null в качестве элементов.

Используя `PriorityQueue`, можно, например, реализовать алгоритм Дейкстры для поиска кратчайшего пути от одной вершины графа к другой. Либо для хранения объектов согласно определённого свойства.

#### `Stack` считается «устаревшим». Чем его рекомендуют заменять? Почему? [X]

`Stack` был добавлен в Java 1.0 как реализация стека LIFO (last-in-first-out) и является расширением коллекции `Vector`, хотя это несколько нарушает понятие стека (например, класс `Vector` предоставляет возможность обращаться к любому элементу по индексу). Является частично синхронизированной коллекцией (кроме метода добавления `push()`) с вытекающими отсюда последствиями в виде негативного воздействия на производительность. После добавления в Java 1.6 интерфейса `Deque`, рекомендуется использовать реализации именно этого интерфейса, например, `ArrayDeque`.

#### Разница сложности между ArrayList и LinkedList

[Array vs. Linked List](https://www.happycoders.eu/algorithms/array-vs-linked-list/)

![](../../../../_res/Pasted%20image%2020250402124147.png)

LinkedList:
- Elements can be inserted and removed with constant time.
- A linked list does not occupy any unused memory.
ArrayList:
- We can access any array element ("random access") in constant time.
- We can traverse an array from back to front – this is not possible with a singly linked list, only with a doubly linked one.
- When containing the same number of elements, an array occupies significantly less memory than a linked list (C/C++: factor 2–3; Java: factor 6).
- Due to the principle of locality, we can access elements close to each other much faster in an array.
- The garbage collector can perform a reachability analysis much quicker on an array than on a linked list.
- Deleting an array frees a contiguous memory area, while deleting a linked list leaves fragmented memory.

### Map

#### Зачем нужен HashMap, если есть Hashtable? [X]

- Методы класса `Hashtable` синхронизированы, что приводит к снижению производительности, а `HashMap` - нет;
- `HashTable` не может содержать ни ключи, ни значения `null`, тогда как `HashMap` может содержать один ключ `null` и любое количество значений `null`;
- Iterator в `HashMap`, Enumeration в `HashTable`, работает по принципу «fail-fast» (выдает исключение при любой несогласованности данных).

`Hashtable` это устаревший класс и его использование не рекомендовано.
#### Как храниться Hash Map и HashSet в памяти? [X]

> HashMap и хэш-таблица:

- Внутри **`HashMap`** есть **массив бакетов**.
- Этот массив похож на обычный массив в Java: **`bucket[]`** = `new bucket[initialCapacity]`, где `initialCapacity` — это начальный размер массива (например, по умолчанию 16).
- **Каждый бакет** в массиве является **ссылкой** на **цепочку элементов** (в виде списка или дерева).

> Что такое бакет?

- **Бакет** — это **ячейка массива**. В этой ячейке находится либо `null` (если там пока ничего нет), либо ссылка на **первый элемент** связанного списка (или дерева), в котором хранятся элементы с одинаковым хеш-кодом.
- **Когда несколько элементов имеют одинаковый хеш-код**, они попадают в **один и тот же бакет**. Чтобы различать их, внутри бакета строится либо **связанный список**, либо, если элементов слишком много (начиная с Java 8), **дерево**.

> Структура бакета:

- В начале, когда элементы добавляются в **пустую хэш-таблицу**, в каждом бакете может храниться либо:
    - `null` (если в этом бакете нет данных).
    - Ссылка на **связанный список** элементов (если в бакете один или несколько элементов с одинаковым хеш-кодом).
- Когда количество элементов в одном бакете становится слишком большим (обычно 8 или больше), этот связанный список преобразуется в **красно-черное дерево** для ускорения доступа.

> Алгоритм работы:

- **Хэш-таблица** в `HashMap` — это массив, который индексируется по **хеш-коду ключа**.
    - Хеш-код ключа используется для вычисления **индекса** в массиве бакетов.
- **Бакеты**:
    - Если хеш-коды **разные**, элементы будут храниться в **разных бакетах** (ячейках массива).
    - Если хеш-коды **одинаковые** (коллизия), элементы будут храниться **в одном бакете** — сначала как **связанный список**, а при увеличении количества элементов как **дерево**.

Представьте, что **бакет** — это ячейка в массиве. Если два элемента попадают в один бакет (т.е. имеют одинаковый хеш-код), то бакет хранит **ссылку на список** этих элементов. Когда список становится слишком большим, он преобразуется в **дерево** для более быстрого поиска.
#### В чем разница между HashMap и IdentityHashMap? Для чего нужна IdentityHashMap? [X]

`IdentityHashMap` - это структура данных, так же реализующая интерфейс `Map` и использующая при сравнении ключей (значений) сравнение ссылок, а не вызов метода `equals()`. Другими словами, в `IdentityHashMap` два ключа `k1` и `k2` будут считаться равными, если они указывают на один объект, т.е. выполняется условие `k1` == `k2`.

`IdentityHashMap` не использует метод `hashCode()`, вместо которого применяется метод `System.identityHashCode()`, по этой причине `IdentityHashMap` по сравнению с `HashMap` имеет более высокую производительность, особенно если последний хранит объекты с дорогостоящими методами `equals()` и `hashCode()`.

Одним из основных требований к использованию `HashMap` является неизменяемость ключа, а, т.к. `IdentityHashMap` не использует методы `equals()` и `hashCode()`, то это правило на него не распространяется.

`IdentityHashMap` может применяться для реализации сериализации/клонирования. При выполнении подобных алгоритмов программе необходимо обслуживать хэш-таблицу со всеми ссылками на объекты, которые уже были обработаны. Такая структура не должна рассматривать уникальные объекты как равные, даже если метод `equals()` возвращает `true`.

#### В чем разница между HashMap и WeakHashMap? Для чего используется WeakHashMap? [X]

В Java существует 4 типа ссылок: _сильные (strong reference)_, _мягкие (SoftReference)_, _слабые (WeakReference)_ и _фантомные (PhantomReference)_. Особенности каждого типа ссылок связаны с работой Garbage Collector. Если объект можно достичь только с помощью цепочки WeakReference (то есть на него отсутствуют сильные и мягкие ссылки), то данный объект будет помечен на удаление.

`WeakHashMap` - это структура данных, реализующая интерфейс `Map` и основанная на использовании WeakReference для хранения ключей. Таким образом, пара «ключ-значение» будет удалена из `WeakHashMap`, если на объект-ключ более не имеется сильных ссылок.

В качестве примера использования такой структуры данных можно привести следующую ситуацию: допустим имеются объекты, которые необходимо расширить дополнительной информацией, при этом изменение класса этих объектов нежелательно либо невозможно. В этом случае добавляем каждый объект в `WeakHashMap` в качестве ключа, а в качестве значения - нужную информацию. Таким образом, пока на объект имеется сильная ссылка (либо мягкая), можно проверять хэш-таблицу и извлекать информацию. Как только объект будет удален, то WeakReference для этого ключа будет помещен в ReferenceQueue и затем соответствующая запись для этой слабой ссылки будет удалена из `WeakHashMap`.

#### В `WeakHashMap` используются WeakReferences. А почему бы не создать `SoftHashMap` на SoftReferences? [X]

- `SoftReference` не гарантирует моментального удаления. Это может привести к утечкам памяти, если разработчик ошибочно полагается на "автоматическую" очистку. Пример: Если `SoftHashMap` используется как кэш, он может бесконечно расти, пока JVM не начнет паниковать из-за нехватки памяти.
- `SoftHashMap` представлена в сторонних библиотеках, например, в `Apache Commons`.

#### В `WeakHashMap` используются WeakReferences. А почему бы не создать `PhantomHashMap` на PhantomReferences? [X]

PhantomReference при вызове метода `get()` возвращает всегда `null`, поэтому тяжело представить назначение такой структуры данных. Но используется вместе с `ReferenceQueue` для отслеживания что ресурсы очищен.

```java
ReferenceQueue<Resource> queue = new ReferenceQueue<>();
PhantomReference<Resource> phantomRef = new PhantomReference<>(resource, queue);
```
#### `LinkedHashMap` - что в нем от `LinkedList`, а что от `HashMap`? [X]

Реализация `LinkedHashMap` отличается от `HashMap` поддержкой двухсвязанного списка, определяющего порядок итерации по элементам структуры данных. По умолчанию элементы списка упорядочены согласно их порядку добавления в `LinkedHashMap` (insertion-order). Однако порядок итерации можно изменить, установив параметр конструктора `accessOrder` в значение `true`. В этом случае доступ осуществляется по порядку последнего обращения к элементу (access-order). Это означает, что при вызове методов `get()` или `put()` элемент, к которому обращаемся, перемещается в конец списка.

При добавлении элемента, который уже присутствует в `LinkedHashMap` (т.е. с одинаковым ключом), порядок итерации по элементам не изменяется.

#### В чем проявляется «сортированность» `SortedMap`, кроме того, что `toString()` выводит все элементы по порядку? [X]

Так же оно проявляется при итерации по коллекции.

#### Как устроен `HashMap`? [X]

`HashMap` состоит из «корзин» (bucket). С технической точки зрения «корзины» — это элементы массива, которые хранят ссылки на списки элементов. При добавлении новой пары «ключ-значение», вычисляет хэш-код ключа, на основании которого вычисляется номер корзины (номер ячейки массива) при помощи хэш функции, в которую попадет новый элемент. 

До Java 8.

```java
int hash = key.hashCode();
int index = (table.length - 1) & hash;
```

После Java 8.

```java
int hash = key.hashCode();
hash ^= (hash >>> 16);
int index = (table.length - 1) & hash;
```

Если корзина пустая, то в нее сохраняется ссылка на вновь добавляемый элемент, если же там уже есть элемент, то происходит последовательный переход по ссылкам между элементами в цепочке, в поисках последнего элемента, от которого и ставится ссылка на вновь добавленный элемент. Если в списке был найден элемент с таким же ключом, то он заменяется.

#### Согласно Кнуту и Кормену существует две основных реализации хэш-таблицы: на основе открытой адресации и на основе метода цепочек. Как реализована `HashMap`?

`HashMap` реализован с использованием метода цепочек, т.е. каждой ячейке массива (корзине) соответствует свой связный список и при возникновении коллизии осуществляется добавление нового элемента в этот список.

Для метода цепочек коэффициент заполнения может быть больше 1 и с увеличением числа элементов производительность убывает линейно. Такие таблицы удобно использовать, если заранее неизвестно количество хранимых элементов, либо их может быть достаточно много, что приводит к большим значениям коэффициента заполнения.

Среди методов открытой реализации различают:

- линейное пробирование;
- квадратичное пробирование;
- двойное хэширование.

Недостатки структур с методом открытой адресации:

- Количество элементов в хэш-таблице не может превышать размера массива. По мере увеличения числа элементов и повышения коэффициента заполнения производительность структуры резко падает, поэтому необходимо проводить перехэширование.
- Сложно организовать удаление элемента.
- Первые два метода открытой адресации приводят к проблеме первичной и вторичной группировок.

Преимущества хэш-таблицы с открытой адресацией:

- отсутствие затрат на создание и хранение объектов списка;
- простота организации сериализации/десериализации объекта.

#### Приведи реализации HashMap в Java основанные на методе цепочек [X]

- `java.util.HashMap`

#### Приведи примеры реализации HashMap в Java основанные на открытой адресации [X]

- `java.util.IdentityHashMap`
#### Как работает HashMap при попытке сохранить в него два элемента по ключам с одинаковым hashCode(), но для которых equals() == false? [X]

По значению `hashCode()` вычисляется индекс ячейки массива, в список которой этот элемент будет добавлен. Перед добавлением осуществляется проверка на наличие элементов в этой ячейке. Если элементы с таким `hashCode()` уже присутствует, но их `equals()` методы не равны, то элемент будет добавлен в конец списка.

#### Какое начальное количество корзин в HashMap? [X]

В конструкторе по умолчанию - 16, используя конструкторы с параметрами можно задавать произвольное начальное количество корзин.

#### Какова оценка временной сложности операций над элементами из HashMap? Гарантирует ли HashMap указанную сложность выборки элемента? [X]

В общем случае операции добавления, поиска и удаления элементов в `HashMap` занимают константное время O(1).

Эта сложность не гарантируется, так как если хэш-функция распределяет элементы равномерно, временная сложность остается O(1). Однако, если хэш-функция постоянно возвращает одно и то же значение, все элементы попадают в одну корзину. В Java 8 и выше, когда размер корзины превышает 8 элементов и общее количество элементов в `HashMap` превышает 64, связный список преобразуется в красно-черное дерево, и временная сложность операций становится O(log n).

Таким образом, в случае, когда все элементы имеют одинаковый хэш-код, временная сложность операций может быть:

- O(n) для первых 8 элементов,
- O(log n) для элементов после преобразования в красно-черное дерево, если размер корзины превышает 8 и общее количество элементов в `HashMap` превышает 64.
#### Возможна ли ситуация, когда HashMap выродится в список даже с ключами имеющими разные hashCode()? [X]

Это возможно в случае, если метод (хэш функция), определяющий номер корзины будет возвращать одинаковые значения. Притянутый за уши пример:

Допустим, `HashMap` имеет размер `n = 8` (8 бакетов).  
Индекс бакета вычисляется так:  `index = (n - 1) & hash` → `index = 7 & hash`.

|Объект|Хеш-код (`hash`)|`hash & 7` (индекс)|
|---|---|---|
|`"A"`|`65`|`65 & 7 = 1`|
|`"Q"`|`81`|`81 & 7 = 1`|
|`"a"`|`97`|`97 & 7 = 1`|

Итог: Все три ключа попадают в бакет `1`, хотя их хеш-коды (`65`, `81`, `97`) разные.
#### В каком случае может быть потерян элемент в HashMap? [X]

Допустим, в качестве ключа используется не примитив, а объект с несколькими полями. После добавления элемента в `HashMap` у объекта, который выступает в качестве ключа, изменяют одно поле, которое участвует в вычислении хэш-кода. В результате при попытке найти данный элемент по исходному ключу, будет происходить обращение к правильной корзине, а вот `equals` уже не найдет указанный ключ в списке элементов. Тем не менее, даже если `equals` реализован таким образом, что изменение данного поля объекта не влияет на результат, то после увеличения размера корзин и пересчета хэш-кодов элементов, указанный элемент, с измененным значением поля, с большой долей вероятности попадет в совершенно другую корзину и тогда уже потеряется совсем.

#### Почему нельзя использовать byte[] в качестве ключа в HashMap? [X]

Хэш-код массива не зависит от хранимых в нем элементов, а присваивается при создании массива (метод вычисления хэш-кода массива не переопределен и вычисляется по стандартному `Object.hashCode()` на основании адреса массива). Так же у массивов не переопределен `equals` и выполняется сравнение указателей. Это приводит к тому, что обратиться к сохраненному с ключом-массивом элементу не получится при использовании другого массива такого же размера и с такими же элементами, доступ можно осуществить лишь в одном случае — при использовании той же самой ссылки на массив, что использовалась для сохранения элемента.

#### Какова роль equals() и hashCode() в HashMap? [X]

`hashCode` позволяет определить корзину для поиска элемента, а `equals` используется для сравнения ключей элементов в списке корзины и искомого ключа.

#### Каково максимальное число значений hashCode()? [X]

Число значений следует из сигнатуры `int hashCode()` и равно диапазону типа `int` — 2^32.

#### Какое худшее время работы метода get(key) для ключа, который есть в HashMap? [X]

O(N). Худший случай - это поиск ключа в `HashMap`, вырожденного в список по причине совпадения ключей по `hashCode()` и для выяснения хранится ли элемент с определённым ключом может потребоваться перебор всего списка.

#### Сколько переходов происходит в момент вызова HashMap.get(key) по ключу, который есть в таблице? [X]

- ключ равен `null`: **1** - выполняется единственный метод `getForNullKey()`.
- любой ключ отличный от `null`: **4** - вычисление хэш-кода ключа; определение номера корзины; поиск значения; возврат значения.

#### Сколько создается новых объектов, когда вы добавляете новый элемент в HashMap? [X]

Один новый объект статического вложенного класса Entry<K,V>.

#### Как и когда происходит увеличение количества корзин в HashMap? [X]

Помимо `capacity` у `HashMap` есть еще поле `loadFactor`, на основании которого, вычисляется предельное количество занятых корзин `capacity * loadFactor`. По умолчанию `loadFactor = 0.75`. По достижению предельного значения, число корзин увеличивается в 2 раза и для всех хранимых элементов вычисляется новое «местоположение» с учетом нового числа корзин -> [rehashing](https://stackoverflow.com/questions/10655239/rehashing-process-in-hashmap-or-hashtable).

#### Объясните смысл параметров в конструкторе HashMap(int initialCapacity, float loadFactor) [X]

- `initialCapacity` - исходный размер `HashMap`, количество корзин в хэш-таблице в момент её создания.
- `loadFactor` - коэффициент заполнения `HashMap`, при превышении которого происходит увеличение количества корзин и автоматическое перехэширование. Равен отношению числа уже хранимых элементов в таблице к её размеру.

#### Будет ли работать HashMap, если все добавляемые ключи будут иметь одинаковый hashCode()? [X]

Да, будет, но в этом случае `HashMap` вырождается в связный список и теряет свои преимущества.

#### Как перебрать все ключи `Map`? [X]

Использовать метод `keySet()`, который возвращает множество `Set<K>` ключей.

#### Как перебрать все значения Map? [X]

Использовать метод `values()`, который возвращает коллекцию `Collection<V>` значений.

#### Как перебрать все пары «ключ-значение» в Map? [X]

Использовать метод `entrySet()`, который возвращает множество `Set<Map.Entry<K, V>` пар «ключ-значение».

#### В чем отличия TreeSet и HashSet? [X]

`TreeSet` обеспечивает упорядоченно хранение элементов в виде красно-черного дерева. Сложность выполнения основных операций не хуже _O(log(N))_ (Логарифмическое время). Нужна реализация Comparable или Comparator.

`HashSet` использует вложенную `HashMap`, каждый элемент выступает как ключ в базовом. В качестве значения (`value`) используется статический объект `PRESENT`. Этот подход позволяет использовать `HashSet` без необходимости хранить дополнительные данные в качестве значений. Благодаря этому и уникальность множества, при использовании ключа мапы.

#### Что будет, если добавлять элементы в TreeSet по возрастанию? [X]

В основе `TreeSet` лежит красно-черное дерево, которое умеет само себя балансировать. В итоге, `TreeSet` все равно в каком порядке вы добавляете в него элементы, преимущества этой структуры данных будут сохраняться.

#### Чем LinkedHashSet отличается от HashSet? [X]

`LinkedHashSet` отличается от `HashSet` только тем, что в его основе лежит `LinkedHashMap` вместо `HashMap`. Благодаря этому порядок элементов при обходе коллекции является идентичным порядку добавления элементов (insertion-order). При добавлении элемента, который уже присутствует в `LinkedHashSet` (т.е. с одинаковым ключом), порядок обхода элементов не изменяется.

#### Для Enum есть специальный класс java.util.EnumSet. Зачем? Чем авторов не устраивал HashSet или TreeSet? [X]

`EnumSet` - это реализация интерфейса `Set` для использования с перечислениями (`Enum`). В структуре данных хранятся объекты только одного типа `Enum`, указываемого при создании. Для хранения значений `EnumSet` использует массив битов (_bit vector_), - это позволяет получить высокую компактность и эффективность. Проход по `EnumSet` осуществляется согласно порядку объявления элементов перечисления.

Все основные операции выполняются за _O(1)_ и обычно (но негарантированно) быстрей аналогов из `HashSet`, а пакетные операции (_bulk operations_), такие как `containsAll()` и `retainAll()` выполняются даже горазда быстрей.

Помимо всего `EnumSet` предоставляет множество статических методов инициализации для упрощенного и удобного создания экземпляров.

#### Каким образом можно получить синхронизированные объекты стандартных коллекций? [X]

С помощью статических методов `synchronizedMap()` и `synchronizedList()` класса `Collections`. Данные методы возвращают синхронизированный декоратор переданной коллекции. При этом все равно в случае обхода по коллекции требуется ручная синхронизация.

```java
Map m = Collections.synchronizedMap(new HashMap());
List l = Collections.synchronizedList(new ArrayList());
```

Начиная с Java 6 JCF был расширен специальными коллекциями, поддерживающими многопоточный доступ, такими как `CopyOnWriteArrayList` и `ConcurrentHashMap`.

#### Как получить коллекцию только для чтения? [X]

При помощи:

- `Collections.unmodifiableList(list)`;
- `Collections.unmodifiableSet(set)`;
- `Collections.unmodifiableMap(map)`.

Эти методы принимают коллекцию в качестве параметра, и возвращают коллекцию только для чтения с теми же элементами внутри.

#### Напишите однопоточную программу, которая заставляет коллекцию выбросить `ConcurrentModificationException` [X]

```java
public static void main(String[] args) {
    List<Integer> list = new ArrayList<>();
    list.add(1);
    list.add(2);
    list.add(3);

    for (Integer integer : list) {
        list.remove(1);
    }
}
```

#### Приведите пример, когда какая-либо коллекция выбрасывает UnsupportedOperationException [x]

```java
public static void main(String[] args) {
    List<Integer> list = Collections.emptyList();
    List<String> unmodifiableList = Collections.unmodifiableList(mutableList);
    List<String> singletonList = Collections.singletonList("Element 1");
    
    list.add(0);
    unmodifiableList.add(0);
    singletonList.add(0);
}
```

#### Как одной строчкой скопировать элементы любой collection в массив?

```java
Object[] array = collection.toArray();
```

#### Как одним вызовом из List получить List со всеми элементами, кроме первых и последних 3-х? [X]

```java
List<Integer> subList = list.subList(3, list.size() - 3);
```
#### Сделайте HashSet из ключей HashMap

```java
HashSet<Object> set = new HashSet<>(map.keySet());
```

#### Какие коллекции позволяют дублировать, какие не позволяют? [X]

Позволяют List, Deque
Не позволяют Set, Map (key)
#### Какова основная идея хэш-таблиц и как они работают? [X]

-  Словарь, ключ-значение.
- Хранение в бакетах по индексам — Каждый ключ преобразуется с помощью хэш-функции в числовой индекс.
- Рехеширование — Когда количество элементов в хэш-таблице превышает Load Factor, размер таблицы увеличивается, и данные распределяются заново, чтобы уменьшить количество коллизий.
- Load Factor (коэффициент загрузки) — Это отношение количества элементов к количеству бакетов в хэш-таблице. По умолчанию 0.75
- Коллизии — Когда два разных ключа генерируют один и тот же хэш-индекс, возникает коллизия. Хэш-таблицы решают это с помощью методов вроде цепочек (связные списки в бакетах) или открытой адресации (поиск другого свободного места в таблице).
- Хэш-функция — Преобразует хэш код в хэш индекс.
- Производительность — В среднем время составляет **O(1)**, но в худшем случае, при множественных коллизиях, может стать **O(n)**.

#### Difference between HashMap and TreeMap

 [TreeMap](https://www.geeksforgeeks.org/treemap-in-java/) offers ****O(log N)**** lookup and insertion. Keys are ordered, so if you need to iterate through the keys in sorted order, you can. This means that keys must implement the Comparable interface. TreeMap is implemented by a [Red-Black Tree](https://www.geeksforgeeks.org/red-black-tree-set-1-introduction-2/).

[HashMap](https://www.geeksforgeeks.org/java-util-hashmap-in-java-with-examples/) offers ****0(1)**** lookup and insertion. If you iterate through the keys, though, the ordering of the keys is essentially arbitrary. It is implemented by an array of [linked list](https://www.geeksforgeeks.org/linked-list-in-java/)s.

![[../../../../_res/Pasted image 20241202110836.png]]

#### Какие есть неизменяемые коллекции

```java
Map<String, String> unmodifiableMap = Collections.unmodifiableMap(modifiableMap);
Map<String, String> immutableMap = Map.of("name1", "Michael", "name2", "Harry");
Map<String, String> copyOfImmutableMap = Map.copyOf(immutableMap);
```

#### Различия между Collections.unmodifiable... и List.of()/Set.of() и их применение. [X]

- [Creating Unmodifiable Lists, Sets, and Maps](https://docs.oracle.com/en/java/javase/17/core/creating-immutable-lists-sets-and-maps.html#GUID-6A9BAE41-A1AD-4AA1-AF1A-A8FC99A14199)
- In java 8:
```java
List<String> stringList = Arrays.asList("a", "b", "c");
stringList = Collections.unmodifiableList(stringList);
```
- in java 9:
```java
List<String> stringList = List.of("a", "b", "c");
```
- copy to unmodifiable collection
```java
List<Item> snapshot = List.copyOf(list);
```
- creating Unmodifiable Collections from Streams
```java
Collectors.toUnmodifiableList() Collectors.toUnmodifiableSet() Collectors.toUnmodifiableMap(keyMapper, valueMapper)     Collectors.toUnmodifiableMap(keyMapper, valueMapper, mergeFunction)
```
- The collections returned by the convenience factory methods added in JDK 9 are unmodifiable. Any attempt to add, set, or remove elements from these collections causes an **UnsupportedOperationException** to be thrown.

#### TreeSet vs. HashSet [X]

- HashSet can store null objects, while TreeSet does not allow them
- TreeSet is rich in functionalities, implementing additional methods like:
	- pollFirst() – to return the first element, or null if Set is empty
	- pollLast() – to retrieve and remove the last element, or return null if Set is empty
	- first() – to return the first item
	- last() – to return the last item
	- ceiling() – to return the least element greater than or equal to the given element, or null if there is no such element
	- lower() – to return the largest element strictly less than the given element, or null if there is no such element

#### Какие основные различия между HashMap и TreeMap? [X]

- HashMap:
    - Основан на хэш-таблице.
    - Не гарантирует порядок элементов.
    - В среднем обеспечивает O(1) для операций вставки, удаления и поиска.
        
- TreeMap:
    - Основан на красно-черном дереве.
    - Элементы сортируются по ключам (естественный порядок или через `Comparator`).
    - Обеспечивает O(log n) для операций вставки, удаления и поиска.

#### Что такое перестроение (rehashing) [X]

При добавлении в хеш-таблицу большого количества элементов могут возникнуть ухудшения в ее работе. Обработка любого вызова будет занимать больше времени из-за увеличения размеров цепочек при хешировании на списках или кластеризации при хешировании с открытой адресацией, также, при хешировании с открытой адресацией может произойти переполнение таблицы. Для избежания таких ситуаций используется выбор новой хеш-функции и (или) хеш-таблица большего размера. Этот процесс называется [перехеширование](https://neerc.ifmo.ru/wiki/index.php?title=Перехеширование) (_rehashing_).
#### Как происходит перестроение (rehashing) в HashMap? [X]

При добавлении нового элемента:

```java
if (size > threshold) {  // threshold = capacity * loadFactor
    resize();  // Запускается перестроение
}
```

- `size` — текущее количество элементов.
- `threshold` — максимальное число элементов до перестроения.
    
Увеличение размера таблицы:

- Размер увеличивается в 2 раза (например, с `16` до `32`).  
- Новый `threshold` пересчитывается (`32 * 0.75 = 24`).

Перераспределение элементов:

1. Создается новая таблица увеличенного размера.
2. Все существующие элементы пересчитываются:
    - Для каждого элемента вычисляется новый индекс (`newIndex = (newCapacity - 1) & hash`).
    - Элементы перемещаются в новые бакеты.

Пример пересчета индекса

- Старый размер: `16` → маска `15` (`1111`).
- Новый размер: `32` → маска `31` (`11111`).

|Ключ|Хеш (`hash`)|Старый индекс (`hash & 15`)|Новый индекс (`hash & 31`)|
|---|---|---|---|
|`"A"`|`65` (`01000001`)|`1` (`0001`)|`1` (`00001`)|
|`"Q"`|`81` (`01010001`)|`1` (`0001`)|`17` (`10001`)|

Что изменилось?
- `"A"` остался в бакете `1`.
- `"Q"` переместился в бакет `17` (из-за дополнительного бита в маске).
#### Во сколько раз увеличивается ArrayList при заполнении? Что если выставить capacity 1? [X]

```java
newCapacity = oldCapacity + (oldCapacity >> 1) newCapacity = 1 + (1 >> 1) = 1 + 0 = 1
```

Но емкость не может остаться той же, поэтому срабатывает минимальное увеличение до 2.
#### Каковы особенности реализации и применения хэш-таблиц с открытой адресацией по сравнению с методом цепочек? [X]

Иногда разные ключи могут указывать на одно и то же место. Например, хэш-функция может дать один и тот же "адрес" (индекс) для двух разных ключей. Это называется коллизией, и есть два основных способа её решить:

Метод цепочек. HashMap, HashTable. В этом методе каждый "индекс" таблицы ведёт к списку (или цепочке) элементов, которые попали в одно и то же место. Если у нас несколько ключей с одинаковым индексом, мы просто добавляем их в этот список.

Открытая адресация. Свой класс. Здесь мы решаем коллизии не с помощью цепочек, а поиском свободного места в самой таблице. Если при добавлении новый элемент попадает на занятое место, мы ищем следующую свободную ячейку, куда его можно вставить. Есть несколько способов поиска

#### Чем ConcurrentHashMap отличается от HashTable? [X]

-  ConcurrentHashMap: Поддерживает параллельные операции (блокировка на уровне сегментов/buckets)
- HashTable: Глобальная блокировка (медленнее), потокобезопасность за счет синхронизации всех методов
#### Какие проблемы возникнут, если была переопределена хэш-code и теперь всегда возвращает константу? [X]

- Деградация производительности:
    - `HashMap`: O(1) → O(n) (цепочка коллизий) → O(log n) (при преобразовании в дерево).
    - `HashSet`: Аналогично.
- Нарушение контракта `hashCode`-`equals`: Объекты с разными `equals` будут считаться одинаковыми.
#### Как правильно реализовать хэш-code, какие требования? [X]

1. Консистентность: Если `equals()` не изменился, `hashCode()` должен возвращать то же значение.
2. Равенство по `equals` → одинаковый `hashCode`.
3. Разные `hashCode` → объекты могут быть неравными (но желательно минимизировать коллизии).
4. Используйте `Objects.hash()` для удобства
#### Разница между Set и List?

- Set: уникальные элементы, не гарантирует порядок (кроме `LinkedHashSet`/`TreeSet`), основан на `HashMap`/`TreeMap`
- List: Дубликаты разрешены, сохраняет порядок вставки

#### Какова сложность поиска элементов в HashMap? [X]

- **В среднем**: O(1) (хороший `hashCode`).
- **В худшем случае**: O(n) (все элементы в одной корзине) → O(log n) (если преобразовано в дерево).
#### Можно ли в HashMap положить ключ null? [X]

- Да, можно (`HashMap` разрешает один `null`-ключ).
- `Hashtable` и `ConcurrentHashMap`, TreeMap — нет.

#### Для чего нужны wildcard в дженериках? [X]

- **`<?>`**: Любой тип (но нельзя добавлять элементы). Компилятор не знает точный тип `?`, поэтому запрещает добавление **любых** элементов (кроме `null`, который совместим со всеми типами).
- **`<? extends T>`**: Ковариантность (чтение).
- **`<? super T>`**: Контравариантность (запись).
#### Корректно ли такое присваивание `List<Number> list = new ArrayList<Integer>();`? [X]

- **Некорректно** (из-за инвариантности дженериков).

```java
List<? extends Number> list = new ArrayList<Integer>();
```

#### Есть массив с типом Number и есть лист с типом Number, что мы можем положить в массив, а что можем положить в List? [X]

```java
Number[] arr = new Integer[10]; // OK (ковариантность)
arr[0] = 1.0; // ArrayStoreException

List<Number> list = new ArrayList<Integer>();
```

#### При вставке в середину листа N количество, элементов, какой реализацией листа лучше воспользоваться и почему? [X]

- **`LinkedList`**: O(1) для вставки начало/конец (но O(n) для поиска позиции в остальных случаях).
- **`ArrayList`**: O(1), но при переполнение внутреннего массива - O(n) (сдвиг элементов, однако используется быстрый System.arraycopy(), копирует старый в новый массив).
#### В каких ситуациях ArrayList будет точно быстрее? [X]

- Random access: `get(i)` — O(1).
- Кэш-локальность: Данные в памяти последовательны.
- Итерация: Быстрее `LinkedList`.


## Resources 

- [Java Collection Framework: Полное руководство для разработчиков](https://struchkov.dev/blog/ru/java-collection-framework/)
- [Структуры данных в картинках. HashMap](https://habr.com/ru/articles/128017/)
- [Структуры данных в картинках. ArrayList](https://habr.com/ru/articles/128269/)