## QA

### Монолиты и микросервисы
###### Плюсы и минусы микросервисов и монолитов

- Тесты. Интеграционные легче в монолите, юнит в микрах;
- Консистентность данных. Микросервисы могут иметь разны базы, нужно приводить к согласонванности;
- Транзакции. В микрах нужно работать с распределенными транзакциями;
- Масштабирование. В миках мы можем масштабировать отдельные части;
- Скорость деплоя. В случе монолоита при изменение одной части, нам нужно передплоить весь монолит;
- Сложность управления. Микры сложнее упралвять из-за их большого количества.
###### В каких случаях предпочтительно использовать монолитную архитектуру?

- Монолит подходит для стартапов, когда ресурсы ограничены.
###### Какие паттерны разбиения монолита на микросервисы ты знаешь?

- **Шаблон «Душитель» (Strangler)**

Этот шаблон означает миграцию монолитного приложения на микросервисную архитектуру путем постепенного переноса существующих функций в микросервисы. Настраивается маршрутизация запросов между устаревшим монолитом и микросервисами. Когда очередная функциональность переносится из монолита в микросервисы, фасад перехватывает клиентский запрос и направляет его к микросервисам. Новые функции при этом реализуются исключительно в микросервисах, минуя монолит. После переноса всех функций монолитное приложение полностью выводится из эксплуатации.

Паттерн "душитель" (Throttling) используется для ограничения количества запросов или событий, которые система может обрабатывать за определённый период времени. Он предотвращает перегрузку системы и может быть полезен при работе с внешними сервисами или при защите от пиковых нагрузок.

Пример: [[../../../_inforage/Patterns/Storage/Microservices/Integration/API Gateway]] может ограничить количество запросов, которые клиент может отправить на сервер в течение минуты, чтобы избежать перегрузки.

- **Шаблон «Уровень защиты от повреждений» (Anti-Corruption Layer)**

Для таких случаев отлично подходит паттерн Anti-Corruption Layer. Он предназначен для изолирования различных подсистем путем размещения между ними дополнительного уровня, который может быть реализован как компонент приложения или независимая служба. Этот уровень связывает две подсистемы, позволяя им оставаться максимально независимыми друг от друга. Он содержит всю логику, необходимую для передачи данных в обе стороны: при взаимодействии с каждой из подсистем используется именно ее модель данных.

- Цитадель (состояние когда есть монолит вокруг него микросервисы)

### Паттерны микросервисной архитектуры

###### Какие виды паттернов микросервисной архитектуры знаешь?

- Разбиение 
- Декомпозиция
- Отказоустойчивость
- Деплой
- Управление данными
- Распределенные транзакции
- Мониторинга
- Гарантии доставки
- Обнаружение
###### Какие паттерны декомпозиции на микросервисы ты знаешь

- Шаблон «Разбиение по бизнес-возможностям» (Decompose By Business Capability)
- Шаблон «Разбиение по поддоменам» (Decompose By Subdomain)

###### Паттерны мониторинга микросервисов

- **«Агрегация логов» (Log Aggregation)** предлагает использовать централизованную службу ведения логов, которая будет собирать логи от каждого экземпляра сервиса. Это предоставит пользователям единую точку для поиска, анализа логов и настройки предупреждений, которые будут запускаться при появлении в них определенных сообщений.
- **«Распределенная трассировка» (Distributed Tracing)**  Он предлагает назначать каждому внешнему запросу уникальный идентификатор (TraceId), который будет передаваться всем сервисам, участвующим в обработке запроса, и фиксироваться в журналах. Это позволит разработчикам видеть, как обрабатывается отдельный запрос, путем поиска в агрегированных журналах его внешнего идентификатора.
- **«Проверки здоровья» (Health Check)** Он предлагает определить для каждого сервиса конечную точку, которую можно использовать для проверки работоспособности, например /health. Этот API должен проверять статус хоста, подключение к другим сервисам, инфраструктуре и любую иную бизнес-логику.
###### Какие паттерны деплоймента знаешь?

-	**Blue-green deploy** – 2 среды развертывания – blue – основной рабочий проект, green – новая версия, стратегия в том, что б начинать перенаправлять трафик на green проект для его тестирования, если проект упадет – вернуть трафик на blue, исправить green, если blue cправляется успешно – заменить blue – green 
-	Canary-deploy – предоставление новой версии для ограниченного кол-во пользователей.
-	Rolling deployment – поочередное развертывание на разных серверах.
-	Feature toggled – внедрение нового функционала сразу в рабочую версию, при помощи флага функционал отключается до тех пор, пока не убедятся в его правильности.
-	Shadow deployment – теневое развертывание, использует 2 среды, первая основная, другая тестовая , запросы с основной дублируются на теневую для проверки работоспособности.
-	Recreate deployment – удалить старую – вставить новую.
###### Какие паттерны распределенных транзакций знаешь?

- SAGA
- 2/3 phase commit

###### Что за паттерн SAGA, и как есть его виды

Он представляет собой последовательность локальных транзакций, где каждый сервис выполняет свою транзакцию и публикует событие. Другие сервисы слушают эти события и выполняют следующие локальные транзакции. Если одна из транзакций завершается неудачно, SAGA также выполняет компенсирующие транзакции для отмены эффекта предыдущих транзакций.

Пример. Банк одобряет кредит, страховая компания проверяет клиента, а система логистики доставляет товар. Виды подхода:

- В **Orchestration-Based Saga** есть центральный "дирижер", который координирует все эти шаги. Если на каком-то этапе возникает проблема, "дирижер" может перенаправить процесс или повторить шаги.
- **Choreography-Based Saga**. Когда банк одобряет кредит, он публикует событие. Страховая компания реагирует на это событие и проверяет клиента. Система логистики реагирует на событие от страховой компании и доставляет товар. Если что-то идет не так, каждый сервис решает проблему самостоятельно, и процесс продолжается.
###### Что такое 2-х фазный и как он работает

- [2/3 phase commit](../../../_inforage/Patterns/Storage/Microservices/Data/2-phase-commit.md)
###### Что такое паттерн outbox, в чем его отличие от паттерна Saga

- [[../../../_inforage/Patterns/Storage/Microservices/Data/Transactional Out Box]]
- [[../../../_inforage/Patterns/Storage/Microservices/Data/SAGA]]
- Основное отличие заключается в том, что паттерн Outbox фокусируется на надежной доставке сообщений, **используя базу данных для хранения**, а Saga управляет распределенными транзакциями, **разбивая их** на более мелкие операции с **возможностью компенсации**.

###### Какие паттерны отказоустойчивости знешь?

- **«Автоматический выключатель» (Circuit Breaker)**
- «Герметичные отсеки» (Bulkhead) -  Пример — использование отдельного пула соединений для каждого из нижестоящих сервисов. Еще один вариант использования шаблона — назначение каждому клиенту сервиса отдельного экземпляра сервиса.
- Fallback
- Timeout
- Rate limiter
- Retry

```java
@CircuitBreaker(name= "licenseService",
fallbackMethod= "buildFallbackLicenseList")
@RateLimiter(name = "licenseService",
fallbackMethod = "buildFallbackLicenseList")
@Retry(name = "retryLicenseService",
fallbackMethod = "buildFallbackLicenseList")
@Bulkhead(name= "bulkheadLicenseService",
fallbackMethod= "buildFallbackLicenseList")
public List<License> getLicensesByOrganization(String organizationId)
	throws TimeoutException {
	logger.debug("getLicensesByOrganization Correlation id: {}",
	UserContextHolder.getContext().getCorrelationId());
	randomlyRunLong();
	return licenseRepository.findByOrganizationId(organizationId);
}

private List<License> buildFallbackLicenseList(String organizationId, Throwable t){
	List<License> fallbackList = new ArrayList<>();
	License license = new License();
	license.setLicenseId("0000000-00-00000");
	license.setOrganizationId(organizationId);
	license.setProductName(
	"Sorry no licensing information currently available");
	fallbackList.add(license);
	return fallbackList;
}
```
###### Как работает Circuit Breaker?

![[../../../_inforage/Patterns/Storage/Microservices/Fault tolerance/Circuit Breaker#Кратко]]

###### Паттерны гарантии доставки

- In/out box
###### Какие паттерны по управлению данными существуют?

- **Database Per Service**
- **API Composition**
- **Command Query Responsibility Segregation, CQRS**
- **Event Sourcing**

###### Паттерны обнаружения сервисов в микросервисной архитектуре

- **Client-Side Service Discovery**
- **Server-Side Service Discovery**
###### В чем разница между гексагональной архитектурой и Onion

- [[../../../_inforage/Microservices/Storage/Onion архитектура]]
- [[../../../_inforage/Microservices/Storage/Гексагональная архитектура]]

###### Что такое CQRS?

- [CQRS](../../../_inforage/Patterns/Storage/Microservices/Data/CQRS.md)
###### Как реализовать CQRS на практике?

- [Two Micro](https://fullstackdeveloper.guru/2023/05/04/how-to-implement-cqrs-design-pattern-in-spring-boot/)
- [One Micro - Postgre Command & Elasticsearch Query](https://github.com/yusufyilmazfr/cqrs-design-pattern-java/tree/main)
- Если в одном сервисе и к одной Postgre, опеределяем два Datasource, два TransactionManager. На запись как Primary, на чтение явное указание в @Transactional.

###### Паттерн - селективность в бд

- [[../../../_inforage/Patterns/Storage/Database/Cелективность]]
###### Что такое CAP-теорема, как она соблюдается?

- [CAP](../../../_inforage/Microservices/Storage/CAP%20-%20теорема.md)
###### Что обозначает PACELC?

- **P** — Partition Tolerance (Терпимость к разделению): система должна продолжать работать, даже если часть сети недоступна или разделена.
- **A** — Availability (Доступность): система должна гарантировать, что каждый запрос получит ответ (независимо от того, является ли результат успешным или нет).
- **E** — Else (Иначе): дополнительный фактор, который используется для обозначения компромисса, который должен быть принят, когда система не делится, то есть в обычном рабочем состоянии.
- **L** — Latency (Задержка): насколько быстро система отвечает на запросы.
- **C** — Consistency (Согласованность) снова.
- **P — A / E — L**: В случае отказа сети система выбирает между доступностью и согласованностью, а когда сеть работает нормально, она минимизирует задержку в обмен на согласованность.
###### Какие еще есть паттерны в бд?

- **Шардирование** (Sharding): Разделение больших таблиц на более мелкие части к примеру по id, локации, дате актуальности, чтобы распределить данные по разным физическим серверам и улучшить масштабируемость.
- Кэширование (Caching): Хранение часто запрашиваемых данных в быстрых хранилищах (например, Redis), чтобы уменьшить нагрузку на основную базу данных.
- **Репликация** (Replication): Создание копий базы данных на нескольких серверах для повышения доступности и отказоустойчивости.
- Этапное удаление (Soft Delete): Вместо физического удаления данных используется флаг (например, `isDeleted`), чтобы пометить запись как удалённую, но не удалять её из базы. К примеру используется для создания отчетов.
- Агрегаты (Aggregate Pattern): Группировка данных, связанных с одной сущностью (например, заказа и его элементов), для упрощения работы с ними.
- Вычисляемые колонки (Computed/Derived Columns): Колонки, которые хранятся в базе и содержат результаты вычислений на основе других полей.
- Паттерн Table Inheritance: Представление иерархии классов в базе данных с помощью разных таблиц для базового и производных классов.
- Event Sourcing: Хранение событий изменения данных вместо их текущего состояния для обеспечения отслеживаемости изменений и их восстановления.
- [[../../../_inforage/Patterns/Storage/Microservices/Data/CQRS]]: Разделение операций чтения и записи на отдельные модели, оптимизированные для своих целей.
- Паттерн Locking (Блокировки): Использование механизмов блокировки данных (например, пессимистическая или оптимистическая блокировка) для управления конкурентным доступом к данным.

###### Если у нас кол-во данных в бд растет, добавление индексов уже не помогает. Что делать в данном случае?

- Шардирование (Sharding): Разделение базы данных на несколько частей (шардов) по какому-то ключу, например, по ID пользователя. Это позволяет распределить данные и нагрузку на несколько серверов, уменьшая размер каждого отдельного сегмента базы данных.
- Архивирование данных: Старые или редко используемые данные можно переместить в архивные таблицы или отдельную базу данных. 
- Кэширование (Caching): Использование систем кэширования (например, Redis или Memcached) для хранения результатов частых запросов в памяти. Это снижает нагрузку на базу данных и ускоряет доступ к часто используемым данным.
- [[../../../_inforage/Базы_данных/Storage/Денормализация]]
- Использование распределенных баз данных: Переход на распределённые базы данных, такие как Cassandra, MongoDB, HBase, которые предназначены для работы с большими объёмами данных и масштабирования.
- Репликация (Replication): Запросы на чтение обрабатывались репликами, снижая нагрузку на основной сервер. Это также повышает отказоустойчивость.
- Масштабирование вертикальное и горизонтальное:
	- Вертикальное масштабирование: Увеличение ресурсов одного сервера базы данных (добавление оперативной памяти, процессоров, дисков).
	- Горизонтальное масштабирование: Распределение данных и нагрузки на несколько серверов (например, с использованием шардирования или кластеров).
-  Пересмотр и переписывание запросов для их оптимизации. Это может включать:
	- Избегание сложных операций `JOIN` и подзапросов.
	- Минимизация выборки данных (использование только необходимых полей).
	- Проверка использования индексов в запросах с помощью инструментов профилирования.
- Инвертированные индексы или полнотекстовые индексы: Если у вас много текстовых данных, то можно использовать полнотекстовые индексы для ускорения поиска по тексту.
- Использование очередей: Для операций записи, которые не требуют моментального завершения, можно использовать очереди (например, Kafka или RabbitMQ). Это позволяет разгрузить базу данных и распределить нагрузку во времени.
- В зависимости от типа данных, можно рассмотреть использование других типов баз данных:
	- Базы данных для OLAP (например, ClickHouse, Amazon Redshift) для аналитических запросов.
	- Временные базы данных (Time-Series, такие как InfluxDB) для данных, которые хранятся по времени.
	- Документоориентированные или ключ-значение базы данных для неструктурированных данных (MongoDB, DynamoDB, Redis).
###### Партиция в бд

- [[../../../_inforage/Базы_данных/Storage/Partition DB]]
###### Если начать разрабатывать масштабное приложение, как бы ты это делал?

###### Что такое паттерн change data capture? CDC - outbox with debezium without scheduler

- [Kafka Connect, Debezium и OUTBOX pattern](https://www.youtube.com/watch?v=EP1i4fowjjg)
### Мониторинг
###### Micrometer vs Actuator

###### TraceId и SpanId что за что отвечает, и как (где) передаются от сервиса к сервису

- **TraceId** — уникальный идентификатор для одного запроса, который связывает все операции и взаимодействия между микросервисами, относящиеся к одному запросу.
- **SpanId** — уникальный идентификатор для каждой операции или подзадачи, выполняемой в рамках одного запроса.
###### Журналирование, логирование с MDC контекстом

MDC — это ключ-значение пара, которая хранится в **потоке** (thread) и доступна для всех логируемых сообщений в рамках этого потока. Этот контекст может быть использован для добавления информации, которая будет автоматически включена в логи, например:

- **TraceId** и **SpanId** для распределенного трассирования.
- Идентификатор пользователя, сессии или устройства.
- Название приложения, версии и другие метаданные.

###### Как анализировал и решал проблемы с производительностью микросервисов? (мониторинг, анализ запросов, оптимизация).

######  Приходит тестировщик или сотрудник второй линии и говорит что сервис медленно работает, вроде ничего не произошло. С чего бы ты начал свой анализ?

###### Как можно производить инвалидацию кэша?

### Прочее

#### В чем разница между процессами ETL и ELT

- [[../../../_inforage/Microservices/Storage/ETL vs ELT]]

#### Архитектура Data Warehouse и Data Lake

- [[../../../_inforage/Microservices/Storage/Архитектура Data Warehouse и Data Lake]]

#### Что такое DDD (Domain-Driven Design) и для чего он используется?

## Resources

- [26 основных паттернов микросервисной разработки](https://cloud.vk.com/blog/26-osnovnyh-patternov-mikroservisnoj-razrabotki/)
- 