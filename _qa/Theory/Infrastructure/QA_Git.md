#### Что такое GIT? [X]

Git — это распределённая система контроля версий (VCS), которая позволяет отслеживать изменения в файлах, работать над проектом в команде и откатываться к предыдущим версиям кода.

#### Что такое коммит [X]

Коммит (commit) — это фиксация изменений в репозитории Git. Каждый коммит содержит:
- Изменения в файлах
- Уникальный хеш (идентификатор)
- Автора
- Сообщение (commit message), описывающее изменения

#### Что такое ветка [X]

Ветка — это независимая линия разработки в Git, которая позволяет работать над разными задачами параллельно, не затрагивая основной код (обычно ветку `main` или `master`).

✅ Параллельная разработка — можно работать над несколькими задачами одновременно. 
✅ Изоляция изменений — эксперименты в feature-ветках не ломают `main`.  
✅ Code Review — удобно проверять изменения перед слиянием.  
✅ Тестирование — можно выкладывать тестовые версии без риска для продакшена.

```bash
git branch feature/new-button  # создаёт ветку, но не переключается на неё
git checkout -b feature/new-button  # создаёт и сразу переключается

git branch -d feature/old  # безопасное удаление (если изменения слиты)
git branch -D feature/old  # принудительное удаление (даже если не слито)

git push origin feature/new-button
```

#### Как посмотреть список веток [X]

```bash
git branch          # локальные ветки
git branch -a       # все ветки (включая удалённые)
```

#### Что такое тег? [X]

Тег (tag) — это метка, отмечающая определённый коммит (например, версию релиза v1.0.0).

```bash
git tag -a v2.0.0 -m "Релиз версии 2.0.0"  # аннотированный тег
git tag hotfix-v1.1.0                       # легковесный тег

git tag                # список всех тегов
git show v1.0.0        # информация о конкретном теге

git push origin v1.0.0          # отправить один тег
git push origin --tags          # отправить все теги
```
#### Как сжать несколько последних коммитов в один ? [X]

- Используется интерактивный rebase:

```bash
git rebase -i HEAD~N  # где N — количество коммитов для объединения
```

В открывшемся редакторе оставить pick у первого коммита, а для остальных поставить squash (или s).

- Через git merge --squash (если коммиты ещё не влиты в основную ветку)
- Через git reset --soft

```bash
git reset --soft HEAD~N  # N — количество коммитов
git commit -m "Объединённый коммит"
```

1. Не сжимайте коммиты, которые уже есть у других разработчиков (это перезапишет историю и вызовет проблемы).
2. Для публичных веток (например, `main`) лучше использовать `git merge --squash`, а не `rebase --interactive`.
#### Что такое конфликт в гите и как его можно разрешить ? [X]

Конфликт возникает, когда Git не может автоматически объединить изменения (например, две ветки изменили одну строку в файле).

1. Открыть файл с конфликтом (будут маркеры `<<<<<<<, =======, >>>>>>>`).
2. Вручную отредактировать нужные участки.
3. Добавить исправленный файл и завершить слияние:

```bash
git add имя_файла
git commit
```

#### Как сделать откат изменений ? [X]

```
Откатить последний коммит (без удаления изменений):
git reset --soft HEAD~1

Откатить коммит и изменения в файлах
git reset --hard HEAD~1

Откатить отдельный файл к состоянию в коммите:
git checkout хеш_коммита -- имя_файла

Отменить изменения в рабочей директории (незакоммиченные):
git restore имя_файла

Если нужно откатить уже отправленный в удалённый репозиторий коммит, лучше использовать `git revert`:
git revert хеш_коммита  # создаст новый коммит, отменяющий изменения
```

#### В чем разница между reset vs revert [X]

- [Сравнение 5 команд Git: revert, checkout, reset, merge и rebase](https://proglib.io/p/sravnenie-5-komand-git-revert-checkout-reset-merge-i-rebase-2020-05-25)
1. git reset
- Полностью удаляет коммит(ы) из истории
- Перемещает указатель ветки на указанный коммит
- Может быть опасным для совместной работы (переписывает историю)
- Требует `git push --force` для отправки изменений в удаленный репозиторий
- Варианты:
    - `--soft` - оставляет изменения в staging area
    - `--mixed` (по умолчанию) - оставляет изменения в рабочей директории
    - `--hard` - полностью удаляет изменения
2. git revert
- Создает новый коммит, который отменяет изменения указанного коммита
- Не удаляет оригинальные коммиты из истории
- Безопасен для совместной работы
- Не требует принудительного пуша
- Сохраняет полную историю изменений
#### Какие есть флаги reset, в чем разница ? [X]

| Флаг                     | Что делает?                                                                 | Где остаются изменения?                          |
| ------------------------ | --------------------------------------------------------------------------- | ------------------------------------------------ |
| `--soft`                 | Отменяет коммит, но оставляет изменения в staging (индексе)                 | `git status` покажет изменения готовые к коммиту |
| `--mixed` (по умолчанию) | Отменяет коммит, оставляет изменения в рабочей директории (но не в индексе) | Нужно снова добавить `git add`                   |
| `--hard`                 | Полностью удаляет коммит и изменения (осторожно!)                           | Безвозвратно стирает изменения                   |
#### Какие состояние файлов есть в гите ? [X]

Отслеживаемое (tracked). Об этих файлах Git знает и отслеживает изменения в них. Отслеживаемые файлы могут быть в следующих состояниях: 
    - Неизменённое (unmodified). С момента последнего коммита в файле не было никаких изменений. 
    - Изменённое (modified). С последнего коммита в файле были произведены какие-то изменения.
    - Подготовленное к коммиту (staged). Это значит, что в файл внесли изменения и затем проиндексировали их, и эти изменения будут добавлены в следующий коммит.
Неотслеживаемое (untracked). О неотслеживаемых файлах Git не знает, поэтому изменения в них не будут добавлены в коммит. Это любые файлы в рабочем каталоге, которые не входили в последний коммит и не подготовлены к текущему коммиту. 
#### Как переключиться на другую ветку в Git и создать новую ветку ? [X]

```
git branch feature/new-button # создаёт
git checkout feature/new-button  # переключается

git checkout -b feature/new-button  # создаёт и сразу переключается

git switch -c новая_ветка # Git 2.23+
```

#### Как можно отменить коммит, уже отправленный в удаленный репозиторий, не удаляя историю коммитов ? [X]

```bash
git revert
```

- Git инвертирует изменения из указанного коммита.
- Создаётся новый коммит с сообщением вида:

```
Revert "Сообщение оригинального коммита"
```

- История не перезаписывается, поэтому коллеги смогут спокойно сделать `git pull`.

#### Что такое stash [X]

- [git stash](https://skillbox.ru/media/code/lokalnoe-khranilishche-git-kak-rabotat-s-git-stash/)
- git stash — это команда, которая позволяет записывать изменения в коде в локальное хранилище и возвращаться к ним позже. И всё это происходит на компьютере, а не в репозитории.
- Базовые команды для git stash — это git stash save, git stash list и git stash apply. Они помогут вам сохранить изменения в хранилище, посмотреть список доступных сохранений и применить их к своему проекту.

#### В чем разница pull vs fetch [X]

- git fetch: Загружает изменения из удаленного репозитория, но не сливает их с локальной веткой.
- git pull: Выполняет `git fetch`, а затем автоматически сливает изменения с текущей веткой. Грубо говоря, по дефолту `git pull` — это shortcut для последовательности двух команд: `git fetch` (получение изменений с сервера) и `git merge` (сливание в локальную копию).

При использовании `fetch`, git собирает все коммиты из целевой ветки, которых нет в текущей ветке, и сохраняет их в локальном репозитории. Однако он не сливает их в текущую ветку. Это особенно полезно, если вам нужно постоянно обновлять свой репозиторий, но вы работаете над функциональностью, неправильная реализация которой может негативно сказаться на проекте в целом. Чтобы слить коммиты в основную ветвь, нужно использовать `merge`.

![[../../../_res/Pasted image 20241206112408.png]]

#### Разница merge vs rebase [X]

| **`git merge`**                                                     | **`git rebase`**                                                         |
| ------------------------------------------------------------------- | ------------------------------------------------------------------------ |
| ✅ Создаёт новый коммит слияния (merge commit)                       | ✅ Перемещает коммиты на верх другой ветки (линейная история)             |
| ✅ Сохраняет историю "как было" (видно ветвление в виде веток метро) | ✅ Делает историю чище (выглядит как последовательная работа)             |
| ✅ Безопаснее для общих веток (не перезаписывает историю)            | ⚠️ Опасен для общих веток (перезаписывает историю, требует `force push`) |
| Команда: `git merge ветка`                                          | Команда: `git rebase ветка`                                              |

#### Если работаем с одной веткой вдвоём и кто-то делает Rabase, что делать? Если он ещё сделал force push?

- Ваша локальная история и удалённая ветка теперь расходятся.
- Обычный `git pull` выдаст ошибку.

Способ 1: Перезаписать свою историю (если ваших коммитов нет в удалённой ветке)

```bash
git fetch origin
git reset --hard origin/ветка  # ⚠️ Удалит ваши локальные изменения!
```

Способ 2: Создать новую ветку и смержить изменения

```bash
git fetch origin
git checkout -b новая-ветка
git merge origin/ветка  # подтягиваем изменения после rebase
```

Способ 3: Перебазировать свою работу поверх новых изменений

```bash
git fetch origin
git rebase origin/ветка  # перемещает ваши коммиты на обновлённую ветку
```
#### Что такое squash и итеративный ребейз? [X]

|**Squash**|**Итеративный ребейз**|
|---|---|
|Только объединяет коммиты|Позволяет также переупорядочивать, редактировать, удалять|
|Делает один новый коммит|Может сохранить несколько коммитов, но в изменённом виде|
|Проще (часто через `merge --squash`)|Гибче (полный контроль над историей)

```shell
git rebase -i HEAD~5  # работаем с последними 5 коммитами
pick a1b2c3 Добавил модель
pick d4e5f6 Исправил баг
pick g7h8i9 Поправил стиль
```

Меняете `pick` на нужное действие:
    - `squash` (`s`) — объединить с предыдущим,
    - `fixup` (`f`) — объединить и удалить сообщение,
    - `edit` (`e`) — остановиться для правки,
    - `drop` (`d`) — удалить коммит.


```shell
git checkout main
git merge --squash feature-branch
git commit -m "Вся feature в одном коммите"
```

#### Что делает команда Cherry Peek [X]

Копирует изменения из одного коммита (из другой ветки) и применяет их в текущей ветке как новый коммит.

- Нужно перенести отдельный фикс из одной ветки в другую (без мержа всей ветки).
- Хотите взять только конкретные изменения из чужого коммита.

#### Какая команда позволяет изменить последний коммит без изменения его содержимого (например, для исправления сообщения коммита) ? [X]

- Позволяет исправить сообщение последнего коммита.
- Или добавить новые изменения в него (если забыли что-то включить).

```bash
git commit --amend
```

Изменить сообщение коммита (без правки кода):

```bash
git commit --amend -m "Новое сообщение"
```

Добавить забытые файлы в последний коммит:

```bash
git add забытый_файл.txt    # добавляем пропущенный файл  
git commit --amend          # откроется редактор для изменения сообщения  
```

- `--amend` перезаписывает историю (меняет хеш коммита).
- Если коммит уже отправлен в удалённый репозиторий, потребуется **`git push --force`** (но это опасно для общих веток!).

#### Какая команда используется для просмотра истории коммитов ? [X]

Показывает историю коммитов в текущей ветке:

```
git log
```

Вывод:
- Хеш коммита (например, `abc123`)
- Автор
- Дата
- Сообщение коммита

Полезные флаги `git log`

|**Флаг**|**Что делает**|**Пример**|
|---|---|---|
|`--oneline`|Краткий вывод (хеш + сообщение)|`git log --oneline`|
|`--graph`|Визуализирует ветвление|`git log --graph`|
|`--all`|Показывает все ветки|`git log --all --graph`|
|`-p`|Показывает изменения в коде (diff)|`git log -p`|
|`-n`|Ограничивает число коммитов (например, `-2`)|`git log -2`|
|`--since/--until`|Фильтр по дате|`git log --since="2024-01-01"`|
|`--author`|Поиск по автору|`git log --author="John"`|
|`--grep`|Поиск по сообщению|`git log --grep="bugfix"`|

#### Что такое force push [X]

- git push --force  # Перезаписывает историю удалённого репозитория.
- **Опасность**: Может удалить коммиты других разработчиков.
- Аналог: git push --force-with-lease  # Отменяет push, если ветка изменилась.

#### Такая ситуация в гите. Если ты сделал cherry pick какого-то файла из ветки другого разработчика, как потом решить проблему сливания обеих веток в главную, не будут ли конфликтовать взятый файл с файлом другого разработчика?

Проблемы:

- Ветка A: Разработчик A вносит изменения в файл `file.txt` и коммитит их.
- Ветка B: Разработчик B делает cherry-pick этих изменений из ветки A, применяя их в своей ветке.
- Ветка A и B сливаются: В какой-то момент обе ветки сливаются в основную ветку, например, в `master`. Теперь Git может обнаружить конфликты, если изменения в `file.txt` в обеих ветках не согласуются.

Решение: 

- Основной способ разрешения — ручное разрешение конфликта при слиянии.
- В некоторых случаях использование `rebase` или других стратегий слияния может уменьшить вероятность конфликтов.