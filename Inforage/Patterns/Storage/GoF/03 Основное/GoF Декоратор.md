---
Определение: Позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки».
Тип:
  - Структурный
пример: Упаковка подарка добавляет украшения, не меняя сам подарок.
---
Wrapper, Обёртка, Decorator

Клиент берёт на себя ответственность за конфигурацию и порядок обёртывания объектов.

![[Pasted image 20241211092247.png]]
### Проблема

Вы работаете над библиотекой оповещений, которую можно подключать к разнообразным программам, чтобы получать уведомления о важных событиях.

Основой библиотеки является класс `Notifier` с методом `send`, который принимает на вход строку-сообщение и высылает её всем администраторам по электронной почте. Сторонняя программа должна создать и настроить этот объект, указав кому отправлять оповещения, а затем использовать его каждый раз, когда что-то случается.

В какой-то момент стало понятно, что одних email-оповещений пользователям мало. Некоторые из них хотели бы получать извещения о критических проблемах через SMS. Другие хотели бы получать их в виде сообщений Facebook. Корпоративные пользователи хотели бы видеть сообщения в Slack.

Итак, нужен какой-то другой способ комбинирования поведения объектов, который не приводит к взрыву количества подклассов.

![[Pasted image 20240901120147.png]]

### Решение 

Наследование — это первое, что приходит в голову многим программистам, когда нужно расширить какое-то существующее поведение. Но механизм наследования имеет несколько досадных проблем.

- Он **статичен**. Вы не можете изменить поведение существующего объекта. Для этого вам надо создать новый объект, выбрав другой подкласс.
- Он **не разрешает наследовать поведение нескольких классов одновременно**. Из-за этого вам приходится создавать множество подклассов-комбинаций для получения совмещённого поведения.

Одним из способов обойти эти проблемы является замена наследования _агрегацией_ либо _композицией_ . Это когда один объект _содержит_ ссылку на другой и делегирует ему работу, вместо того чтобы самому _наследовать_ его поведение. Как раз на этом принципе построен паттерн Декоратор.

Декоратор имеет альтернативное название — _обёртка_. Оно более точно описывает суть паттерна: вы помещаете целевой объект в другой объект-обёртку, который запускает базовое поведение объекта, а затем добавляет к результату что-то своё.

Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы, с каким объектом работать — чистым или обёрнутым. Вы можете использовать несколько разных обёрток одновременно — результат будет иметь объединённое поведение всех обёрток сразу.

### Пример

![[Pasted image 20241116113805.png]]

```java
public class UserServiceImpl implements UserService {
  private final UserRepository userRepository;

  @Override
  public void updateUser(Long id, String firstName, String lastName) {
      User user = userRepository.findById(id)
          .orElseThrow(() -> new NoSuchElementException("No User with ID=" + id));
      user.update(firstName, lastName);
  }
}

public class AuditUserService implements UserService {
  private final UserService origin;
  private final AuditService auditService;

  @Override
  public void updateUser(Long id, String firstName, String lastName) {
    try {
      origin.updateUser(id, firstName, lastName);
    }
    catch (RuntimeException e) {
      auditService.auditFailedUserCreation(id, e);
      throw e;
    }
  }
}

public class EmailUserService implements UserService {
  private final UserService origin;
  private final EmailService emailService;

  @Override
  public void updateUser(Long id, String firstName, String lastName) {
    origin.updateUser(id, firstName, lastName);
    emailService.notifyAdmin(new UserUpdatedEvent(id));
  }
}
```

### Отношения с другими паттернами

- [[GoF Адаптер|Адаптер]] предоставляет совершенно другой интерфейс для доступа к существующему объекту. С другой стороны, при использовании паттерна [[GoF Декоратор|Декоратор]] интерфейс либо остается прежнем либо расширяется. Также Декоратор поддерживает рекурсивную вложенность.
    
- С [[GoF Адаптер|Адаптером]] мы получаем доступ к существующем объекту через другой интерфейс. Используя [[GoF Заместитель|Заместитель]], интерфейс остается неизменным. Используя [[GoF Декоратор|Декоратор]], мы получаем доступ к объекту через расширенный интерфейс. 
    
- [[GoF Цепочка обязанностей]] и [[GoF Декоратор]] имеют очень похожие структуры. Оба паттерна базируются на принципе рекурсивного выполнения операции через серию связанных объектов. Но есть и несколько важных отличий.
    
    Обработчики в _Цепочке обязанностей_ могут выполнять произвольные действия, независимые друг от друга, а также в любой момент прерывать дальнейшую передачу по цепочке. С другой стороны _Декораторы_ расширяют какое-то определённое действие, не ломая интерфейс базовой операции и не прерывая выполнение остальных декораторов.
    
- [[GoF Компоновщик]] и **декоратор** имеют похожие структуры классов из-за того, что оба построены на [[Рекурсия|рекурсивной]] вложенности. Она позволяет связать в одну структуру бесконечное количество объектов.
    
    _Декоратор_ оборачивает только один объект, а узел _Компоновщика_ может иметь много детей. _Декоратор_ добавляет вложенному объекту новую функциональность, а _Компоновщик_ не добавляет ничего нового, но «суммирует» результаты всех своих детей.
    
    Но они могут и сотрудничать: _Компоновщик_ может использовать _Декоратор_, чтобы переопределить функции отдельных частей дерева компонентов.
    
- Архитектура, построенная на [[GoF Компоновщик]] и [[GoF Декоратор]], часто может быть улучшена за счёт внедрения [[GoF Прототип]]. Он позволяет клонировать сложные структуры объектов, а не собирать их заново.
    
- [[Gof Стратегия]] меняет поведение объекта «изнутри», а [[GoF Декоратор]] изменяет его «снаружи».
    
- Декоратор и [[GoF Заместитель|Заместитель]] имеют схожие структуры, но разные назначения. Они похожи тем, что оба построены на принципе композиции и делегируют работу другим объектам. Паттерны отличаются тем, что _Заместитель_ сам управляет жизнью сервисного объекта, а обёртывание _Декораторов_ контролируется клиентом. [[../02 Проблемы/В чем разница между Декоратором и Заместителем]]