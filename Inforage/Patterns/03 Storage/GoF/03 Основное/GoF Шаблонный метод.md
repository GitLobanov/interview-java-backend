---
Определение: Определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры.
Тип:
  - Поведенческий
пример: Рецепт пиццы определяет базу, а начинку выбирает каждый
---
Template Method
### Проблема

Вы пишете программу для дата-майнинга в офисных документах. Пользователи будут загружать в неё документы в разных форматах (PDF, DOC, CSV), а программа должна извлекать из них полезную информацию.

В первой версии вы ограничились только обработкой DOC-файлов. В следующей версии добавили поддержку CSV. А через месяц прикрутили работу с PDF-документами.

![[Pasted image 20240901145245.png]]

В какой-то момент вы заметили, что код всех трёх классов обработки документов хоть и отличается в части работы с файлами, но содержат довольно много общего в части самого извлечения данных. Было бы здорово избавится от повторной реализации алгоритма извлечения данных в каждом из классов.

К тому же остальной код, работающий с объектами этих классов, наполнен условиями, проверяющими тип обработчика перед началом работы. Весь этот код можно упростить, если слить все три класса воедино либо свести их к общему интерфейсу.
### Решение 

Паттерн Шаблонный метод предлагает разбить алгоритм на последовательность шагов, описать эти шаги в отдельных методах и вызывать их в одном _шаблонном_ методе друг за другом.

Это позволит подклассам переопределять некоторые шаги алгоритма, оставляя без изменений его структуру и остальные шаги, которые для этого подкласса не так важны.

В нашем примере с дата-майнингом мы можем создать общий базовый класс для всех трёх алгоритмов. Этот класс будет состоять из шаблонного метода, который последовательно вызывает шаги разбора документов.

![[Pasted image 20240901145310.png]]

Для начала шаги шаблонного метода можно сделать абстрактными. Из-за этого все подклассы должны будут реализовать каждый из шагов по-своему. В нашем случае все подклассы и так содержат реализацию каждого из шагов, поэтому ничего дополнительно делать не нужно.

По-настоящему важным является следующий этап. Теперь мы можем определить общее для всех классов поведение и вынести его в суперкласс. В нашем примере шаги открытия, считывания и закрытия могут отличаться для разных типов документов, поэтому останутся абстрактными. А вот одинаковый для всех типов документов код обработки данных переедет в базовый класс.

Как видите, у нас получилось два вида шагов: _абстрактные_, которые каждый подкласс обязательно должен реализовать, а также шаги _с реализацией по умолчанию_, которые можно переопределять в подклассах, но не обязательно.

Но есть и третий тип шагов — _хуки_: их не обязательно переопределять, но они не содержат никакого кода, выглядя как обычные методы. Шаблонный метод останется рабочим, даже если ни один подкласс не переопределит такой хук. Однако, хук даёт подклассам дополнительные точки «вклинивания» в шаблонный метод.

### Пример

Представим, что мы разрабатываем систему для приготовления различных напитков, таких как чай и кофе. Процесс приготовления этих напитков схож, но имеет некоторые отличия. Мы можем использовать шаблонный метод для определения общего процесса и позволить подклассам реализовать специфические шаги.

Создадим абстрактный класс `CaffeineBeverage`, который определяет общий процесс приготовления напитка. Шаблонный метод `prepareRecipe` содержит шаги, которые должны быть выполнены в определенной последовательности. Некоторые из этих шагов определены в базовом классе, а некоторые — в подклассах.

```java
abstract class CaffeineBeverage {
    // Шаблонный метод, который определяет общий процесс
    final void prepareRecipe() {
        boilWater();
        brew();
        pourInCup();
        addCondiments();
    }

    // Эти методы могут быть переопределены в подклассах
    abstract void brew();
    abstract void addCondiments();

    // Эти методы общие для всех подклассов и не должны быть изменены
    void boilWater() {
        System.out.println("Boiling water");
    }

    void pourInCup() {
        System.out.println("Pouring into cup");
    }
}
```

Теперь создадим два подкласса — `Tea` и `Coffee`, которые реализуют шаги, специфичные для каждого напитка.

```java
class Tea extends CaffeineBeverage {
    @Override
    void brew() {
        System.out.println("Steeping the tea");
    }

    @Override
    void addCondiments() {
        System.out.println("Adding lemon");
    }
}

class Coffee extends CaffeineBeverage {
    @Override
    void brew() {
        System.out.println("Dripping coffee through filter");
    }

    @Override
    void addCondiments() {
        System.out.println("Adding sugar and milk");
    }
}

```

Теперь мы можем использовать шаблонный метод для приготовления чая и кофе.

```java
public class Main {
    public static void main(String[] args) {
        CaffeineBeverage tea = new Tea();
        CaffeineBeverage coffee = new Coffee();

        System.out.println("Making tea...");
        tea.prepareRecipe();

        System.out.println("\nMaking coffee...");
        coffee.prepareRecipe();
    }
}
```

### Шаги реализации

1. Изучите алгоритм и подумайте, можно ли его разбить на шаги. Прикиньте, какие шаги будут стандартными для всех вариаций алгоритма, а какие — изменяющимися.
    
2. Создайте абстрактный базовый класс. Определите в нём шаблонный метод. Этот метод должен состоять из вызовов шагов алгоритма. Имеет смысл сделать шаблонный метод финальным, чтобы подклассы не могли переопределить его (если ваш язык программирования это позволяет).
    
3. Добавьте в абстрактный класс методы для каждого из шагов алгоритма. Вы можете сделать эти методы абстрактными или добавить какую-то реализацию по умолчанию. В первом случае все подклассы _должны_ будут реализовать эти методы, а во втором — только если реализация шага в подклассе отличается от стандартной версии.
    
4. Подумайте о введении в алгоритм хуков. Чаще всего, хуки располагают между основными шагами алгоритма, а также до и после всех шагов.
    
5. Создайте конкретные классы, унаследовав их от абстрактного класса. Реализуйте в них все недостающие шаги и хуки.

### Отношения с другими паттернами

- [[GoF Фабричный метод]] можно рассматривать как частный случай [[GoF Шаблонный метод|Шаблонного метода]]. Кроме того, _Фабричный метод_ нередко бывает частью большого класса с _Шаблонными методами_. [[EX. Фабричный метод вместе с Шаблонными методами]]
    
- [[GoF Шаблонный метод]] использует наследование, чтобы расширять части алгоритма. [[Gof Стратегия]] использует делегирование, чтобы изменять выполняемые алгоритмы на лету. _Шаблонный метод_ работает на уровне классов. _Стратегия_ позволяет менять логику отдельных объектов.