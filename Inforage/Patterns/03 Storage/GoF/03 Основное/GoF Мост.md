---
Определение: Разделяет один или несколько классов на две отдельные иерархии — Абстракция и Реализация, позволяя изменять их независимо друг от друга.
Тип:
  - Структурный
пример: "Пульт может управлять разными устройствами: телевизором, кондиционером."
---
Bridge

Выделение интерфейсов, абстрактных классов, делегетатов, фабрик, стратегия, шаблонные метод

![[Pasted image 20241003122319.png]]
### Проблема

У нас есть класс геометрических `Фигур`, который имеет подклассы `Круг` и `Квадрат`. Мы хотим расширить иерархию фигур по цвету, то есть иметь `Красные` и `Синие` фигуры. Но чтобы всё это объединить, придётся создать 4 комбинации подклассов, вроде `СиниеКруги` и `КрасныеКвадраты`.

При добавлении новых видов фигур и цветов количество комбинаций будет расти в геометрической прогрессии.

### Решение 

Корень проблемы заключается в том, что мы пытаемся расширить классы фигур сразу в двух независимых плоскостях — по виду и по цвету. Именно это приводит к разрастанию дерева классов.

Паттерн Мост предлагает заменить наследование [[Агрегация|агрегацией]] или [[Композиция|композицией]] . Для этого нужно выделить одну из таких «плоскостей» в отдельную иерархию и ссылаться на объект этой иерархии, вместо хранения его состояния и поведения внутри одного класса.

### Пример

Предположим, у нас есть система автосервиса, где нам нужно поддерживать разные типы автомобилей и различные виды обслуживания. Мы можем использовать паттерн Мост для разделения абстракции автомобиля от конкретных реализаций обслуживания.

Создаем абстрактный класс `Car` и интерфейс `Service`, которые будут содержать методы для работы с автомобилем и его обслуживания соответственно.

```java
// Абстракция
abstract class Car {
    protected Service service;  // Ссылка на реализацию сервиса

    protected Car(Service service) {
        this.service = service;
    }

    abstract void performService();  // Метод для выполнения обслуживания
}

// Конкретные абстракции
class Sedan extends Car {
    public Sedan(Service service) {
        super(service);
    }

    @Override
    void performService() {
        System.out.println("Performing service for Sedan");
        service.performService(this);
    }
}

class SUV extends Car {
    public SUV(Service service) {
        super(service);
    }

    @Override
    void performService() {
        System.out.println("Performing service for SUV");
        service.performService(this);
    }
}
```

Создаем интерфейс `Service` и конкретные реализации сервиса.

```java
// Интерфейс реализации
interface Service {
    void performService(Car car);
}

// Конкретные реализации сервиса
class BasicService implements Service {
    @Override
    public void performService(Car car) {
        System.out.println("Performing basic service for " + car.getClass().getSimpleName());
    }
}

class PremiumService implements Service {
    @Override
    public void performService(Car car) {
        System.out.println("Performing premium service for " + car.getClass().getSimpleName());
    }
}
```

Теперь мы можем создать объекты типа автомобиля и сервисов, а также выполнить обслуживание, используя паттерн Мост.

```java
public class BridgeExample {
    public static void main(String[] args) {
        // Создаем реализации сервиса
        Service basicService = new BasicService();
        Service premiumService = new PremiumService();
        
        // Создаем автомобили с разными сервисами
        Car sedanWithBasicService = new Sedan(basicService);
        Car suvWithPremiumService = new SUV(premiumService);
        
        // Выполняем обслуживание
        sedanWithBasicService.performService();
        suvWithPremiumService.performService();
    }
}
```

### Шаги реализации

1. Определите, существует ли в ваших классах два непересекающихся измерения. Это может быть функциональность/платформа, предметная-область/инфраструктура, фронт-энд/бэк-энд или интерфейс/реализация.
    
2. Какие операции будут нужны клиентам, и описать в базовом классе [[Абстракция|абстракции]].
    
3. Определить поведения, доступные на всех платформах, и выделить из них ту часть, которая нужна абстракции. На основании этого описать общий интерфейс [[Реализация|реализации]].
    
4. Для каждой платформы создавать свой класс конкретной реализации. Все они должны следовать общему интерфейсу, который мы выделили перед этим.
    
5. Добавить в класс абстракции ссылку на объект реализации. Реализовать методы абстракции, делегируя основную работу связанному объекту реализации.
    
6. Если у вас есть несколько вариаций абстракции, создайте для каждой из них свой подкласс.
    
7. Клиент должен подать объект реализации в конструктор абстракции, чтобы связать их воедино. После этого он может свободно использовать объект абстракции, забыв о реализации.

### Отношения с другими паттернами

- Мост проектируют загодя, чтобы развивать большие части приложения отдельно друг от друга [[GoF Адаптер|Адаптер]] применяется постфактум, чтобы заставить несовместимые классы работать вместе.
    
- [[GoF Мост|Мост]], [[Gof Стратегия|Стратегия]] и [[GoF Состояние|Состояние]] (а также слегка и [[GoF Адаптер|Адаптер]]), имеют схожие структуры классов - все они построены на принципе [[Композиция]], делегирование работы другим объектам. Тем не менее они решают разные задачи!
    
- [[GoF Абстрактная фабрика]] может работать совместно с Мостом. Это особенно полезно, если есть абстракции, которые могут работать только с некоторыми из реализаций. В этом случае фабрика будет определять типы создаваемых абстракций и реализаций.
    
- Паттерн [[GoF Строитель]] может быть построен в виде Моста: _директор_ будет играть роль абстракции, а _строители_ — реализации.