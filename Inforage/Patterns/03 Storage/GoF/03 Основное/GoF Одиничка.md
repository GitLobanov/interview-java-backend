---
Определение: Гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.
Тип:
  - Порождающий
пример: Водонапорная башня одна на весь город, чтобы регулировать водоснабжение
---
Singleton
### Проблема

Одиночка решает сразу две проблемы, нарушая _принцип единственной ответственности_ класса.

1. **Гарантирует наличие единственного экземпляра класса**. Чаще всего это полезно для доступа к какому-то общему ресурсу, например, базе данных.
    
    Представьте, что вы создали объект, а через некоторое время пробуете создать ещё один. В этом случае хотелось бы получить старый объект, вместо создания нового.
    
    Такое поведение невозможно реализовать с помощью обычного конструктора, так как конструктор класса **всегда** возвращает новый объект.

2. **Предоставляет глобальную точку доступа**. Это не просто глобальная переменная, через которую можно достучаться к определённому объекту. Глобальные переменные не защищены от записи, поэтому любой код может подменять их значения без вашего ведома.
    
    Но есть и другой нюанс. Неплохо бы хранить в одном месте и код, который решает проблему №1, а также иметь к нему простой и доступный интерфейс.
    

Интересно, что в наше время паттерн стал настолько известен, что теперь люди называют «одиночками» даже те классы, которые решают лишь одну из проблем, перечисленных выше.
### Решение 

Все реализации одиночки сводятся к тому, чтобы скрыть конструктор по умолчанию и создать публичный статический метод, который и будет контролировать жизненный цикл объекта-одиночки.

Если у вас есть доступ к классу одиночки, значит, будет доступ и к этому статическому методу. Из какой точки кода вы бы его ни вызвали, он всегда будет отдавать один и тот же объект.

### Пример потокопезопасного одиночки

```java
public class Singleton {
    private static volatile Singleton instance;
    private static final Object lock = new Object();
    public static Singleton getInstance() {
        Singleton result = instance;
        if (result != null)
            return result;

        synchronized (lock) {
            if (instance == null)
                instance = new Singleton();
            return instance;
        }
    }
    private Singleton() {}
}
```

### Пример ленивого одиночки

А теперь правильное создание ленивого одиночки. 
Lazy Initialization Holder Class Idiom

```java
public class Singleton {
	// доступен только здесь
    private static class SingletonHolder {
       public static final Singleton instance = new Singleton();
    }

    public static Singleton getInstance() {
        return SingletonHolder.instance;
    }
    private Singleton() {
    }
}
```

В этом случае, `SingletonHolder` будет загружен только тогда, когда кто-то вызовет метод `getInstance()`. Это обеспечивает **ленивую инициализацию** объекта `Singleton`.
### Шаги реализации

1. Добавьте в класс приватное статическое поле, которое будет содержать одиночный объект.
    
2. Объявите статический создающий метод, который будет использоваться для получения одиночки.
    
3. Добавьте «ленивую инициализацию» (создание объекта при первом вызове метода) в создающий метод одиночки.
    
4. Сделайте конструктор класса приватным.
    
5. В клиентском коде замените вызовы конструктора одиночка вызовами его создающего метода.

### Отношения с другими паттернами

- [[GoF Фасад]] можно сделать **Одиночкой**, так как обычно нужен только один объект-фасад.
    
- Паттерн [[GoF Легковес]] может напоминать **Одиночку**, если для конкретной задачи у вас получилось свести количество объектов к одному. Но помните, что между паттернами есть два кардинальных отличия:
    
    1. В отличие от _Одиночки_, вы можете иметь множество объектов-легковесов.
    2. Объекты-легковесы должны быть неизменяемыми, тогда как объект-одиночка допускает изменение своего состояния.
- [[GoF Абстрактная фабрика]], [[GoF Строитель]] и [[GoF Прототип]] могут быть реализованы при помощи [[GoF Одиничка]].