---
Определение: Даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.
Тип:
  - Поведенческий
пример: Позволяет обходить элементы коллекции, скрывая реализацию структуры данных.
---
#iterator
### Проблема

Коллекции — самая распространённая структура данных, которую вы можете встретить в программировании. Это набор объектов, собранный в одну кучу по каким-то критериям.

![[Pasted image 20240901133532.png]]

Большинство коллекций выглядят как обычный список элементов. Но есть и экзотические коллекции, построенные на основе деревьев, графов и других сложных структур данных.

Но как бы ни была структурирована коллекция, пользователь должен иметь возможность последовательно обходить её элементы, чтобы проделывать с ними какие-то действия.

Но каким способом следует перемещаться по сложной структуре данных? Например, сегодня может быть достаточным обход дерева в глубину, но завтра потребуется возможность перемещаться по дереву в ширину. А на следующей неделе и того хуже — понадобится обход коллекции в случайном порядке.

![[Pasted image 20240901133609.png]]
### Решение 

Идея паттерна Итератор состоит в том, чтобы вынести поведение обхода коллекции из самой коллекции в отдельный класс.

![[Pasted image 20240901133654.png]]

Объект-итератор будет отслеживать состояние обхода, текущую позицию в коллекции и сколько элементов ещё осталось обойти. Одну и ту же коллекцию смогут одновременно обходить различные итераторы, а сама коллекция не будет даже знать об этом.

К тому же, если вам понадобится добавить новый способ обхода, вы сможете создать отдельный класс итератора, не изменяя существующий код коллекции.

### Пример

```java
// Интерфейс Итератора

interface Iterator<T> {
    boolean hasNext();
    T next();
}


// Этот итератор будет реализовывать логику обхода элементов коллекции.

class BookIterator implements Iterator<Book> {
    private List<Book> books;
    private int position = 0;

    public BookIterator(List<Book> books) {
        this.books = books;
    }

    @Override
    public boolean hasNext() {
        return position < books.size();
    }

    @Override
    public Book next() {
        return hasNext() ? books.get(position++) : null;
    }
}

// Конкретная коллекция

class BookCollection implements IterableCollection<Book> {
    private List<Book> books = new ArrayList<>();

    public void addBook(Book book) {
        books.add(book);
    }

    @Override
    public Iterator<Book> createIterator() {
        return new BookIterator(books);
    }
}

// Теперь мы можем использовать итератор для обхода коллекции книг.

public class Main {
    public static void main(String[] args) {
        BookCollection collection = new BookCollection();
        collection.addBook(new Book("The Catcher in the Rye"));
        collection.addBook(new Book("To Kill a Mockingbird"));
        collection.addBook(new Book("1984"));

        Iterator<Book> iterator = collection.createIterator();

        while (iterator.hasNext()) {
            Book book = iterator.next();
            System.out.println("Book: " + book.getTitle());
        }
    }
}

```

### Шаги реализации

1. Создайте общий интерфейс итераторов. Обязательный минимум — это операция получения следующего элемента коллекции. Но для удобства можно предусмотреть и другое. Например, методы для получения предыдущего элемента, текущей позиции, проверки окончания обхода и прочие.
    
2. Создайте интерфейс коллекции и опишите в нём метод получения итератора. Важно, чтобы сигнатура метода возвращала общий интерфейс итераторов, а не один из конкретных итераторов.
    
3. Создайте классы конкретных итераторов для тех коллекций, которые нужно обходить с помощью паттерна. Итератор должен быть привязан только к одному объекту коллекции. Обычно эта связь устанавливается через конструктор.
    
4. Реализуйте методы получения итератора в конкретных классах коллекций. Они должны создавать новый итератор того класса, который способен работать с данным типом коллекции. Коллекция должна передавать ссылку на собственный объект в конструктор итератора.
    
5. В клиентском коде и в классах коллекций не должно остаться кода обхода элементов. Клиент должен получать новый итератор из объекта коллекции каждый раз, когда ему нужно перебрать её элементы.

### Отношения с другими паттернами

- Вы можете обходить дерево [[GoF Компоновщик]] , используя **итератор**.
    
- [[GoF Фабричный метод]] можно использовать вместе с итератором, чтобы подклассы коллекций могли создавать подходящие им итераторы.
    
- [[GoF Снимок]] можно использовать вместе с **итератором**, чтобы сохранить текущее состояние обхода структуры данных и вернуться к нему в будущем, если потребуется.
    
- [[GoF Посетитель]] можно использовать совместно с **итератором**. _Итератор_ будет отвечать за обход структуры данных, а _Посетитель_ — за выполнение действий над каждым её компонентом.