---
Определение: Позволяет объектам с несовместимыми интерфейсами работать вместе.
Тип:
  - Структурный
пример: Зарядное устройство адаптирует разные типы разъемов для телефонов.
---
Wrapper, Обёртка, Adapter
Сохраняет внутренне состояние

![[Pasted image 20241003115021.png]]
### Проблема

Представьте, что вы делаете приложение для торговли на бирже. Ваше приложение скачивает биржевые котировки из нескольких источников в XML, а затем рисует красивые графики.

В какой-то момент вы решаете улучшить приложение, применив стороннюю библиотеку аналитики. Но вот беда — библиотека поддерживает только формат данных JSON, несовместимый с вашим приложением.

### Решение 

Вы можете создать _адаптер_. Это объект-переводчик, который трансформирует интерфейс или данные одного объекта в такой вид, чтобы он стал понятен другому объекту.

При этом адаптер оборачивает один из объектов, так что другой объект даже не знает о наличии первого. Например, вы можете обернуть объект, работающий в метрах, адаптером, который бы конвертировал данные в футы.

Таким образом, в приложении биржевых котировок вы могли бы создать класс `XML_To_JSON_Adapter`, который бы оборачивал объект того или иного класса библиотеки аналитики. Ваш код посылал бы адаптеру запросы в формате XML, а адаптер сначала транслировал входящие данные в формат JSON, а затем передавал бы их методам обёрнутого объекта аналитики.
### Пример

Представим, что у вас есть система для изучения языков, которая использует современные учебные материалы в виде цифровых ресурсов. Но у вас есть старый класс, представляющий учебники в бумажном виде. Вы хотите интегрировать этот старый класс в свою новую систему, но интерфейсы не совпадают.

Допустим, у нас есть класс `OldPaperTextbook`, который используется для работы с бумажными учебниками:

```java
class OldPaperTextbook {
    void openBook() {
        System.out.println("Opening the paper textbook...");
    }

    void readPage(int pageNumber) {
        System.out.println("Reading page " + pageNumber + " from the paper textbook...");
    }
}
```

В новой системе у вас есть интерфейс `DigitalTextbook`, который должен поддерживать все цифровые учебные материалы:

```java
interface DigitalTextbook {
    void open();
    void read(int page);
}
```

Чтобы использовать старый класс `OldPaperTextbook` с интерфейсом `DigitalTextbook`, создадим адаптер:

```java
class PaperTextbookAdapter implements DigitalTextbook {
    private OldPaperTextbook oldPaperTextbook;

    public PaperTextbookAdapter(OldPaperTextbook oldPaperTextbook) {
        this.oldPaperTextbook = oldPaperTextbook;
    }

    @Override
    public void open() {
        oldPaperTextbook.openBook();
    }

    @Override
    public void read(int page) {
        oldPaperTextbook.readPage(page);
    }
}
```

Теперь вы можете использовать адаптированный бумажный учебник как цифровой:

```java
public class Main {
    public static void main(String[] args) {
        OldPaperTextbook oldTextbook = new OldPaperTextbook();
        DigitalTextbook adaptedTextbook = new PaperTextbookAdapter(oldTextbook);

        // Используем адаптированный бумажный учебник как цифровой
        adaptedTextbook.open();
        adaptedTextbook.read(42);
    }
}
```
### Шаги реализации

1. Убедиться что есть два есть два интерфейса с несовместимыми интерфейсами:
- полезный сервис - тот что нельзя и не можем изменять
- один или несколько клиентов - несовместимых или неудобных в использовании с интерфейсом сервиса

2. Описать клиентский интерфейс через который классы приложения смогли бы взаимодействовать с сервисом

3. Создать класс адаптера, реализовав этот интерфейс.

4. Поместить объект с ссылкой на сервис. Обычно объект сервиса передается в конструкторе. В случае простой реализации, объект можно передавать параметром через методы адаптера

5. Реализовать все методы клиентского интерфейса в адаптере. Адаптер должен делегировать основную работу сервису.

6. Приложение должно использовать адаптере через клиентский интерфейса. Это позволит гибкость в изменении адаптера в будущем.

### Отношения с другими паттернами

- Адаптер применяется постфактум, чтобы заставить несовместимы классы работать вместе. [[GoF Мост|Мост]] проектирует загодя, чтобы развивать большие части приложения отдельно друг от друга.

- Адаптер предоставляет совершенно другой интерфейс для доступа к существующему объекту. С другой стороны, при использовании паттерна [[GoF Декоратор|Декоратор]] интерфейс либо остается прежнем либо расширяется. Также Декоратор поддерживает рекурсивную вложенность.

- С Адаптером мы получаем доступ к существующем объекту через другой интерфейс. Используя [[GoF Заместитель|Заместитель]], интерфейс остается неизменным. Используя [[GoF Декоратор|Декоратор]], мы получаем доступ к объекту через расширенный интерфейс. 

- [[GoF Фасад|Фасад]] задает новый интерфейс, тогда как Адаптер повторно использует старый. Адаптер оборачивает только один класс, а Фасад оборачивает целую подсистему. Кроме того, Адаптер позволяет работать двум существующим интерфейсам сообща, вместо того, чтобы задать полностью новый.

- [[GoF Мост|Мост]], [[Gof Стратегия|Стратегия]] и [[GoF Состояние|Состояние]] (а также слегка и Адаптер), имеют схожие структуры классов - все они построены на принципе [[Композиция]], делегирование работы другим объектам. Тем не менее они решают разные задачи!