---
Определение: Позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи, реализуя как бы связанный список обработчиков.
Тип:
  - Поведенческий
пример: Поддержка клиентов передает запросы от оператора к менеджеру.
---
CoR, Chain of Command, Chain of Responsibility

HandlerMapping (contollers), HandlerAdapter (methods), ModelAndView в DispacherServlet
FilterChainProxy - SecuritySpring
### Проблема

Представьте, что вы делаете систему приёма онлайн-заказов. Вы хотите ограничить к ней доступ так, чтобы только авторизованные пользователи могли создавать заказы. Кроме того, определённые пользователи, владеющие правами администратора, должны иметь полный доступ к заказам.

Вы быстро сообразили, что эти проверки нужно выполнять последовательно. Ведь пользователя можно попытаться «залогинить» в систему, если его запрос содержит логин и пароль. Но если такая попытка не удалась, то проверять расширенные права доступа попросту не имеет смысла.

На протяжении следующих нескольких месяцев вам пришлось добавить ещё несколько таких последовательных проверок.

- Кто-то резонно заметил, что неплохо бы проверять данные, передаваемые в запросе перед тем, как вносить их в систему — вдруг запрос содержит данные о покупке несуществующих продуктов.
    
- Кто-то предложил блокировать массовые отправки формы с одним и тем же логином, чтобы предотвратить подбор паролей ботами.
    
- Кто-то заметил, что форму заказа неплохо бы доставать из кеша, если она уже была однажды показана.

С каждой новой «фичей» код проверок, выглядящий как большой клубок условных операторов, всё больше и больше раздувался. При изменении одного правила приходилось трогать код всех проверок. А для того, чтобы применить проверки к другим ресурсам, пришлось продублировать их код в других классах.
### Решение 

![[Pasted image 20240901131439.png]]

Очень важно, чтобы все объекты цепочки имели общий интерфейс. Обычно каждому конкретному обработчику достаточно знать только то, что следующий объект в цепи имеет метод `выполнить`. Благодаря этому связи между объектами цепочки будут более гибкими. Кроме того, вы сможете формировать цепочки на лету из разнообразных объектов, не привязываясь к конкретным классам.
### Пример

Представьте, что у нас есть система для обработки сообщений. Сообщения могут быть разного типа: информационные, предупреждения и ошибки. Мы хотим, чтобы каждое сообщение обрабатывалось соответствующим обработчиком, но если сообщение не может быть обработано на текущем уровне, оно передавалось дальше по цепочке.

```java
// Базовый класс для всех обработчиков
abstract class MessageHandler {
    protected MessageHandler nextHandler;

    public void setNextHandler(MessageHandler nextHandler) {
        this.nextHandler = nextHandler;
    }

    public void handleMessage(String message, String type) {
        if (nextHandler != null) {
            nextHandler.handleMessage(message, type);
        }
    }
}

// Обработчик информационных сообщений
class InfoHandler extends MessageHandler {
    @Override
    public void handleMessage(String message, String type) {
        if (type.equals("INFO")) {
        ...
    }
}

// Обработчик предупреждений
class WarningHandler extends MessageHandler {
    @Override
    public void handleMessage(String message, String type) {
        if (type.equals("WARNING")) {
        ...
}

// Обработчик ошибок
class ErrorHandler extends MessageHandler {
    @Override
    public void handleMessage(String message, String type) {
        if (type.equals("ERROR")) {
        ...
}

// Клиентский код
public class Main {
    public static void main(String[] args) {
        // Создаем обработчиков
        MessageHandler infoHandler = new InfoHandler();
        MessageHandler warningHandler = new WarningHandler();
        MessageHandler errorHandler = new ErrorHandler();

        // Устанавливаем цепочку: info -> warning -> error
        infoHandler.setNextHandler(warningHandler);
        warningHandler.setNextHandler(errorHandler);

        // Отправляем сообщения разного типа
        infoHandler.handleMessage("Это информационное сообщение.", "INFO");
        infoHandler.handleMessage("Это предупреждение.", "WARNING");
        infoHandler.handleMessage("Это сообщение об ошибке.", "ERROR");
        infoHandler.handleMessage("Неизвестный тип сообщения.", "UNKNOWN");
    }
}
```

### Шаги реализации

1. Создайте интерфейс обработчика и опишите в нём основной метод обработки.
    
    Продумайте, в каком виде клиент должен передавать данные запроса в обработчик. Самый гибкий способ — превратить данные запроса в объект и передавать его целиком через параметры метода обработчика.
    
2. Имеет смысл создать абстрактный базовый класс обработчиков, чтобы не дублировать реализацию метода получения следующего обработчика во всех конкретных обработчиках.
    
    Добавьте в базовый обработчик поле для хранения ссылки на следующий объект цепочки. Устанавливайте начальное значение этого поля через конструктор. Это сделает объекты обработчиков неизменяемыми. Но если программа предполагает динамическую перестройку цепочек, можете добавить и сеттер для поля.
    
    Реализуйте базовый метод обработки так, чтобы он перенаправлял запрос следующему объекту, проверив его наличие. Это позволит полностью скрыть поле-ссылку от подклассов, дав им возможность передавать запросы дальше по цепи, обращаясь к родительской реализации метода.
    
3. Один за другим создайте классы конкретных обработчиков и реализуйте в них методы обработки запросов. При получении запроса каждый обработчик должен решить:
    
    - Может ли он обработать запрос или нет?
    - Следует ли передать запрос следующему обработчику или нет?
4. Клиент может собирать цепочку обработчиков самостоятельно, опираясь на свою бизнес-логику, либо получать уже готовые цепочки извне. В последнем случае цепочки собираются фабричными объектами, опираясь на конфигурацию приложения или параметры окружения.
    
5. Клиент может посылать запросы любому обработчику в цепи, а не только первому. Запрос будет передаваться по цепочке до тех пор, пока какой-то обработчик не откажется передавать его дальше, либо когда будет достигнут конец цепи.
    
6. Клиент должен знать о динамической природе цепочки и быть готов к таким случаям:
    
    - Цепочка может состоять из единственного объекта.
    - Запросы могут не достигать конца цепи.
    - Запросы могут достигать конца, оставаясь необработанными.

### Отношения с другими паттернами

- [[GoF Цепочка обязанностей]], [[GoF Команда]], [[GoF Посредник]] и [[GoF Наблюдатель]] показывают различные способы работы отправителей запросов с их получателями:
    
    - _Цепочка обязанностей_ передаёт запрос последовательно через цепочку потенциальных получателей, ожидая, что какой-то из них обработает запрос.
    - _Команда_ устанавливает косвенную одностороннюю связь от отправителей к получателям.
    - _Посредник_ убирает прямую связь между отправителями и получателями, заставляя их общаться опосредованно, через себя.
    - _Наблюдатель_ передаёт запрос одновременно всем заинтересованным получателям, но позволяет им динамически подписываться или отписываться от таких оповещений.
- [[GoF Цепочка обязанностей]] часто используют вместе с [[GoF Компоновщик|Компоновщиком]]. В этом случае запрос передаётся от дочерних компонентов к их родителям.
    
- Обработчики в [[GoF Цепочка обязанностей]] могут быть выполнены в виде [[GoF Команда|Команды]]. В этом случае множество разных операций может быть выполнено над одним и тем же контекстом, коим является запрос.
    
    Но есть и другой подход, в котором сам запрос является _Командой_, посланной по цепочке объектов. В этом случае одна и та же операция может быть выполнена над множеством разных контекстов, представленных в виде цепочки.
    
- [[GoF Цепочка обязанностей]] и [[GoF Декоратор]] имеют очень похожие структуры. Оба паттерна базируются на принципе рекурсивного выполнения операции через серию связанных объектов. Но есть и несколько важных отличий.
    
    Обработчики в _Цепочке обязанностей_ могут выполнять произвольные действия, независимые друг от друга, а также в любой момент прерывать дальнейшую передачу по цепочке. С другой стороны _Декораторы_ расширяют какое-то определённое действие, не ломая интерфейс базовой операции и не прерывая выполнение остальных декораторов.