---
Определение: Превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций.
Тип:
  - Поведенческий
пример: Инкапсулирует запрос, например, для создания undo/redo действий в текстовом редакторе.
---
Действие, Транзакция, Action, #command
### Проблема

Представим, что мы создаем кнопки для панели управления. Куда прописывать обработчики событий? Создать подклассы?

![[Pasted image 20240901132826.png]]

И тут голова кипит, куча классов, дублируется код. А еще все время <mark style="background: #ADCCFFA6;">нестабильная бизнес-логика переплетается с графическим интерфейсом</mark>, что <mark style="background: #ADCCFFA6;">НЕ советуется делать</mark>.

![[Pasted image 20240901132839.png]]

Но самое обидное ещё впереди. Ведь некоторые операции, например, «сохранить», можно вызывать из нескольких мест: нажав кнопку на панели управления, вызвав контекстное меню или просто нажав клавиши `Ctrl+S`. Когда в программе были только кнопки, код сохранения имелся только в подклассе `SaveButton`. Но теперь его придётся продублировать ещё в два класса.
### Решение 

Хорошие программы обычно структурированы в виде слоёв. Самый распространённый пример — слои пользовательского интерфейса и бизнес-логики. Первый всего лишь рисует красивую картинку для пользователя. Но когда нужно сделать что-то важное, интерфейс «просит» слой бизнес-логики заняться этим.

![[Pasted image 20240901132913.png]]

Паттерн Команда предлагает больше не отправлять такие вызовы напрямую. Вместо этого каждый вызов, отличающийся от других, следует завернуть в собственный класс с единственным методом, который и будет осуществлять вызов. Такие объекты называют _командами_.

К объекту интерфейса можно будет привязать объект команды, который знает, кому и в каком виде следует отправлять запросы. Когда объект интерфейса будет готов передать запрос, он вызовет метод команды, а та — позаботится обо всём остальном.

![[Pasted image 20240901133036.png]]

Классы команд можно объединить под общим интерфейсом c единственным методом запуска. После этого одни и те же отправители смогут работать с различными командами, не привязываясь к их классам. Даже больше: команды можно будет взаимозаменять на лету, изменяя итоговое поведение отправителей.

### Пример

```java

// Класс Свет
class Light {
    public void turnOn() {
        System.out.println("Свет включен.");
    }

    public void turnOff() {
        System.out.println("Свет выключен.");
    }
}

// Интерфейс Команды
interface Command {
    void execute();
}

// Команда для включения света
class LightOnCommand implements Command {
    private Light light;

    public LightOnCommand(Light light) {
        this.light = light;
    }

    @Override
    public void execute() {
        light.turnOn();
    }
}

// Команда для выключения света
class LightOffCommand implements Command {
    private Light light;

    public LightOffCommand(Light light) {
        this.light = light;
    }

    @Override
    public void execute() {
        light.turnOff();
    }
}

// Класс Пульт управления
class RemoteControl {
    private Command command;

    public void setCommand(Command command) {
        this.command = command;
    }

    public void pressButton() {
        command.execute();
    }
}

public class Main {
    public static void main(String[] args) {
        // Создаем объекты света
        Light livingRoomLight = new Light();

        // Создаем команды
        Command lightOn = new LightOnCommand(livingRoomLight);
        Command lightOff = new LightOffCommand(livingRoomLight);

        // Создаем пульт управления
        RemoteControl remoteControl = new RemoteControl();

        // Включаем свет
        remoteControl.setCommand(lightOn);
        remoteControl.pressButton(); // Вывод: "Свет включен."

        // Выключаем свет
        remoteControl.setCommand(lightOff);
        remoteControl.pressButton(); // Вывод: "Свет выключен."
    }
}
```

### Шаги реализации

1. Создаем общий интерфейс команд и определяем в нём метод запуска.
    
2. Один за другим создаем классы конкретных команд. В каждом классе должно быть поле для хранения ссылки на один или несколько объектов-получателей, которым команда будет перенаправлять основную работу.
    
    Кроме этого, команда должна иметь поля для хранения параметров, которые нужны при вызове методов получателя. Значения всех этих полей команда должна получать через конструктор.
    
    И, наконец, реализуйте основной метод команды, вызывая в нём те или иные методы получателя.
    
3. Добавляем в классы отправителей поля для хранения команд. Обычно объекты-отправители принимают готовые объекты команд извне — через конструктор либо через сеттер поля команды.
    
4. Изменяем основной код отправителей так, чтобы они делегировали выполнение действия команде.
    
5. Порядок инициализации объектов должен выглядеть так:
    
    - Создаём объекты получателей.
    - Создаём объекты команд, связав их с получателями.
    - Создаём объекты отправителей, связав их с командами.

### Отношения с другими паттернами

- [[GoF Цепочка обязанностей]], [[GoF Команда]], [[GoF Посредник]] и [[GoF Наблюдатель]] показывают различные способы работы отправителей запросов с их получателями:
    
    - _Цепочка обязанностей_ передаёт запрос последовательно через цепочку потенциальных получателей, ожидая, что какой-то из них обработает запрос.
    - _Команда_ устанавливает косвенную одностороннюю связь от отправителей к получателям.
    - _Посредник_ убирает прямую связь между отправителями и получателями, заставляя их общаться опосредованно, через себя.
    - _Наблюдатель_ передаёт запрос одновременно всем заинтересованным получателям, но позволяет им динамически подписываться или отписываться от таких оповещений.
- Обработчики в [[GoF Цепочка обязанностей]] могут быть выполнены в виде [[GoF Команда]]. В этом случае множество разных операций может быть выполнено над одним и тем же контекстом, коим является запрос.
    
    Но есть и другой подход, в котором сам запрос является _Командой_, посланной по цепочке объектов. В этом случае одна и та же операция может быть выполнена над множеством разных контекстов, представленных в виде цепочки.
    
- [[GoF Команда]] и [[GoF Снимок]] можно использовать сообща для реализации отмены операций. В этом случае объекты команд будут отвечать за выполнение действия над объектом, а снимки будут хранить резервную копию состояния этого объекта, сделанную перед самым запуском команды.
    
- [[GoF Команда]] и [[Gof Стратегия]] похожи по духу, но отличаются масштабом и применением:
    
    - _Команду_ используют, чтобы превратить любые разнородные действия в объекты. Параметры операции превращаются в поля объекта. Этот объект теперь можно логировать, хранить в истории для отмены, передавать во внешние сервисы и так далее.
    - С другой стороны, _Стратегия_ описывает разные способы произвести одно и то же действие, позволяя взаимозаменять эти способы в каком-то объекте контекста.
- Если [[GoF Команда]] нужно копировать перед вставкой в историю выполненных команд, вам может помочь [[GoF Прототип]].
    
- [[GoF Посетитель]] можно рассматривать как расширенный аналог [[GoF Команда]], который способен работать сразу с несколькими видами получателей.