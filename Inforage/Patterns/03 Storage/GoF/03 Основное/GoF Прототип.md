---
Определение: Позволяет копировать объекты, не вдаваясь в подробности их реализации.
Тип:
  - Порождающий
пример: Архитектор копирует чертеж дома, чтобы внести незначительные изменения.
---
Клон, Prototype

![[Pasted image 20241003104553.png]]
### Проблема

У вас есть объект, который нужно скопировать. Как это сделать? Нужно создать пустой объект такого же класса, а затем поочерёдно скопировать значения всех полей из старого объекта в новый.

Прекрасно! Но есть нюанс. Не каждый объект удастся скопировать таким образом, ведь часть его состояния может быть приватной, а значит — недоступной для остального кода программы.

Но есть и другая проблема. Копирующий код станет зависим от классов копируемых объектов. Ведь, чтобы перебрать _все_ поля объекта, нужно привязаться к его классу. Из-за этого вы не сможете копировать объекты, зная только их интерфейсы, а не конкретные классы.

### Решение 

Паттерн Прототип поручает создание копий самим копируемым объектам. Он вводит общий интерфейс для всех объектов, поддерживающих клонирование. Это позволяет копировать объекты, не привязываясь к их конкретным классам. Обычно такой интерфейс имеет всего один метод `clone`.

Реализация этого метода в разных классах очень схожа. Метод создаёт новый объект текущего класса и копирует в него значения всех полей собственного объекта. Так получится скопировать даже приватные поля, так как большинство языков программирования разрешает доступ к приватным полям любого объекта текущего класса.

Объект, который копируют, называется _прототипом_ (откуда и название паттерна). Когда объекты программы содержат сотни полей и тысячи возможных конфигураций, прототипы могут служить своеобразной альтернативой созданию подклассов.

В этом случае все возможные прототипы заготавливаются и настраиваются на этапе инициализации программы. Потом, когда программе нужен новый объект, она создаёт копию из приготовленного прототипа.

### Пример

Система управления документами. Создадим систему управления документами, где можно клонировать шаблоны документов для создания новых экземпляров с тем же содержанием, но уникальными идентификаторами.

Определим интерфейс `Prototype` с методом для клонирования.

```java
public interface Prototype {
    Prototype clone();
}
```

Создадим конкретный класс `Document`, который реализует интерфейс `Prototype`. Этот класс представляет собой документ, который можно клонировать.

```java
public class Document implements Prototype {
    private String content;
    private String author;

    public Document(String content, String author) {
        this.content = content;
        this.author = author;
    }

    // Геттеры и сеттеры
    ...

    // Реализация метода clone
    @Override
    public Prototype clone() {
        return new Document(content, author);
    }
}
```

Теперь мы можем создать оригинальный документ и клонировать его для создания новых документов.

```java
public class PrototypeDemo {
    public static void main(String[] args) {
        // Создаем оригинальный документ
        Document originalDocument = new Document("This is the content of the document.", "John Doe");

        // Клонируем документ
        Document clonedDocument1 = (Document) originalDocument.clone();
        Document clonedDocument2 = (Document) originalDocument.clone();

        // Изменяем содержание и автора клонированных документов
        clonedDocument1.setContent("This is the content of the first cloned document.");
        clonedDocument1.setAuthor("Jane Smith");

        clonedDocument2.setContent("This is the content of the second cloned document.");
        clonedDocument2.setAuthor("Alice Johnson");

        // Выводим документы
        System.out.println("Original Document: " + originalDocument);
        System.out.println("Cloned Document 1: " + clonedDocument1);
        System.out.println("Cloned Document 2: " + clonedDocument2);
    }
}
```

### Шаги реализации

1. Создайте интерфейс прототипов с единственным методом `clone`. Если у вас уже есть иерархия продуктов, метод клонирования можно объявить непосредственно в каждом из её классов.
    
2. Добавьте в классы будущих прототипов альтернативный конструктор, принимающий в качестве аргумента объект текущего класса. Этот конструктор должен скопировать из поданного объекта значения всех полей, объявленных в рамках текущего класса, а затем передать выполнение родительскому конструктору, чтобы тот позаботился о полях, объявленных в суперклассе.
    
    Если ваш язык программирования не поддерживает перегрузку методов, то вам не удастся создать несколько версий конструктора. В этом случае копирование значений можно проводить и в другом методе, специально созданном для этих целей. Конструктор удобнее тем, что позволяет клонировать объект за один вызов.
    
3. Метод клонирования обычно состоит всего из одной строки: вызова оператора `new` с конструктором прототипа. Все классы, поддерживающие клонирование, должны явно определить метод `clone`, чтобы использовать собственный класс с оператором `new`. В обратном случае результатом клонирования станет объект родительского класса.
    
4. Опционально, создайте центральное хранилище прототипов. В нём удобно хранить вариации объектов, возможно, даже одного класса, но по-разному настроенных.
    
    Вы можете разместить это хранилище либо в новом фабричном классе, либо в фабричном методе базового класса прототипов. Такой фабричный метод должен на основании входящих аргументов искать в хранилище прототипов подходящий экземпляр, а затем вызывать его метод клонирования и возвращать полученный объект.
    
    Наконец, нужно избавиться от прямых вызовов конструкторов объектов, заменив их вызовами фабричного метода хранилища прототипов.

### Отношения с другими паттернами

- Многие архитектуры начинаются с применения [[GoF Фабричный метод]]  (более простого и расширяемого через подклассы) и эволюционируют в сторону [[GoF Абстрактная фабрика]], **Прототип** или [[GoF Строитель|Строителя]] (более гибких, но и более сложных).
    
- Классы [[GoF Абстрактная фабрика|Абстрактной фабрики]] чаще всего реализуются с помощью [[GoF Фабричный метод|Фабричного метода]], хотя они могут быть построены и на основе **Прототипа**. [[EX. Абстрактная фабрика при помощи паттерна Прототип]]
    
- Если [[GoF Команда]] нужно копировать перед вставкой в историю выполненных команд, вам может помочь **Прототип**.
    
- Архитектура, построенная на [[GoF Компоновщик]] и [[GoF Декоратор]], часто может быть улучшена за счёт внедрения **Прототипа** Он позволяет клонировать сложные структуры объектов, а не собирать их заново.
    
- **Прототип** не опирается на наследование, но ему нужна сложная операция инициализации. [[GoF Фабричный метод]], наоборот, построен на наследовании, но не требует сложной инициализации.
    
- [[GoF Снимок]] иногда можно заменить **Прототипом**, если объект, состояние которого требуется сохранять в истории, довольно простой, не имеет активных ссылок на внешние ресурсы либо их можно легко восстановить.
    
- [[GoF Абстрактная фабрика]], [[GoF Строитель]] и **Прототип** могут быть реализованы при помощи [[GoF Одиничка]].