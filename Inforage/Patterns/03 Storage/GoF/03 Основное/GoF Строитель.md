---
Определение: Позволяет создавать сложные объекты пошагово. Даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.
Тип:
  - Порождающий
пример: "Проект дома строится поэтапно: сначала фундамент, потом стены."
---
Builder
### Проблема

Представьте сложный объект, требующий кропотливой пошаговой инициализации множества полей и вложенных объектов. Код инициализации таких объектов обычно спрятан внутри монструозного конструктора с десятком параметров. Либо ещё хуже — распылён по всему клиентскому коду.

Например, давайте подумаем о том, как создать объект `Дом`. Чтобы построить стандартный дом, нужно поставить 4 стены, установить двери, вставить пару окон и положить крышу. Но что, если вы хотите дом побольше да посветлее, имеющий сад, бассейн и прочее добро?

Самое простое решение — расширить класс `Дом`, создав подклассы для всех комбинаций параметров дома. Проблема такого подхода — это громадное количество классов, которые вам придётся создать. Каждый новый параметр, вроде цвета обоев или материала кровли, заставит вас создавать всё больше и больше классов для перечисления всех возможных вариантов.

Чтобы не плодить подклассы, вы можете подойти к решению с другой стороны. Вы можете создать гигантский конструктор `Дома`, принимающий уйму параметров для контроля над создаваемым продуктом. Действительно, это избавит вас от подклассов, но приведёт к другой проблеме.
### Решение 

Паттерн Строитель предлагает вынести конструирование объекта за пределы его собственного класса, поручив это дело отдельным объектам, которые следует называть _строителями_.

Паттерн предлагает разбить процесс конструирования объекта на отдельные шаги (например, `построитьСтены`, `вставитьДвери` и другие). Чтобы создать объект, вам нужно поочерёдно вызывать методы строителя. Причём не нужно запускать все шаги, а только те, что нужны для производства объекта определённой конфигурации.

Зачастую один и тот же шаг строительства может отличаться для разных вариаций производимых объектов. Например, деревянный дом потребует строительства стен из дерева, а каменный — из камня.

В этом случае вы можете создать несколько классов строителей, выполняющих одни и те же шаги по-разному. Используя этих строителей в одном и том же строительном процессе, вы сможете получать на выходе различные объекты.

Например, один строитель делает стены из дерева и стекла, другой из камня и железа, третий из золота и бриллиантов. Вызвав одни и те же шаги строительства, в первом случае вы получите обычный жилой дом, во втором — маленькую крепость, а в третьем — роскошное жилище. Замечу, что код, который вызывает шаги строительства, должен работать со строителями через общий интерфейс, чтобы их можно было свободно взаимозаменять.

#### Директор

Вы можете пойти дальше и выделить вызовы методов строителя в отдельный класс, называемый _директором_. В этом случае директор будет задавать порядок шагов строительства, а строитель — выполнять их.

Отдельный класс директора не является строго обязательным. Вы можете вызывать методы строителя и напрямую из клиентского кода. Тем не менее, директор полезен, если у вас есть несколько способов конструирования продуктов, отличающихся порядком и наличием шагов конструирования. В этом случае вы сможете объединить всю эту логику в одном классе.

Такая структура классов полностью скроет от клиентского кода процесс конструирования объектов. Клиенту останется только привязать желаемого строителя к директору, а затем получить у строителя готовый результат.

### Пример

Рассмотрим пример системы для построения различных типов домов. Здесь мы будем использовать паттерн Строитель для создания домов с разными характеристиками.

Определим класс `House`, который представляет собой конечный продукт, который мы будем строить.

```java
public class House {
    private String foundation;
    private String walls;
    private String roof;

    // Геттеры
	...
    // Сеттеры
    ...
}
```

Создадим интерфейс `HouseBuilder`, который определяет методы для установки различных частей дома.

```java
public interface HouseBuilder {
    void buildFoundation();
    void buildWalls();
    void buildRoof();
    House getResult();
}
```

Реализуем конкретные строители для создания различных типов домов.

```java
public class ModernHouseBuilder implements HouseBuilder {
    private House house;

    public ModernHouseBuilder() {
        this.house = new House();
    }

    @Override
    public void buildFoundation() {
        house.setFoundation("Modern Foundation");
    }

    @Override
    public void buildWalls() {
        house.setWalls("Modern Walls");
    }

    @Override
    public void buildRoof() {
        house.setRoof("Modern Roof");
    }

    @Override
    public House getResult() {
        return house;
    }
}

public class ClassicHouseBuilder implements HouseBuilder {
    private House house;

    public ClassicHouseBuilder() {
        this.house = new House();
    }

    @Override
    ...
}
```

Создадим класс `Director`, который будет использовать строителя для создания объекта.

```java
public class Director {
    private HouseBuilder builder;

    public Director(HouseBuilder builder) {
        this.builder = builder;
    }

    public void constructHouse() {
        builder.buildFoundation();
        builder.buildWalls();
        builder.buildRoof();
    }
}
```

Клиентский код использует директора и строителя для создания различных типов домов.

```java
public class BuilderDemo {
    public static void main(String[] args) {
        // Создаем строителя для современного дома
        HouseBuilder modernHouseBuilder = new ModernHouseBuilder();
        Director director = new Director(modernHouseBuilder);
        director.constructHouse();
        House modernHouse = modernHouseBuilder.getResult();
        System.out.println("Modern House: " + modernHouse);

        // Создаем строителя для классического дома
        HouseBuilder classicHouseBuilder = new ClassicHouseBuilder();
        director = new Director(classicHouseBuilder);
        director.constructHouse();
        House classicHouse = classicHouseBuilder.getResult();
        System.out.println("Classic House: " + classicHouse);
    }
}
```

### Шаги реализации

1. Убедитесь в том, что создание разных представлений объекта можно свести к общим шагам.
    
2. Опишите эти шаги в общем интерфейсе строителей.
    
3. Для каждого из представлений объекта-продукта создайте по одному классу-строителю и реализуйте их методы строительства.
    
    Не забудьте про метод получения результата. Обычно конкретные строители определяют собственные методы получения результата строительства. Вы не можете описать эти методы в интерфейсе строителей, поскольку продукты не обязательно должны иметь общий базовый класс или интерфейс. Но вы всегда сможете добавить метод получения результата в общий интерфейс, если ваши строители производят однородные продукты с общим предком.
    
4. Подумайте о создании класса директора. Его методы будут создавать различные конфигурации продуктов, вызывая разные шаги одного и того же строителя.
    
5. Клиентский код должен будет создавать и объекты строителей, и объект директора. Перед началом строительства клиент должен связать определённого строителя с директором. Это можно сделать либо через конструктор, либо через сеттер, либо подав строителя напрямую в строительный метод директора.
    
6. Результат строительства можно вернуть из директора, но только если метод возврата продукта удалось поместить в общий интерфейс строителей. Иначе вы жёстко привяжете директора к конкретным классам строителей.

### Отношения с другими паттернами

- Многие архитектуры начинаются с применения [[GoF Фабричный метод]]  (более простого и расширяемого через подклассы) и эволюционируют в сторону [[GoF Абстрактная фабрика]], [[GoF Прототип|Прототипа]] или [[GoF Строитель|Строителя]] (более гибких, но и более сложных).
    
- **Строитель** концентрируется на построении сложных объектов шаг за шагом. [[GoF Абстрактная фабрика]] специализируется на создании семейств связанных продуктов. _Строитель_ возвращает продукт только после выполнения всех шагов, а _Абстрактная фабрика_ возвращает продукт сразу же.
    
- **Строитель** позволяет пошагово сооружать дерево [[GoF Компоновщик]].
    
- Паттерн **Строитель** может быть построен в виде [[GoF Мост]]: _директор_ будет играть роль абстракции, а _строители_ — реализации.
    
- [[GoF Абстрактная фабрика]], **Строитель** и [[GoF Прототип]] могут быть реализованы при помощи [[GoF Одиничка]].

# Resources

- Habr - 2021. [Паттерн проектирования Builder (Строитель) в Java](https://habr.com/ru/companies/otus/articles/552412/)
- [Builder Pattern. Стручков](https://garden.struchkov.dev/ru/dev/architecture/Builder-Pattern)
- 