## Паттерн Saga

Иногда как альтернативу 2PC можно использовать паттерн Saga. Этот паттерн подходит в случае, если в проекте несколько микросервисов со своими хранилищами.

Допустим, у нас есть три микросервиса: сервис обработки заказов и сервис обработки оплаты и сервис доставки, у каждого своя база данных. Нужно сделать атомарную транзакцию в этих трех базах.

Это можно сделать с помощью двух видов паттерна Saga:

1. Choreography
2. Orchestration

### Choreography

1. В сервис обработки заказов приходит событие - создание заказа.
2. Он запускает транзакцию у себя в базе и посылает в сервис оплаты событие - произведение оплаты.
3. Сервис оплаты делает изменение у себя в базе и шлет событие в сервис доставки.
4. Сервис доставки делает изменение у себя в базе.

Теперь, что происходит в случае, если один из микросервисов не смог сделать локальную транзакцию? Тогда запускается механизм отката всех предыдущих транзакций. Но так как транзакции у других сервисов уже закоммичены просто откатить транзакцию уже нельзя. Что же делать?

Одно из требований паттерна - наличие отменяющий транзакций, которые запускаются сервисом, чтобы отменить то, что поменяла исходная транзакция.

Например, сервис доставки в исходной транзакции сделал в таблице delivery своей базы запись с информацией о доставке. Чтобы отменить это изменение, нужно сделать транзакцию, которая будет удалять эту запись.

Также Saga требует, чтобы отменяющая транзакция была [идемпотентна](https://ru.wikipedia.org/wiki/%D0%98%D0%B4%D0%B5%D0%BC%D0%BF%D0%BE%D1%82%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C), то есть результат нескольких ее выполнений равен результату одного ее выполнения. Это необходимо, для возможности перепроигрывания отменяющей транзакции до тех пор, пока она не сможет закоммититься.

Итак, пусть у сервиса доставки не получилось закоммитить исходную транзакцию, тогда:

1. Сервис доставки запускает отменяющую транзакцию и шлет событие сервису оплаты - отмена оплаты.
2. Сервис оплаты запускает отменяющую транзакцию и шлет событие сервису обработки заказов - отмена заказа.
3. Сервис обработки заказов запускает отменяющую транзакцию.
4. Сервис обработки заказов может инициировать процесс распределенной транзакции заново.

### Orchestration

В этом варианте есть некоторый центральный элемент, им может быть один из уже существующих сервисов или отдельный сервис, который занимается исключительно координацией транзакций.

1. Координатор шлет запрос об обработке заказа сервису обработки заказов.
2. Когда сервис обработки заказов успешно закоммитил свои изменения, он шлет подтверждение координатору.
3. Координатор шлет запрос об обработке оплаты сервису оплаты.
4. Когда сервис оплаты успешно закоммитил свои изменения, он шлет подтверждение координатору.
5. Координатор шлет запрос об обработке доставки сервису доставки.
6. Когда сервис доставки успешно закоммитил свои изменения, он шлет подтверждение координатору.

В случае сбоя на одном из микросервисов, координатор организует запуск отменяющих транзакций у соответствующих сервисов.

## Особенности Saga

- Saga работает в микросервисной архитектуре
- Требует от разработчика реализации идемпотентных отменяющих транзакций
- Реализация паттерна Saga довольно трудоемкий процесс
- Система может находиться какое-то время не в консистентном состоянии

- Управляет набором распределенных несвязанных транзакций. Если в цепочке транзакций что-то упало - использует компенсирующие транзакции.
- **Хареография** - сами микросервисы управляют транзакциями
- **Оркестровка** - есть сервис, обязанность которого управлять транзакциями.
- Каждое сообщение должно обладать ключом идемпотентности, чтобы сервисы понимали, обработали они сообщение или нет
- Событие должно доставляться at most once

Этот паттерн предназначен для управления распределенными транзакциями в микросервисной архитектуре, где применение традиционного протокола двухфазной фиксации транзакций (Two-phase commit protocol, 2PC) становится трудноосуществимым.

При использовании паттерна каждая локальная транзакция обновляет данные в хранилище в рамках одного микросервиса и публикует событие или сообщение, которые, в свою очередь, запускают следующую локальную транзакцию и так далее. Если локальная транзакция завершается с ошибкой, выполняется серия компенсирующих транзакций, которые отменяют изменения предыдущих транзакций.

Для координации транзакций существует два основных способа:

- **Хореография.** Децентрализованная координация, при которой каждый микросервис прослушивает события/сообщения другого микросервиса и решает, следует предпринять действие или нет.
- **Оркестровка.** Централизованная координация, при которой отдельный компонент (оркестратор) сообщает микросервисам, какое действие необходимо выполнить далее.

⠀ Использование шаблона обеспечивает согласованность транзакций в слабосвязанных распределенных системах, однако увеличивает сложность отладки. Saga отлично подходит для систем, управляемых событиями и/или использующих базы данных NoSQL без поддержки 2PC, но не рекомендуется при использовании баз данных SQL и в системах с циклическими зависимостями между сервисами.

![[Pasted image 20241215100623.png]]


>Транзакция проходит через каждый сервис. Если сервис обработал запрос успешно, он отправляет свой результат следующему сервису и так пока транзакция не обработается полностью. Если на этапе одного и сервисов произошла ошибка, сообщает предыдущему сервису что нужно запустить компенсирующую транзакцию, отмена всех внесенных изменений.

![[Pasted image 20240928153929.png]]

- Атомарность (+): сага гарантирует что локальные транзакции выполняются, либо в случае неудаче компенсируются
- Согласованность (+): после успешного выполнения всех транзакций, составляющих сагу, все системы переводятся из одного согласованного состояния в другое
- Изоляция (-): уровень изоляции сравним с "read uncommitted". Транзакции коммитятся во время выполнения, их изменения видны другим параллельным транзакциям, несмотря на то что все может завершится сбоем, в результате чего ранее примененные транзакции будут компенсированы. 
- Надежность (+): после коммита локальных транзакций, их изменения сохраняются даже в случае сбоя сервиса и перезапуска.


- Паттерн Saga используется для управления долгими транзакциями в распределенных системах. Вместо выполнения всех операций в одной транзакции, Saga разбивает их на несколько мелких операций, каждая из которых выполняется отдельно.
- Если одна из операций завершится неудачно, Saga запускает компенсационные действия для отмены предыдущих успешных операций. Существует два типа Sagas: **Choreography**, где участники сами управляют своей частью, и **Orchestration**, где централизованный координатор управляет последовательностью операций.
- Преимущества: уменьшает вероятность блокировок и увеличивает масштабируемость, поскольку каждая операция может быть выполнена независимо.


- Плюсы:
	- Позволяет достигнуть согласованности распределенных транзакций.
	- Масштабируемость
	- Слабая связанность участников
- Минусы:
	- сложно отлаживать и тестировать
	- очень сложно предотвратить проблемы, которые решаются изоляциями (lost update, dirty read, non-repeatable read)