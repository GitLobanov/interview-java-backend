> 1. Для чего был создан REST?

- Representational — ресурсы в REST могут быть представлены в любой форме — JSON, XML, текст, или даже HTML — зависит от того, какие данные больше подходят потребителю
- State — при работе с REST вы должны быть сконцентрированы на состоянии ресурса, а не на действиях с ресурсом
- Transfer — REST включает себя передачу ресурсных данных, в любой представленной форме, от одного приложения другому.

REST это передача состояний ресурса между сервером и клиентом.

> 2. Что такое ресурс?

Ресурс в REST — это все, что может быть передано между клиентом и сервером.  Вот несколько примеров ресурсов:

- Новость
- Температура в Санкт-Петербурге в понедельник в 4 утра
- Зарплата сотрудника
- Выборка из базы данных
- Результат поиска

> 3. Что обозначает CRUD?

Действия в REST определяются http-методами.  
`Get`, `Post`, `Put`, `Delete`, `Patch`, и другие.

Самые часто-используемые обозначаются аббревиатурой CRUD:

- Create — `POST`
- Read — `GET`
- Update — `PUT`
- Delete — `DELETE`

> 4. REST безопасен? Как вы можете защитить его?

По умолчанию REST не защищен. Вы можете настроить безопасность с помощью Basic Auth, JWT, OAuth2

> 5. Что такое save operations? Безопасные методы

Это операции, которые не модифицируют ресурсы.

- GET
- HEAD
- OPTIONS

> 6. Что такое идемпотентая операция? Почему идемпотентность важна? 

Идемпотентые методы — это методы, при каждом вызове которых результат будет одинаковый.

То есть, результат после 1 вызова такого метода будет такой же, как и результат после 10 вызовов этого метода.

Это важно для отказоустойчевого API. Предположим, что клиент хочет обновить ресурс с помощью POST-запроса? Если POST не идемпотентный метод, то при многократном вызове возникнут непредвиденные обновления ресурса. Используя идемпотентные методы, вы ограждаете себя от многих ошибок.

> 7. REST хорошо масштабируется?

Да. REST хорошо масштабируется потому что он не хранит состояние. Это значит что он не хранит информацию о пользовательских сессиях на сервере. Информация о клиенте не должна хранится на стороне сервера, а должна передаваться каждый раз туда, где она нужна. Вот что значит ST в REST, State Transfer. Вы передаете состояние, а не храните его на сервере.

REST также интероперабельный — это значит, что на нем могут взаимодействовать разные программы написанные на разных языках. Это исходит из 2ух факторов:

- Интероперабельные HTTP-клиенты. Разные клиенты должны отправлять одинаковые http-запросы.
- Интероперабельность на уровне медиа-типов. Различные клиенты должны корректно отправлять и получать одни и те же ресурсы.

> 8. Что такое HttpMessageConverter?

`HttpMessageConverter` конвертирует запрос в объект и наоборот.

Spring имеет несколько реализаций этого интерфейса, а вы можете создать свою.

В этом случае `DispatcherServlet` не использует Model и View.

В REST вообще не существует Model и View. Есть только данные, поставляемые контроллером, и представление ресурса, когда сообщение конвертируется из медиа-типа(json, xml...) в объект.

Список конвертеров:

`BufferedImageHttpMessageConverter` — конвертирует `BufferedImage` в(из) код изображения.

`Jaxb2RootElementHttpMessageConverter` — конвертирует xml в(из) объект, помеченный jaxb2 аннотациями. Регистрируется, если jaxb2 находится в classpath.

`MappingJackson2HttpMessageConverter` — конвертирует JSON в(из) объект. Регистрируется, если Jackson 2 находится в classpath.

`StringHttpMessageConverter` — конвертирует все медиа-файлы в text/plain.

> 9. Как работает аннотация @RestController?

`@RestController` ставится на класс-контроллер вместо `@Controller`. Она указывает, что этот класс оперирует не моделями, а данными. Она состоит из аннотаций `@Controller` и `@RequestBody`.

[[@Controller vs @RestController]]

> 10. Зачем нужна @ResponseBody?

Аннотация `@ResponseBody` ставится на методы, которые работают с данными, а не с моделями. Ее не требуется указывать явно, если используется `@RestController`.

Обычные методы возвращают `Model`, а методы аннотированные `@ResponseBody` возвращают объекты, которые конвертируются в медиа-файлы с помощью `HttpMessageConverter`.

> 11. Что делает аннотация @RequestMapping?

Эта аннотация служит для маппинга запросов на классы-контроллеры и методы.  Раньше ее использовали для методов класса, чтобы указать URI, http-метод, тип отправляемых данных, и т.п. В более новых версиях Spring ее заменили на аннотации `@GetMapping`, `@PostMapping`, и т.п.

Теперь она используется только для указания URI до класса-контроллера.

> 12. Что за аннотации @GetMapping, @PostMapping, @DeleteMapping и прочие?

Это более узкие аннотации для маппинга http-методов.

- `@GetMapping` — Обрабатывает get-запросы
- `@PostMapping` — Обрабатывает post-запросы
- `@DeleteMapping` — Обрабатывает delete-запросы
- `@PutMapping` — Обрабатывает put-запросы
- `@PatchMapping` — Обрабатывает patch-запросы

Аннотация @GetMapping — это просто аннотация которая содержит _@RequestMapping(method = RequestMethod.GET)_.  
Она также позволяет более глубоко настроить метод-обработчик.  
Ее параметры(они конвертируются в аналогичные параметры @RequestMapping):

- `path` — URI
- `headers` — заголовки
- `name` — имя обработчика
- `params` — [параметры](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/RequestMapping.html#params--)
- `produces` — тип возвращаемых данных(JSON, XML, текст). Используется в REST
- `consumes` — тип принимаемых данных. Используется в REST

По умолчанию аннотация принимает путь до метода.
`@GetMapping("managers") = @GetMapping(path = "managers")`

> 13. Зачем используется аннотация @RequestParam?

Эта аннотация используется для того, чтобы методы обработчики могли получить параметры из http-запроса.

Запрос с параметрами: `http://localhost:8080/getByName/name=Ivan`.  
Следующий код поместит в переменную `name` строку `Ivan`.

> 14. Зачем нужна аннотация @PathVariable? 

Эта аннотация получает определенную часть из URI.

URI: `http://localhost:8080/getById/23`

@GetMapping("getById/{id}")

> 15. Что обозначают разные коды для http-ответов?

- GET — 200 OK
- POST — 200 OK, 201 Created, 204 No Content
- PUT — 200 OK, 201 Created, 204 No Content
- DELETE — 204 No Content, 202 Accepted

> 16.  Зачем нужна аннотация @ResponseStatus?

Она позволяет устанавливать код ответа. Обычно Spring сам устанавливает нужный код ответа, но бывают моменты, когда это нужно переопределить.

Вместо использования аннотации можно возвращать `ResponseEntity` и вручную устанавливать код ответа. Не рекомендуется использовать `ResponseEntity` и `@ReponseStatus` вместе.

> 17. Что такое ResponseEntity?

Это [специальный класс](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/http/ResponseEntity.html), который представляет http-ответ. Он содержит тело ответа, код состояния, заголовки. Мы можем использовать его для более тонкой настройки http-ответа.

> 18. Зачем нужны @RequestBody?

Вы можете использовать аннотацию `@RequestBody` на параметре метода, для того чтобы тело запроса конвертировалось в этот параметр. Вы можете использовать `@Validated` вместе с `@RequestBody`, для проверки пришедшего запроса.

> 19. Что такое RestTemplate? Какие у него преимущества?

[RestTemplate](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html) это специальный клиент в Spring для отправки http-запросов. Он предоставляет удобные API для легкого вызова конечных точек REST’а в одну строку.

```java
RestTemplate restTemplate = new RestTemplate();
String fooResourceUrl = "http://localhost:8080/spring-rest/foos";
ResponseEntity response  = restTemplate.getForEntity(fooResourceUrl + "/1", String.class);
```



