Это ситуация, когда транзакция читает данные, которые были изменены другой транзакцией, но еще не зафиксированы. Если вторая транзакция откатится, данные, которые были прочитаны, окажутся невалидными.

![[Pasted image 20240829200402.png]]

Грязные чтения могут приводить, например, к ситуациям, когда:

- Транзакция, с несколькими операциями записи, откатилась, записав только часть. Тогда другие транзакции смогут увидеть состояние БД, в которой часть данных - неактуальна.
- Транзакция, делает записи, но происходит `ROLLBACK`. Соседние транзакции могут успеть прочитать данные, которые тут же будут откатаны.

То есть `dirty reads` ломают атомарность и консистентность (**A** и **C** из ACID).

Уровень `read commited`, гарантирующий, что читать и обновлять можно только закоммиченные данные, исключает аномалию грязных чтений. Чтобы реализовать этот уровень изоляции, базы данных могут:

- Устанавливать блокировки на чтение и запись, чтобы в каждый момент только одна транзакция имела доступ к объекту. Но такой подход сильно увеличивает время отклика для чтения.
- Сохранять две копии изменяемого объекта, актуальную на момент начала транзакции и новую, с которой работает транзакция. Тогда во время транзакции все чтения видят только старый объект, а после коммита - новый. Этим методом пользуются большинство БД.