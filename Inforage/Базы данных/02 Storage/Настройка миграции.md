Как бы хорошо вы не спроектировали схему БД, в какой-то момент придется вносить изменения в ее структуру (и данные, как следствие), так как требования могут меняться со временем. Переход от старой схемы базы к новой называется миграцией. Изменения структуры применяются прямо к живой продакшен-базе.

Необходимость мигрировать базу влечет возникновение проблем в случае, если накаты производятся "руками", не автоматически:

1. Как в каждый момент времени понять, была ли уже накачена миграция или нет? Без этого знания можно легко потерять что-то важное или ошибочно промигрировать дважды. Например, добавление поля в таблицу делается с помощью команды `ALTER TABLE ADD`. Выполнять это выражение имеет смысл ровно один раз, когда в таблице поле ещё отсутствует, а необходимость в нём уже есть. В другие моменты запуск команды приведёт либо сразу к ошибке, либо, что хуже, к неправильному состоянию структуры базы данных.
2. Миграций обычно много. Некоторые могут зависеть друг от друга. Нужно тратить временя и силы на поддержание "правильного порядка" наката скриптов.
3. Вы работаете в команде с другими разработчикам, из-за этого могут возникать конфликты в миграциях или перезатирания изменений друг друга.

Что мы хотим получить в итоге:

- Любую версию базы данных можно обновить до любой (обычно, самой последней) версии.
- Набор SQL-запросов, реализующих миграцию между любыми двумя версиями, можно было получить как можно быстрее и проще.
- Всегда можно создать с нуля базу данных со структурой самой последней версии.
- Возможность одновременной работы нескольких людей.
- Откатить БД на более раннюю версию так же просто, как и обновить на более новую.

Один из вариантов организации процесса работы с миграциями БД, который разрешает перечисленные проблемы, это _метод инкрементальных изменений_. Внесение изменений в БД производится через специальный новый файл миграции (_changeset_). Он подключается в главный файл (_changeLog_), который контролирует версии и управляет всеми изменениями.

Каждый _changeset_ имеет уникальный идентификатор, для простоты обычно берется путь файла. На стороне БД создается таблица, дублирующая наш _changeLog_-файл (_databasechangelog_). При накате изменений на БД анализируется _changeLog_-файл и для каждого _changeset_'а проверяется таблица _databasechangelog_. Если в таблице есть запись с таким же id, то _changeset_ считается выполненным и будет пропущен. Если записи нет, то выполняются команды из _changeset_'а, а в _databasechangelog_ сохраняется запись о завершенном _changeset_'е. После просмотра всего _changeLog_ БД перейдет в актуальное состояние. _changeLog_ и все _changeset_'ы можно хранить в git'е вместе с исходным кодом приложения.

Этот подход реализует система управления миграциями [Liquibase](https://www.liquibase.org/). _**Liquibase**_ — это независимая от базы данных библиотека для отслеживания, управления и применения изменений схем базы данных. В качестве описания структуры и изменений базы данных используется XML, YAML, JSON и SQL форматы. Существуют и другие системы управления миграциями (DBDeploy, Doctrine 2 migrations и т.д.), некоторые из них платформозависимые, некоторые не обладают таким широким функционалом, как Liquibase.

Liquibase можно использовать как обычное Java приложение. Для этого нужно просто скачать соответствующий JAR-файл и вызывать `java -jar liquibase.jar`, передав в аргументах путь до _changeLog_-файла и параметры подключения к БД. Но удобней использовать [liquibase-maven-plugin](https://mvnrepository.com/artifact/org.liquibase/liquibase-maven-plugin). Тогда можно будет встроить управление миграциями в жизненный цикл вашего приложения. Например, накатывать новую версию БД перед деплоем приложения.