Алгоритм двоичного поиска — это эффективный способ поиска элемента в **отсортированном массиве**. Он работает за счет последовательного деления массива пополам и исключения той половины, в которой искомый элемент точно не находится. Этот метод существенно уменьшает количество проверок, сокращая время поиска.

- Начало: Мы берем **отсортированный массив** и устанавливаем два указателя — один на начало массива (левый индекс), другой на конец (правый индекс).
- Средний элемент: **На каждом шаге находим индекс среднего элемента массива**. $средний индекс=(левый индекс+правый индекс)​ / 2$
- Сравнение: Сравниваем средний элемент с искомым значением:
    - Если средний элемент равен искомому значению, поиск завершен.
    - Если искомое значение меньше среднего элемента, то дальнейший поиск проводится в **левой половине массива** (уменьшаем правый индекс).
    - Если искомое значение больше среднего элемента, то поиск продолжается в **правой половине массива** (увеличиваем левый индекс).
- Повтор: Процесс повторяется с обновленными границами (левым и правым индексами), пока элемент не будет найден или пока границы не сойдутся (что означает отсутствие элемента в массиве).

![[thuat-toan-tim-kiem-tuyen-tinh.gif]]

Сложность:

- Время выполнения: O(log n), где n — количество элементов в массиве.
- Пространственная сложность: O(1) для итеративной версии и O(log n) для рекурсивной версии (из-за глубины стека вызовов рекурсии).

Когда алгоритм наиболее эффективен:

- Когда нужно искать элементы в **большом** и **отсортированном массиве**.
- Когда есть **быстрый доступ** к элементам по индексу (например, в обычном массиве или векторах).

![[Pasted image 20241202065556.png]]

Binary tree digradation

![[1dcffbc7ea6ae5906cc1352ed8d6ad6d.gif]]