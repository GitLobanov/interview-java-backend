Either как замена выбрасыванию исключений

Either из библиотеки с открытым исходным кодом Vavr, представляет из себя контейнер, который может содержать одно из двух значений: либо "левое", либо "правое". Существует общепринятая практика, согласно которой правое значение соответствует какому-либо значению, а левое - ошибке/исключению.
Either похож на Optional, но только если Optional содержит или не содержит значение, то Either содержит либо значение либо ошибку.

Давайте посмотрим на простой пример:

```java
public Either<String, Integer> parseInt(String input) {
    try {
        return Either.right(Integer.parseInt(input));
    } catch (NumberFormatException e) {
        return Either.left("Invalid number format: " + input);
    }
}
```

Данным метод принимает строку и пытается преобразовать ее в Integer. В случае успеха мы записываем значение в правую часть Either (Either.right). 
Если входная строка не может быть преобразована в число, то метод вернет информацию об ошибке в левой части Either (Either.left). 
Таким образом, мы заменили выбрасывание исключения на кастомное представление об ошибке.

Самое интересное - как можно обрабатывать результат подобного метода:

```java
Either<String, Integer> result = parseInt("123");
result
    .peek(value -> System.out.println("Success: " + value))
    .peekLeft(error -> System.err.println("Error: " + error));
```

Принято сначала обрабатывать положительные результаты, а затем ошибочные.
В данном примере peek выполнит команду для вывода успешного результата, а в случае ошибки выполнится peekLeft.

Операции, которые часто используются с Either:
-  фильтрации .filter(...);
-  преобразования .map(...),  .mapLeft(...);
-  проверять наличие значения в левой или правой части .isLeft(), .isRight().
И это только малая часть функционала!

Either хорошо сочетается с функциональным стилем программированием. Если вы любите использовать в своих программах Stream и Optional, то попробуйте Either.
Интегрировав этот паттерн в свою программу, вы заметите, как ваш код станет более чистым и структурированным. Вы избавитесь от необходимости бесконечного пробрасывания и отлавливания Exception, постоянных try-catch и пр, заменив их на понятную цепочку вызовов.
