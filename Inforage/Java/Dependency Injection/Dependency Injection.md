---
Определение: Зависимости (например, сервисы, базы данных, репозитории и т.д.) передаются объектам внешним образом, а не создаются ими самими. Это способствует лучшей модульности и облегчает тестирование.
Примечание:
---
### Основные идеи Dependency Injection:

1. **Инверсия управления (IoC)**:
    
    - Объект сам не создает свои зависимости, а получает их извне (от "контейнера" или другого управляющего компонента). Таким образом, логика управления созданием зависимостей переносится за пределы объекта.
2. **Разные способы внедрения зависимостей**:
    
    - **Через конструктор** — зависимости передаются через параметры конструктора.
    - **Через методы (сеттеры)** — зависимости могут быть переданы через специальные методы.
    - **Через интерфейсы** — объект получает зависимости через реализацию интерфейсов.

### Пример использования DI в приложении по трекингу времени:

Допустим, есть сервис для трекинга задач, который зависит от репозитория, где хранятся данные о задачах:

#### Без Dependency Injection:

```java
public class TaskService {
    private TaskRepository taskRepository = new TaskRepository(); // Жесткая зависимость

    public void trackTask(String taskId) {
        taskRepository.saveTask(taskId);
    }
}
```

В этом случае класс `TaskService` сам создает экземпляр `TaskRepository`. Если нужно будет изменить реализацию репозитория (например, на другую базу данных), придется изменить код внутри класса, что усложняет поддержку и тестирование.

#### С Dependency Injection:

```java
public class TaskService {
    private TaskRepository taskRepository;

    // Зависимость передается через конструктор
    public TaskService(TaskRepository taskRepository) {
        this.taskRepository = taskRepository;
    }

    public void trackTask(String taskId) {
        taskRepository.saveTask(taskId);
    }
}
```

В этом случае класс `TaskService` сам создает экземпляр `TaskRepository`. Если нужно будет изменить реализацию репозитория (например, на другую базу данных), придется изменить код внутри класса, что усложняет поддержку и тестирование.

#### С Dependency Injection:

```java
public class TaskService {
    private TaskRepository taskRepository;

    // Зависимость передается через конструктор
    public TaskService(TaskRepository taskRepository) {
        this.taskRepository = taskRepository;
    }

    public void trackTask(String taskId) {
        taskRepository.saveTask(taskId);
    }
}
```

Теперь класс `TaskService` не создает зависимость сам. Вместо этого он получает `TaskRepository` извне (например, через конструктор). Это делает код более гибким и легко тестируемым — при написании тестов можно передать mock-объект вместо реального репозитория.

### Преимущества DI:

1. **Тестируемость**: Благодаря инверсии управления, классы легко тестировать, поскольку можно легко передать mock-объекты вместо реальных зависимостей.
2. **Гибкость**: Зависимости можно менять без необходимости модифицировать класс. Например, можно заменить реализацию репозитория на другую без изменения логики сервиса.
3. **Повышенная модульность**: Каждый компонент может быть разработан, протестирован и использован независимо от других компонентов.

### Примеры DI-фреймворков:

1. **Spring Framework**: Один из самых популярных DI-фреймворков для Java, использующий аннотации, такие как `@Autowired`, для автоматической инъекции зависимостей.
2. **Guice**: Легковесный DI-фреймворк от Google, который использует аннотации для внедрения зависимостей.

Таким образом, **Dependency Injection** улучшает структуру кода, делая его более гибким, легко поддерживаемым и модульным.

