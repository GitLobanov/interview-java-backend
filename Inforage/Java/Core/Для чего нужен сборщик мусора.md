Сборщик мусора (Garbage Collector) должен делать всего две вещи:

- Находить мусор - неиспользуемые объекты. (Объект считается неиспользуемым, если ни одна из сущностей в коде, выполняемом в данный момент, не содержит ссылок на него, либо цепочка ссылок, которая могла бы связать объект с некоторой сущностью приложения, обрывается);
- Освобождать память от мусора.

## Подходы к обнаружению мусора

Используют два основных метода для определения, какие объекты больше не нужны:

### 1. **Reference Counting** (подсчёт ссылок):

Метод отслеживает количество ссылок на объект. Когда счётчик ссылок достигает нуля, объект считается ненужным и может быть удалён. Однако этот метод имеет серьёзное ограничение — он не справляется с циклическими зависимостями, когда два объекта ссылаются друг на друга, создавая "ловушку", где память не освобождается.

### 2. **Tracing Garbage Collection** (трассировка):

Это наиболее распространённый метод в современных сборщиках мусора. Он основан на использовании **корневых точек** — начальных ссылок, с которых начинается анализ всех доступных объектов. Объекты, которые не могут быть достигнуты из этих точек, считаются мусором и подлежат удалению. Этот метод решает проблему циклических зависимостей и широко используется в популярных виртуальных машинах, таких как JVM и .NET CLR.

## Корневые точки в современных системах

**Корневые точки** — это основные ссылки, с которых сборщик мусора начинает свою работу. В JVM это могут быть:

1. **Локальные переменные и параметры методов** — данные, которые находятся в стеке вызовов методов.
2. **Потоки** — активные потоки программы содержат ссылки на объекты, которые они используют.
3. **Статические переменные** — переменные класса, которые существуют на протяжении всего времени работы программы.
4. **Ссылки из JNI (Java Native Interface)** — объекты, взаимодействующие с нативным кодом через JNI.

Даже самое простое Java-приложение будет иметь хотя бы одну корневую точку — это метод `main()` и его локальные переменные.

## Методы очистки памяти

Современные сборщики мусора применяют несколько основных подходов для очистки памяти:

### 1. **Copying Collectors** (копирующие сборщики):

Этот метод активно используется для управления молодыми объектами, которые существуют недолго. Память делится на две области: активную и свободную. Когда активная область заполняется, все «живые» объекты копируются в свободную область, а затем активная очищается. Это эффективно предотвращает фрагментацию памяти и обеспечивает быстрые сборки для молодых объектов.

### 2. **Mark-and-Sweep** (отметка и очистка):

Этот метод обычно применяется для более старых объектов, которые существуют дольше. Сначала сборщик мусора помечает все доступные объекты через корневые точки, а затем очищает память от неиспользуемых объектов. Однако метод может привести к фрагментации памяти, и для решения этой проблемы часто используются дополнительные алгоритмы, такие как **compact** (уплотнение памяти).

**Compact (уплотнение памяти)** — это процесс, который применяется после основного этапа сборки мусора, чтобы решить проблему **фрагментации памяти**.

Когда используется метод сборки мусора **Mark-and-Sweep** (отметка и очистка), сборщик помечает "живые" объекты, а затем удаляет все остальные, не двигая объекты. Однако это может привести к тому, что свободные участки памяти (дырки) будут разбросаны по всей области памяти. Эти разрозненные куски свободного пространства затрудняют эффективное выделение новых объектов, особенно если требуется большой блок непрерывной памяти.

**Процесс уплотнения (compaction)** перемещает "живые" объекты, чтобы собрать все их вместе в одну непрерывную область, а свободное пространство переместить в конец. Это позволяет избежать фрагментации и позволяет программе более эффективно использовать оставшуюся память.

### Пример:

1. До уплотнения: Память содержит несколько "живых" объектов, разбросанных по всей области, и фрагментированное свободное пространство.
2. После уплотнения: Все "живые" объекты сжаты в одну область, а свободное место собрано в единый блок.

В современных сборщиках, таких как **G1** и **ZGC**, уплотнение является частью гибридного подхода, который минимизирует задержки и управляет памятью с низкой фрагментацией.

## Современные сборщики мусора

Современные виртуальные машины, такие как JVM, применяют гибридные подходы к сборке мусора, чтобы оптимизировать производительность. Один из наиболее популярных методов — **Generational Garbage Collection** (поколенческая сборка мусора). Он основан на наблюдении, что большинство объектов "живут" недолго. Память делится на несколько поколений:

1. **Молодое поколение** — содержит недавно созданные объекты, которые собираются чаще.
2. **Старшее поколение** — содержит объекты, которые "выжили" после нескольких сборок в молодом поколении. Эти объекты обрабатываются реже.
3. **Metaspace** (вместо постоянного поколения) — используется для хранения метаданных классов.

Современные JVM предлагают несколько сборщиков мусора, каждый из которых оптимизирован под разные задачи:

- **G1 (Garbage First)** — это адаптивный сборщик, который минимизирует паузы и эффективно работает в многопоточных средах.
- **ZGC (Z Garbage Collector)** и **Shenandoah** — это низколатентные сборщики мусора, которые минимизируют время задержки (латентность) даже в крупных приложениях с огромным объёмом памяти.
- **Epsilon GC** — это "нулевой" сборщик мусора, который вообще не занимается сборкой мусора, предоставляя полный контроль памяти разработчикам.

Эти новые методы позволяют JVM и другим современным виртуальным машинам быть максимально эффективными и адаптивными к разным сценариям использования — от микросервисов до высоконагруженных серверных приложений.

## Hype о Zero-Latency сборщиках

Новые тренды в сборщиках мусора, такие как **ZGC** и **Shenandoah**, стали особенно важны в последние годы, когда низкая задержка и высокая пропускная способность стали критичными для распределённых систем и облачных сервисов. Эти сборщики минимизируют "паузы" для очистки памяти, обеспечивая более плавную работу приложений, что особенно важно для реального времени, больших данных и многопользовательских систем.