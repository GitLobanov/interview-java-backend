---
Определение: Он используется для создания неизменяемых объектов (immutable objects), которые в основном предназначены для хранения данных.
Примечание:
---
### Зачем нужны **Record** в Java:

 Если тебе нужно создать простой класс, который хранит данные (например, DTO или класс для передачи значений), обычно требуется писать много шаблонного кода, такого как конструкторы, методы `equals()`, `hashCode()`, `toString()`, а также геттеры. `Record` автоматически генерирует этот код для тебя.
    
**Пример до появления Records**:
    
```java
public class Person {
    private final String name;
    private final int age;

    public Person(String name, int age) {

    // getters
    ...

    @Override
    public boolean equals(Object o) {

    @Override
    public int hashCode() {

    @Override
    public String toString() {

}
```


**Пример с использованием Records**:

```java
public record Person(String name, int age) {}
```

**Неизменяемость (Immutability)**:

 Объекты `Record` являются неизменяемыми. Это значит, что их поля нельзя изменить после создания объекта. Это делает их идеальными для случаев, когда тебе нужно создать объект с фиксированными данными, которые не должны изменяться.
    
```java
Person p = new Person("Alice", 25);
System.out.println(p.name());  // Alice
// p.name = "Bob"; // Ошибка: поля Record неизменяемы
```
    
**Использование как контейнеры для данных**:

`Record` отлично подходят для создания простых объектов, которые используются как контейнеры для передачи данных между частями программы, особенно в случаях, когда не требуется сложная логика или поведение.

**Чтение конфигураций и маппинг данных**:
 
 Часто `Records` используются для чтения конфигураций из JSON, XML или других форматов данных, поскольку они обеспечивают удобный способ для хранения полученных данных.

```java
public record Person(String name, int age) {}

ObjectMapper mapper = new ObjectMapper();
Person person = mapper.readValue(jsonInput, Person.class);
```

**Работа с неизменяемыми данными в многопоточности**:

В многопоточных приложениях использование неизменяемых объектов улучшает безопасность потоков, так как не нужно беспокоиться о том, что данные изменятся в процессе выполнения потоков. `Records`, благодаря своей неизменяемости, идеально подходят для таких сценариев.

**Использование в качестве ключей в коллекциях**:

Поскольку `Record` автоматически генерирует методы `equals()` и `hashCode()`, их удобно использовать в качестве ключей в коллекциях, таких как `HashMap` или `HashSet`.

```java
record Point(int x, int y) {}

Map<Point, String> map = new HashMap<>();
map.put(new Point(1, 2), "Point A");
System.out.println(map.get(new Point(1, 2))); // Point A
```
    
### Когда использовать **Records**:

- Когда нужен класс для хранения данных (Data Transfer Object, DTO).
- Когда объекты должны быть неизменяемыми.
- Когда требуется минимизировать количество шаблонного кода.
- Для маппинга данных из внешних источников (например, JSON или XML).
- Когда нужны простые классы с хорошо определенной структурой данных.

### Когда не стоит использовать **Records**:

- Когда тебе нужен класс с изменяемыми полями.
- Когда объект должен иметь сложную логику поведения, а не только хранить данные.
- Когда поля объекта должны быть рассчитаны динамически (в `Record` все поля должны быть заданы в момент создания объекта).