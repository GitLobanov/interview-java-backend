# Кратко

В Hibernate есть два основных уровня кэширования:

1. Первичный кэш (Session Cache): это кэш **на уровне одной сессии** Hibernate. Когда вы запрашиваете объект из базы данных через Hibernate, он сначала проверяет, есть ли этот объект в первичном кэше (кэше сессии). Если объект найден, он возвращается из кэша, иначе — из базы данных.
2. Вторичный кэш (Second Level Cache): это глобальный кэш, который доступен для всех сессий Hibernate в пределах одного приложения. Чтобы его использовать, нужно отдельно включить и настроить кэширующую библиотеку (например, EhCache, Infinispan).
# Подробнее
## Уровни кэширования в Hibernate

### 1. Кэш первого уровня (Session Cache)

Описание:

- Расположение: Внутри `Session` (или `EntityManager` в JPA).
- Область действия: Ограничен одним сеансом (session).
- Цель: Хранит объекты в течение одного сеанса для предотвращения повторных запросов к базе данных за одни и те же данные.

Как работает:

- Когда вы загружаете сущность в `Session`, она сохраняется в кэше первого уровня. Если вы запрашиваете ту же сущность снова в том же сеансе, Hibernate возвращает её из кэша, а не выполняет новый запрос к базе данных.

```java
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

Person person1 = session.get(Person.class, 1L); // Запрос к базе данных
Person person2 = session.get(Person.class, 1L); // Возвращает из кэша первого уровня

tx.commit();
session.close();
```

Особенности:

- Время жизни кэша первого уровня совпадает с продолжительностью сеанса.
- Этот кэш всегда включен и не требует дополнительной конфигурации.

### 2. Кэш второго уровня (Second-Level Cache)

Описание:

- Расположение: Внедряется на уровне `SessionFactory`.
- Область действия: Может быть использован несколькими сеансами.
- Цель: Уменьшение количества запросов к базе данных, используя общий кэш для всех сеансов.

Как работает:

- Кэш второго уровня сохраняет данные между сеансами и предоставляет механизм для кэширования сущностей, коллекций и запросов. Для его использования необходимо конфигурировать и интегрировать один из кэширующих провайдеров, таких как EHCache, Infinispan или Redis.

```java
<hibernate-configuration>
    <session-factory>
        <!-- Включение кэша второго уровня -->
        <property name="hibernate.cache.use_second_level_cache">true</property>
        <property name="hibernate.cache.region.factory_class">org.hibernate.cache.ehcache.EhCacheRegionFactory</property>
        <property name="hibernate.cache.use_query_cache">true</property>
        <!-- Другие свойства -->
    </session-factory>
</hibernate-configuration>
```

```java
@Entity
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class Person {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    // геттеры и сеттеры
}
```

Особенности:

- Для использования кэша второго уровня необходимо включить его в конфигурации и настроить кэш-провайдер.
- Требуется дополнительная настройка кэш-провайдера и аннотации в сущностях.

### 3. Кэш запросов (Query Cache)

Описание:

- Расположение: Часто интегрирован с кэшем второго уровня.
- Область действия: Кэширует результаты запросов HQL или Criteria API.
- Цель: Повышение производительности запросов путем кэширования результатов.

Как работает:

- Когда запрос выполняется, его результаты могут быть сохранены в кэше запросов. Если тот же запрос выполнен снова, результаты будут возвращены из кэша, а не выполнены заново.
```java
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

Query query = session.createQuery("FROM Person");
query.setCacheable(true); // Включение кэширования запросов
List<Person> people1 = query.list(); // Запрос выполняется и кэшируется

List<Person> people2 = query.list(); // Возвращает данные из кэша запросов

tx.commit();
session.close();
```

Особенности:

- Для использования кэша запросов необходимо включить его в конфигурации и включить кэширование в запросах.
- Кэширование запросов должно быть явно активировано для каждого запроса.

## Почему кэширование важно?

1. Улучшение производительности: Снижает количество запросов к базе данных, что может существенно увеличить производительность приложения.
2. Снижение нагрузки на базу данных: Меньше запросов к базе данных означает меньшую нагрузку и более эффективное использование ресурсов базы данных.
3. Повышение отзывчивости: Быстрое получение данных из кэша вместо выполнения долгих запросов может улучшить отзывчивость приложения.

### Проект Nihongo Nexus

Использование кэша второго уровня:

- Цель: Кэширование слов и их переводов для улучшения производительности поиска и отображения.
- Пример: Кэширование сущностей `Vocabulary` и `Translation` для быстрого доступа к часто запрашиваемым данным.
