- Version решает проблему с **потерянными обновлениями**. Как именно, сейчас и посмотрим. **@Version** *реализует механизм оптимистичной блокировки*. 
- Это означает, что разные транзакции могут параллельно читать одну и ту же запись, но если одна из транзакций попытается изменить данные, система проверяет, не были ли они изменены другой транзакцией.
- Hibernate поддерживает специальное поле, аннотированное **@Version**. Это поле может быть типа `int`, `long`, `Timestamp`, или других поддерживаемых типов.
- При каждом обновлении записи, значение этого поля автоматически увеличивается (или изменяется).
- Когда приложение пытается обновить запись в базе данных, Hibernate проверяет, совпадает ли текущее значение версии в базе с версией объекта в памяти. Если версии не совпадают, это означает, что кто-то уже изменил запись, и выбрасывается исключение **OptimisticLockException**.
- **Необходимость обработки исключений**: Приложение должно быть готово к обработке **OptimisticLockException**, что требует дополнительной логики.

В _оптимистичных_ блокировках при коммите в базу данных производится сравнивание значения поля, помеченного как version, на момент получения данных и на данный момент. Если оно изменилось, то есть какая-то другая транзакция опередила нашу и успела изменить данные, то в таком случае наша транзакция выбрасывает ошибку, и необходимо заново запускать ее.  
  
При использовании _оптимистичных_ блокировок обеспечивается более высокий уровень конкурентности при доступе к базе, но в таком случае приходится повторять транзакции, которые не успели внести изменения раньше других.  
  
В _пессимистичных_ же блокировка накладывается сразу же перед предполагаемой модификацией данных на все строки, которые такая модификация предположительно затрагивает.  
  
А при использовании _пессимистичных_ блокировок гарантируется отсутствие противоречий при выполнении транзакции, за счет помещение остальных в режим ожидания(но на это тратится время), как следствие понижение уровня конкурентности.