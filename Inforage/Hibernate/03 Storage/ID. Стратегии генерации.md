- `IDENTITY` - используется встроенный в БД тип данных столбца -identity - для генерации значения первичного ключа.
- `SEQUENCE` - используется последовательность – специальный объект БД для генерации уникальных значений.
- `TABLE` - для генерации уникального значения используется отдельная таблица, которая эмулирует последовательность. Когда требуется новое значение, JPA провайдер блокирует строку таблицы, обновляет хранящееся там значение и возвращает его обратно в приложение. Эта стратегия – наихудшая по производительности и ее желательно избегать. 
## 1. Auto

Описание:
- Hibernate автоматически выбирает наиболее подходящую стратегию генерации идентификатора в зависимости от базы данных и диалекта, который используется.

Hibernate (начиная с версии 5.0) сделает следующее:

- Попробует использовать стратегию `SEQUENCE`.
- Если БД не поддерживает последовательности (например, MySQL), то будет использоваться стратегия `TABLE` (или `IDENTITY`, в версии до 5.0).

```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    private String username;

    // getters and setters
}
```

## 2. Identity

Описание:
- Генерация идентификатора делегируется базе данных. Обычно используется в базах данных, которые поддерживают автоинкрементные столбцы.

Преимущества:
- Понятное и простое использование автоинкрементных столбцов.

Недостатки:
- Может быть менее эффективно при генерации большого количества записей, поскольку идентификатор создается на уровне базы данных.

```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String username;

    // getters and setters
}
```

## 3. Sequence

Описание:
- Использует последовательность базы данных для генерации уникальных идентификаторов. Это позволяет создать идентификаторы, используя специальный объект "sequence" в базе данных.

В большинстве БД максимальное количество значений  
последовательности – 2^63-1, исчерпать такое количество значений, конечно,  
сложновато. Но все возможно, если ваше приложение генерирует огромное  
количество данных; например, у вас огромное количество IoT устройств, постоянно  
присылающих замеры или баннерная сеть, которая генерирует миллионы  
кликов-событий каждый день.

Можно заметить, что у нас появляются накладные расходы: для каждой операцию вставки мы делаем дополнительную выборку из БД. И это, очевидно, будет влиять на скорость вставки данных в базу.

```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "user_seq")
    @SequenceGenerator(name = "user_seq", sequenceName = "user_sequence", allocationSize = 1)
    private Long id;

    private String username;

    // getters and setters
}
```

Если не используется последовательность по умолчанию, Hibernate «кэширует» значения ID при выборке из последовательности. Идея в том, чтобы при одном запросе «захватить» какой-то диапазон значений и потом назначать значения ID из этого диапазона. По умолчанию, Hibernate захватывает 50 значений.

Оптимизация работает так:

- **Шаг 1**: Hibernate выполняет один `SELECT` из последовательности и получает текущее значение.
- **Шаг 2**: Если это значение равно начальному значению, с которым создавалась последовательность, то Hibernate выбирает следующее значение ID, и назначает это значение верхней границей диапазона. А значение, выбранное на шаге 1 – нижней границей. В противном случае переходим к шагу 4.
- **Шаг 3**: Вставляем данные, назначаем ID, начиная с `нижней`границы до `верхней`, пока не закончатся значения.
- **Шаг 4**: Выбираем следующее значение ID из последовательности (оно больше, чем начальное). В этом случае Hibernate вычисляет доступный диапазон, используя параметр `allocationSize`. `Нижняя` граница = `ID – allocationSize+1`, `верхняя` = `ID`. Дальше переходим к шагу 3.
    
Итого, мы делаем только два запроса `SELECT` чтобы сохранить первые 50 сущностей. Для следующих 50-ти нам нужно будет сделать только один дополнительный запрос. Если опять заглянем в логи Hibernate, то увидим:

```sql
select nextval ('pet_seq'); //получаем 1 – начальное значение, нужно ещё одно
select nextval ('pet_seq'); //получаем 51 – верхнюю границу диапазона
insert into pet (name, id) values (?, ?); // id=1
insert into pet (name, id) values (?, ?);
//id=2 //сохраняем остальные 48 сущностей
select nextval ('pet_seq'); // выбираем 101, это верхняя граница, нижняя равна 101 – 50+1 = 52
insert into pet (name, id) values (?, ?); //id=52
```

## 4. Table

Описание:
- Использует специальную таблицу для генерации уникальных идентификаторов. Эта таблица хранит текущее значение идентификатора и обновляется каждый раз при создании нового объекта.

```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.TABLE, generator = "user_table")
    @TableGenerator(name = "user_table", table = "id_generator", pkColumnName = "gen_name", valueColumnName = "gen_value", pkColumnValue = "user_id", allocationSize = 1)
    private Long id;

    private String username;

    // getters and setters
}
```

## 5. UUID

Описание:
- Генерирует уникальные идентификаторы в формате UUID (Universally Unique Identifier). Подходит для распределенных систем, где требуется уникальность идентификаторов по всему миру.

Преимущества:
- Высокая уникальность идентификаторов.
- Удобен для распределенных систем, где идентификаторы должны быть уникальны по всему миру.

Недостатки:
- UUID занимает больше места в базе данных по сравнению с числовыми идентификаторами, что может влиять на производительность.



