## QA

###### Плюсы и минусы микросервисов и монолитов

- Тесты. Интеграционные легче в монолите, юнит в микрах
- Консистентность данных. Микросервисы могут иметь разны базы, нужно приводить к согласонванности
- Транзакции. В микрах нужно работать с распределенными транзакциями.
- Скорость деплоя. В случе монолоита при изменение одной части, нам нужно передплоить весь монолит.
- Масштабирование. В миках мы можем масштабировать отдельные части
- Сложность упрвления. Микры сложнее упралвять из-за их большого количества

###### В каких случаях предпочтительно использовать монолитную архитектуру?

- Монолит подходит для стартапов, когда ресурсы ограничены.

###### Какие виды паттернов микросервисной архитектуры знаешь?

- Разбиение 
- Декомпозиция
- Отказоустойчивость
- Деплой
- Управление данными
- Распределенные транзакции
- Мониторинга
- Гарантии доставки
- Обнаружение
###### Какие паттерны разбиения монолита на микросервисы ты знаешь?

- **Шаблон «Душитель» (Strangler)**

Этот шаблон означает миграцию монолитного приложения на микросервисную архитектуру путем постепенного переноса существующих функций в микросервисы. Настраивается маршрутизация запросов между устаревшим монолитом и микросервисами. Когда очередная функциональность переносится из монолита в микросервисы, фасад перехватывает клиентский запрос и направляет его к микросервисам. Новые функции при этом реализуются исключительно в микросервисах, минуя монолит. После переноса всех функций монолитное приложение полностью выводится из эксплуатации.

- **Шаблон «Уровень защиты от повреждений» (Anti-Corruption Layer)**

Для таких случаев отлично подходит паттерн Anti-Corruption Layer. Он предназначен для изолирования различных подсистем путем размещения между ними дополнительного уровня, который может быть реализован как компонент приложения или независимая служба. Этот уровень связывает две подсистемы, позволяя им оставаться максимально независимыми друг от друга. Он содержит всю логику, необходимую для передачи данных в обе стороны: при взаимодействии с каждой из подсистем используется именно ее модель данных.

- Цитадель (состояние когда есть монолит вокруг него микросервисы)
###### Какие паттерны отказоустойчивости знешь?

- **«Автоматический выключатель» (Circuit Breaker)**
- **«Переборка» (Bulkhead)** -  Пример — использование отдельного пула соединений для каждого из нижестоящих сервисов. Еще один вариант использования шаблона — назначение каждому клиенту сервиса отдельного экземпляра сервиса.

###### Паттерны мониторинга микросервисов

- **«Агрегация логов» (Log Aggregation)** предлагает использовать централизованную службу ведения логов, которая будет собирать логи от каждого экземпляра сервиса. Это предоставит пользователям единую точку для поиска, анализа логов и настройки предупреждений, которые будут запускаться при появлении в них определенных сообщений.
- **«Распределенная трассировка» (Distributed Tracing)**  Он предлагает назначать каждому внешнему запросу уникальный идентификатор (TraceId), который будет передаваться всем сервисам, участвующим в обработке запроса, и фиксироваться в журналах. Это позволит разработчикам видеть, как обрабатывается отдельный запрос, путем поиска в агрегированных журналах его внешнего идентификатора.
- **«Проверки здоровья» (Health Check)** Он предлагает определить для каждого сервиса конечную точку, которую можно использовать для проверки работоспособности, например /health. Этот API должен проверять статус хоста, подключение к другим сервисам, инфраструктуре и любую иную бизнес-логику.
###### Какие паттерны деплоймента знаешь?

-	Blue-green deploy – 2 среды развертывания – green – основной рабочий проект, blue – новая версия, стратегия в том, что б начинать перенаправлять трафик на blue проект для его тестирования, если проект упадет – вернуть трафик на green, исправить blue, если blue cправляется успешно – заменить green – blue 
-	Canary-deploy – предоставление новой версии для ограниченного кол-во пользователей.
-	Rolling deployment – поочередное развертывание на разных серверах.
-	Feature toggled – внедрение нового функционала сразу в рабочую версию, при помощи флага функционал отключается до тех пор, пока не убедятся в его правильности.
-	Shadow deployment – теневое развертывание, использует 2 среды, первая основная, другая тестовая , запросы с основной дублируются на теневую для проверки работоспособности.
-	Recreate deployment – удалить старую – вставить новую.
###### Какие паттерны распределенных транзакций знаешь?

- SAGA
- 2/3 phase commit

###### Паттерны гарантии доставки

- In/out box
###### Какие паттерны декомпозиции на микросервисы ты знаешь

- Шаблон «Разбиение по бизнес-возможностям» (Decompose By Business Capability)
- Шаблон «Разбиение по поддоменам» (Decompose By Subdomain)

###### Какие паттерны по управлению данными существуют?

- **Database Per Service**
- **API Composition**
- **Command Query Responsibility Segregation, CQRS**
- **Event Sourcing**

###### Паттерны обнаружения сервисов в микросервисной архитектуре

- **Client-Side Service Discovery**
- **Server-Side Service Discovery**
###### Что за паттерн SAGA, и как есть его виды

Он представляет собой последовательность локальных транзакций, где каждый сервис выполняет свою транзакцию и публикует событие. Другие сервисы слушают эти события и выполняют следующие локальные транзакции. Если одна из транзакций завершается неудачно, SAGA также выполняет компенсирующие транзакции для отмены эффекта предыдущих транзакций.

Пример. Банк одобряет кредит, страховая компания проверяет клиента, а система логистики доставляет товар. Виды подхода:

- В **Orchestration-Based Saga** есть центральный "дирижер", который координирует все эти шаги. Если на каком-то этапе возникает проблема, "дирижер" может перенаправить процесс или повторить шаги.
- **Choreography-Based Saga**. Когда банк одобряет кредит, он публикует событие. Страховая компания реагирует на это событие и проверяет клиента. Система логистики реагирует на событие от страховой компании и доставляет товар. Если что-то идет не так, каждый сервис решает проблему самостоятельно, и процесс продолжается.

###### Как работает Circuit Breaker?

![[Circuit Breaker#Кратко]]

###### Что такое 2-х фазный и как он работает

- [[2-phase commit]]

###### Что такое паттерн outbox, в чем его отличие от паттерна Saga

- [[Transactional Out Box]]
- [[SAGA]]
- Основное отличие заключается в том, что паттерн Outbox фокусируется на надежной доставке сообщений, **используя базу данных для хранения**, а Saga управляет распределенными транзакциями, **разбивая их** на более мелкие операции с **возможностью компенсации**.

###### В чем разница между процессами ETL и ELT

- [[ETL vs ELT]]

###### Архитектура Data Warehouse и Data Lake

- [[Архитектура Data Warehouse и Data Lake]]

###### Что такое паттерн душитель? 

Паттерн "душитель" (Throttling) используется для ограничения количества запросов или событий, которые система может обрабатывать за определённый период времени. Он предотвращает перегрузку системы и может быть полезен при работе с внешними сервисами или при защите от пиковых нагрузок.

Пример: [[API Gateway]] может ограничить количество запросов, которые клиент может отправить на сервер в течение минуты, чтобы избежать перегрузки.

###### В чем разница между гексагональной архитектурой и Onion

- [[Onion архитектура]]
- [[Гексагональная архитектура]]

###### Что такое CQRS?

- [[CQRS]]

###### Как реализовать CQRS на практике?

- [Two Micro](https://fullstackdeveloper.guru/2023/05/04/how-to-implement-cqrs-design-pattern-in-spring-boot/)
- [One Micro - Postgre Command & Elasticsearch Query](https://github.com/yusufyilmazfr/cqrs-design-pattern-java/tree/main)
- Если в одном сервисе и к одной Postgre, опеределяем два Datasource, два TransactionManager. На запись как Primary, на чтение явное указание в @Transactional.

###### Паттерн - селективность в бд

- [[Cелективность]]

###### Что такое CAP-теорема, как она соблюдается?

- [[CAP - теорема]]

###### Что обозначает PACELC?

- **P** — Partition Tolerance (Терпимость к разделению): система должна продолжать работать, даже если часть сети недоступна или разделена.
- **A** — Availability (Доступность): система должна гарантировать, что каждый запрос получит ответ (независимо от того, является ли результат успешным или нет).
- **E** — Else (Иначе): дополнительный фактор, который используется для обозначения компромисса, который должен быть принят, когда система не делится, то есть в обычном рабочем состоянии.
- **L** — Latency (Задержка): насколько быстро система отвечает на запросы.
- **C** — Consistency (Согласованность) снова.
- **P — A / E — L**: В случае отказа сети система выбирает между доступностью и согласованностью, а когда сеть работает нормально, она минимизирует задержку в обмен на согласованность.
###### Какие еще есть паттерны в бд?

- **Шардирование** (Sharding): Разделение больших таблиц на более мелкие части к примеру по id, локации, дате актуальности, чтобы распределить данные по разным физическим серверам и улучшить масштабируемость.
- Кэширование (Caching): Хранение часто запрашиваемых данных в быстрых хранилищах (например, Redis), чтобы уменьшить нагрузку на основную базу данных.
- **Репликация** (Replication): Создание копий базы данных на нескольких серверах для повышения доступности и отказоустойчивости.
- Этапное удаление (Soft Delete): Вместо физического удаления данных используется флаг (например, `isDeleted`), чтобы пометить запись как удалённую, но не удалять её из базы. К примеру используется для создания отчетов.
- Агрегаты (Aggregate Pattern): Группировка данных, связанных с одной сущностью (например, заказа и его элементов), для упрощения работы с ними.
- Вычисляемые колонки (Computed/Derived Columns): Колонки, которые хранятся в базе и содержат результаты вычислений на основе других полей.
- Паттерн Table Inheritance: Представление иерархии классов в базе данных с помощью разных таблиц для базового и производных классов.
- Event Sourcing: Хранение событий изменения данных вместо их текущего состояния для обеспечения отслеживаемости изменений и их восстановления.
- [[CQRS]]: Разделение операций чтения и записи на отдельные модели, оптимизированные для своих целей.
- Паттерн Locking (Блокировки): Использование механизмов блокировки данных (например, пессимистическая или оптимистическая блокировка) для управления конкурентным доступом к данным.

###### Если у нас кол-во данных в бд растет, добавление индексов уже не помогает. Что делать в данном случае?

- Шардирование (Sharding): Разделение базы данных на несколько частей (шардов) по какому-то ключу, например, по ID пользователя. Это позволяет распределить данные и нагрузку на несколько серверов, уменьшая размер каждого отдельного сегмента базы данных.
- Архивирование данных: Старые или редко используемые данные можно переместить в архивные таблицы или отдельную базу данных. 
- Кэширование (Caching): Использование систем кэширования (например, Redis или Memcached) для хранения результатов частых запросов в памяти. Это снижает нагрузку на базу данных и ускоряет доступ к часто используемым данным.
- [[Денормализация]]
- Использование распределенных баз данных: Переход на распределённые базы данных, такие как Cassandra, MongoDB, HBase, которые предназначены для работы с большими объёмами данных и масштабирования.
- Репликация (Replication): Запросы на чтение обрабатывались репликами, снижая нагрузку на основной сервер. Это также повышает отказоустойчивость.
- Масштабирование вертикальное и горизонтальное:
	- Вертикальное масштабирование: Увеличение ресурсов одного сервера базы данных (добавление оперативной памяти, процессоров, дисков).
	- Горизонтальное масштабирование: Распределение данных и нагрузки на несколько серверов (например, с использованием шардирования или кластеров).
-  Пересмотр и переписывание запросов для их оптимизации. Это может включать:
	- Избегание сложных операций `JOIN` и подзапросов.
	- Минимизация выборки данных (использование только необходимых полей).
	- Проверка использования индексов в запросах с помощью инструментов профилирования.
- Инвертированные индексы или полнотекстовые индексы: Если у вас много текстовых данных, то можно использовать полнотекстовые индексы для ускорения поиска по тексту.
- Использование очередей: Для операций записи, которые не требуют моментального завершения, можно использовать очереди (например, Kafka или RabbitMQ). Это позволяет разгрузить базу данных и распределить нагрузку во времени.
- В зависимости от типа данных, можно рассмотреть использование других типов баз данных:
	- Базы данных для OLAP (например, ClickHouse, Amazon Redshift) для аналитических запросов.
	- Временные базы данных (Time-Series, такие как InfluxDB) для данных, которые хранятся по времени.
	- Документоориентированные или ключ-значение базы данных для неструктурированных данных (MongoDB, DynamoDB, Redis).

###### Партиция в бд

- [[Partition DB]]

###### Если начать разрабатывать масштабное приложение, как бы ты это делал?


###### Что такое паттерн change data capture? CDC - outbox with debezium without scheduler

- [Kafka Connect, Debezium и OUTBOX pattern](https://www.youtube.com/watch?v=EP1i4fowjjg)


###### Micrometer vs Actuator

- Трассировка зачем нужна

###### TraceId и SpanId что за что отвечает, и как (где) передаются от сервиса к сервису

- **TraceId** — уникальный идентификатор для одного запроса, который связывает все операции и взаимодействия между микросервисами, относящиеся к одному запросу.
- **SpanId** — уникальный идентификатор для каждой операции или подзадачи, выполняемой в рамках одного запроса.
###### Журналирование, логирование с MDC контекстом

MDC — это ключ-значение пара, которая хранится в **потоке** (thread) и доступна для всех логируемых сообщений в рамках этого потока. Этот контекст может быть использован для добавления информации, которая будет автоматически включена в логи, например:

- **TraceId** и **SpanId** для распределенного трассирования.
- Идентификатор пользователя, сессии или устройства.
- Название приложения, версии и другие метаданные.

######  Каким способом через cronJob можно поднять 3-5 реплик микросервисов, чтобы не было конфликтов?


######  Приходит тестировщик или сотрудник второй линии и говорит что сервис медленно работает, вроде ничего не произошло. С чего бы ты начал свой анализ?


###### По Rest долго приходит ответ от внешнего сервиса. Если ты архитектор, как бы ты решил этот вопрос?


###### Можно ли реализовать на Rest стеке долгую операцию?


###### Как анализировал и решал проблемы с производительностью микросервисов? (мониторинг, анализ запросов, оптимизация).

######  

###### Как можно производить инвалидацию кэша?



## Задачи

###### Ситуация: пришли на нагрузочное тестирование, пошел траффик, оказалось что сервис (развернут в кубере) падает  с периодичностью например в 15 мин. - потому что превышает необходимую утилизацию памяти.  График утилизации Хипа в поряде, но рестарты из за памяти. Как ты думаешь, в чем проблема? Посмотрели - файл-дескрипторы ползут вверх. Что может быть?


###### Есть микросервис, пишешь метод в нем хочешь сходить параллельно в 2 других микросервиса что-то там подтянуть и у себя сагрегировать, что для этого будешь использовать? В каком пуле поток будет выполнятся твоя текущая задачка?

###### допустим нам нужно 3 instance нашего приложения, и необходим функционал который в определенное время ходит в базу и отправляет email, как сделать так чтобы это было сделано один раз?

###### Как гарантировано отправить сообщение в сторонний сервис в случае успешного завершения транзакции?

###### Система с генерацией отчета, нажал и почти моментально должен получить отчет по какой-то теме. На UI есть возможность выбора глубины желаемого отчета(в днях). Как это сделаешь?

###### Есть фронт-офис и бек-офис, в бек идут операции, есть третий компонент сверка, она реализована в виде библиотеки, подключаем ее, и при проверке оказывается, что операции не мэтчаться(не совпадают). Как бы ты стал исследовать почему они не мэтчаться?

###### К тебе пришли со своей библиотекой самописной и говорят, давай использовать ее в нашем проекте, решение нужно принять тебе. Как на онове чего ты примешь это решение

###### Есть твоя система и есть некоторые системы поставщики данных A, B, C, D, E. И есть реализация, в которой наша система получает реквест от фронта, ей нужно собрать какой-то набор данных, для этого она ходит рестами в 5 этих систем (A, B, C, D, E) получив все данные система может их аггрегировать и отдать ответ потребителю (Пример, отчет строится). Тестировщик приходит и говорит: ваш метод, который я дергаю, отрабатывает 200 секунд, сделайте что-нибудь. Какая тут будет стратегия, как бороться с такмим вещами? Что и как можно ускорить, как диагностировать?

###### есть наш сервис и есть внешние сервисы поставщики данных, мы 5 раз ходим к каждому сервису и соответственно каждый из сервисов отдает данные строго за 5 секунд. Общее время запроса условно было 25 секунд плюс время на аггрегацию данных. Мы хотим чтобы эти 5 запросов к пяти нашим поставщикам отрабатывали в параллель. У тебя спринговое приложение, что нужно использовать, как поступить, чтобы выполнить требование?

###### Допустим в блоке try вызывается ненадежный провайдер, в блоке catch - надежный. Столкнулись со следующей проблемой - в блоке try отвечает ошибкой через минуту ожидания и на каком-то ненулевом потоке все висят в try, ждут ответ от сервиса. Что можем сделать, чтобы не висеть на таких долгих ожиданиях

######  Есть у нас сервис, есть контроллер, метод сохраняет в базу и нам по кафке нужно отправить уведомление во внешнюю систему причем сделать это с гарантией доставки, если данные в базу записались, то мы гарантированно должны доставить сообщение во внешнюю систему по кафке, что тут может поломаться и как бы ты это реализовывал


######  вот представь у нас проблемы с сетью, вот 5 сервисов мы прошли и на 5-ом у нас ошибка, мы должны откатится. мы обратно по цепочке идем и откатываемся, но в 4 сервисе не можем откатится, что тогда?

###### У нас есть эндпоинт, который делает 5 вызовов в другие сервисы, и работает слишком долго, как это исправить? (Перейти на реактивщину, посмотреть explain)


###### Написали rest, все работает какое-то время, потом добавили ассинхронный процесс, который пишет в бд и все начала тормозить. Как понять в чем дело?

######  От чего отталкиваетесь , чтобы определить критерий шардирования и партиционирования

###### В проде 3 контейнера, каждый из которых реплика друг друга. И нам нужно сделать чтобы в каждый момент времени собирался какой то отчет, но это должна сделать только одна реплика из всех. Как это сделать? 

- [Guide to ShedLock with Spring](https://www.baeldung.com/shedlock-spring)
- [Leader Election in System Design](https://www.geeksforgeeks.org/leader-election-in-system-design/)
- [What is Leader Election in a Distributed System?](https://www.geeksforgeeks.org/what-is-leader-election-in-a-distributed-system/?ref=ml_lbp)
- 


## Resources

- [26 основных паттернов микросервисной разработки](https://cloud.vk.com/blog/26-osnovnyh-patternov-mikroservisnoj-razrabotki/)
- 