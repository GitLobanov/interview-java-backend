Задача №1.
/*
1. Заполнить поле children у каждого объекта в списке treeList.
 */
class Node {
  long id; //заполнен
  Long parentId; //заполнен
  List<Node> children; //пустой
}

class Test {
  public void someMethod(){
    List<Node> treeList = getList();
  }
}

--------------------------------------------------------------------------------------------------

/*
1. Есть класс А
2. Входной список отсортирован по i
3. Нужно найти элемент A.i = 18
4. Использовать бест алгоритм сложности
5. Вернуть один элемент в списке
6. Какая сложность будет подходить если нужно вернуть все возможные вхождения (несколько элементов)
 */

public List<A> findA(List<A> list){
    //
    return null;
}


--------------------------------------------------------------------------------------------------

Дан список строк {"a", "bb", "ccc", "dddd"}. Создайте новый список, содержащий только строки
длиной более 2 символов.

--------------------------------------------------------------------------------------------------

```java
/**
 * Преобразовать отсортированный массив неуникальных чисел вида [1,1,2,2,3,3,6,7] в массив отсортированных 
 * по возрастанию уникальных чисел - [1,2,3,6,7,_,_,_]
 */
// example: [1,1,2,2,3,3,6,7] -> [1,2,3,6,7,_,_,_]

class Solution {
    public void removeDuplicates(int[] nums) {
        if(nums == null || nums.length == 0){
            return;
        }

        int count = 1;
        int previous = 0;

        for(int i = 1; i < nums.length; i++){
            if(nums[i] != nums[previous]){
                nums[count++] = nums[i];
                previous = i;
            }
        }

        for(int j = count; j < nums.length; j++){
            nums[j] = 0;
        }

    }
}

```

---------------------------------------------------------------------------------------------------

```java
/**
    Задача написать класс с тремя методами
    
    - в метод parse передается строка вида key1=val1;key2=val2;key2=val3... и нужно это все упаковать
    каким то образом чтобы getRecord возвращала начальную строку
    - getValue сложность O(1)
    - getRecord - кэшируем строку в методе parse в переменную String и возвращаем
    - 1 доп - Сделать так, чтобы могли храниться дубликаты значений (решал через HashMap<String, String> переделал -> HashMap<String, List<String>>)
    - 2 доп сделать класс иммутабельным (метод parse = конструктор и все вспомогательные поля private final геттеры не создавать)
*/
    static class ParseHolder {

        public void parse(String str) {

        }

        public String getRecord() {

        }

        // За O(1)
        public String getValue(String key) {

        }

    }
```

--------------------------------------------------------------------------

```java
/**
 * Дан массив целых чисел nums и целое число target,
 * нужно вернуть индексы двух чисел из массива таким образом,
 * чтобы они в сумме давали target.
 * Имеем в ввиду, что каждый набора входных данных будет только одно решение,
 * и нельзя использовать один и тот же элемент дважды.
 * Вы можете вернуть ответ в любом порядке.
 */

/**
 * Пример 1:
 * Входные данные: nums = [2,7,11,15], target = 9
 * Выходные данные: [0,1]
 * Объяснение: Поскольку nums[0] + nums[1] == 9, возвращаем [0, 1].
 *
 * Пример 2:
 * Входные данные: nums = [3,2,4], target = 6
 * Выходные данные: [1,2]
 *
 * Пример 3:
 * Входные данные: nums = [3,3], target = 6
 * Выходные данные: [0,1]
 */

class Solution {
    public int[] twoSum(int[] nums, int target) {

    }
}

//доп. Дать оценку сложности алгоритма
//доп. Придумать алгоритм который найдет 3 числа которые дадут targetSum
```

```java
/*
Дана строка, состоящая из скобок ({[]}), необходимо проверить строку на валидность.
Валидной строка является та, в которой встречается открывающая и соответствующая ей закрывающая скобка.

System.out.println(bracketCheck("")); // 1 - true
System.out.println(bracketCheck("()")); // 2 - true
System.out.println(bracketCheck("(({}[()]))")); // 3 - true
System.out.println(bracketCheck("(()")); // 4 - false
System.out.println(bracketCheck("((]")); // 5 - false
System.out.println(bracketCheck("]")); // 6 - false
 */

private static boolean bracketCheck (String str) {
    return false;
}


```

```java

/**
* Есть массив слов
* Написать функцию, которая определяет самый длинный общий префикс
* Пример:
* Массив array{"flower", "flow", "flight"}
* Самый длинный общий префикс -> "fl"
* Массив array {"dog","racecar","car"}
* Самый длинный общий префикс -> ""
*/

```
----------------------------------------------------
```java
//Нужно написать метод, который переворачивает значение Integer:
//120 -> 21
//351 -> 153

public static int reverse(int i){
    //
}
```
Решение: ReverseInteger

------------------------------------------------------------------------

```java

// Отсортировать сначала четные, затем нечетные
// List<Integer> list = List.of(1, 2, 5, 3, 6, 2); // Результат: 2 2 6 1 3 5

public List<Integer>sortEvenAndOdd (List<Integer> list){

}
```

```java

// Удалить все элементы меньше 3 не используя стримы

```


```java

/*
    реализовать пузырьковую сортировку
 */

public class BubbleSort(){
    public static int[] sort (int[] array){ [1, 2, 4, 56, 13, 721, 0] };

    }
}
```


```java

/**
* Данa строка s, найте длину самой длинной подстроки (substring)
* без повторяющихся символов
*/

class Solution {
    public static int lengthOfLongestSubstring(String s) {
        // 
    }
}

/**
* Пример 1:
* Входные данные: s = "abcabcbb"
* Выходные данные: 3
* Объяснение: правильный ответ - "abc", с длиной равной 3.
*
* Пример 2:
* Входные данные: s = "bbbbb"
* Выходные данные: 1
* Объяснение: правильный ответ - "b", с длиной равной 1.
*
* Пример 3:
* Входные данные: s = "pwwkew"
* Выходные данные: 3
* Объяснение: правильный ответ - "wke", с длиной равной 3.
*
* Учтите, что ответ должен быть подстрокой(substring), "pwke" является subsequence, а не подстрокой.
*/

// Решение: LengthOfLongestSubstring
```

```java

/**
* Дано целое число x, вернуть true если x является палиндромом, и false в ином случае.
*/

class Solution {
    public boolean isPalindrome(int x) {

    }
}

/**
* Пример 1:
* Входные данные: x = 121
* Выходные данные: true
* Объяснение: 121 читается как 121 слева направо и справа налево.
*
* Пример 2:
* Входные данные: x = -121
* Выходные данные: false
* Объяснение: Слева направо читается как -121.
* Справа налево превращается в 121-. И поэтому это не является палиндромом.
*
* Пример 3:
* Входные данные: x = 10
* Выходные данные: false
* Объяснение: Представляет собой 01 справа налево. И поэтому не является палиндромом.
*/
```

```java

// Инвертировать входящий массив
// {1, 2, 3, 4, 5}

public int[] arrayReverse (int[] array) {
    //
}
```