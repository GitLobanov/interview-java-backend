###### Принципы ООП

- Инкапсуляция – это принцип скрытия внутренней реализации объекта и предоставления интерфейса для взаимодействия с ним. Распределять по пакетам, настраивать модификаторы доступа, инкапсулировать реализацию
- Наследование – это свойство системы, позволяющее описать новый класс на основе уже
существующего с частично или полностью заимствующейся функциональностью. 
- Полиморфизм – дает возможность использовать одинаковые интерфейсы для объектов разных типов. Это позволяет работать с различными объектами, используя единый интерфейс, тем самым упрощая код. Свойства переопределения, перезагрузки, дженериков. 
- Абстракция – это способ выделить набор общих характеристик объекта, исключая взаимодействия с реализацией напрямую
###### Ассоциация, агрегация, композиция

- **Ассоциация** - наследование. Класс является (is a) наследником другого класса.
- **Агрегация** и **композиция** - Класс содержит, агрегирует, композирует (has a) внутри себя другой класс.
- **Агрегация** подразумевает такой тип отношений, в которых дочерняя структура может существовать независимо от родительской. Пример: Если `Address` будет удалён, `Student` всё равно продолжит существовать.
- **Композиция** подразумевает такой тип отношений, в которых дочерняя структура не может существовать отдельно от родительской. Пример: `House` (родительский класс) и `Room` (дочерний класс). `Room` не существует отдельно от `House`.

###### Статическое и динамическое связывание

- Статическое на этапе запуска кода
- Динамическое во время исполнения кода - runtime.
- * Для всех методов Java используется механизм позднего (динамического) связывания, если только метод не был объявлен как final (приватные методы являются final по умолчанию).

###### SOLID

- [SOLID](SOLID.md)
- Принцип единственной ответственности. Класс должен быть ответственен лишь за что-то одно. Если мы хотим поменять метрики, мы не должны менять бизнес логику.
- Принцип открытости-закрытости. Программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для модификации.
- Принцип подстановки Барбары Лисков. Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов.
- Принцип разделения интерфейса. Создание узкоспециализированных интерфейсов, предназначенных для конкретного клиента. Клиенты не должны зависеть от интерфейсов, которые они не используют.
- Принцип инверсии зависимостей. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

###### Назвать методы класса Object

`toString, hashCode, equals, getClass, notify, notifyAll, wait, wait(timeout), finalize, clone`
###### Какие бывают загрузчики классов 

В Java загрузка классов выполняется с помощью механизмов загрузчиков классов, таких как **Bootstrap ClassLoader**, **Extension ClassLoader** и **System/Application ClassLoader**. Они обеспечивают динамическую загрузку классов во время выполнения программы.

- базовый загрузчик (bootstrap/primordial). Загружает основные системные и
внутренние классы JDK (Core API – пакеты java.* (rt.jar и i18n.jar). Важно заметить,
что базовый загрузчик является «изначальным», или «корневым» и частью JVM,
вследствие чего его нельзя создать внутри кода программы. Загружает основные системные классы JDK (например, из пакета `java.*`. ClassLoader for String: null
- загрузчик расширений (extention). Загружает различные пакеты расширений,
которые располагаются в директории <JAVA_HOME>/lib/ext или другой
директории, описанной в системном параметре java.ext.dirs. Это позволяет
обновлять и добавлять новые расширения без необходимости модифицировать
настройки используемых приложений. Загрузчик расширений реализован классом
sun.misc.Launcher$ExtClassLoader.
- системный загрузчик (system/application). Загружает классы, пути к которым
указаны в переменной окружения CLASSPATH или пути, которые указаны в
командной строке запуска JVM после ключей -classpath или -cp. Системный
загрузчик реализован классом sun.misc.Launcher$AppClassLoader.

###### Основные принципы загрузчиков классов

1. Делегирование загрузки более высокому загрузчику (Delegation Model)
2. Иерархическая структура загрузчиков (Hierarchy Model)
3. Изоляция классов (ClassLoader Isolation)
4. Реиспользование загруженных классов (Class Reuse)
5. Ограничение видимости загруженных классов (Visibility)

###### Этап работы загрузки классов

- Загрузка (loading) — поиск и импорт бинарных данных для типа по его имени, создание класса или интерфейса из этого бинарного представления.
- Связывание, линковка (linking) — выполнение верификации, подготовки и, необязательного, разрешения:  
    - Верификация (verification) — проверка корректности импортируемого типа.
    - Подготовка (preparation) — выделение памяти для статических переменных класса и инициализация памяти значениями по умолчанию.
    - Разрешение (resolution) — преобразование символьных ссылок типов в прямые ссылки.
- Инициализация (initialization) — вызов Java-кода, который инициализирует переменные класса их правильными начальными значениями.

###### Как нам узнать каким лоадером загрузился класс

- getClassLoader
- если вызвать у библиотечных классов, вернется null, так как платформ/bootstrap загрузчик написан на С и его представления нету в джаве
###### Виды ссылок в Java

- [Виды ссылок. Weak, Soft, Phantom](Виды%20ссылок.%20Weak,%20Soft,%20Phantom.md)
- StrongReference.  Создаем объект при помощи new. Object obj = new Object();
- SoftReference. Отказывается от объекта при отсутствии памяти.

```java
SoftReference<Object> softRef = new SoftReference<>(new Object());
```

- WeakReference. Мгновенно освобождает объект после ухода последней строгой ссылки.

```java
WeakReference<Object> weakRef = new WeakReference<>(new Object());
```

- PhantomReference. Такой же слабый, но можно делать нотификации через структур QueueReference. GC не удаляет, а складывает туда очищенные объекты.

```java
ReferenceQueue<Object> queue = new ReferenceQueue<>();
WeakReference<Object> weakRef = new WeakReference<>(new Object(), queue);
```
###### Какие структуры данных есть для не сильных ссылок?

- WeakHashMap

```java
WeakHashMap<Object, String> map = new WeakHashMap<>();
Object key = new Object();
map.put(key, "value");

key = null; // Теперь ключ может быть удален сборщиком мусора
```

###### Как Garbage Collector понимает что объект мусор

Использование Tracing, Counting

Главная идея подхода Tracing (трассировка) состоит в утверждении, что живыми могут
считаться только те объекты, до которых можно добраться из корневых точек (GC Root) и те
объекты, которые доступны с живого объекта. Все остальное – мусор.

- Существует 4 типа корневых точек:
	- локальные переменные и параметры методов;
	- потоки;
	- статические переменные;
	- ссылки из JNI;
	- System class;
	- Object held as synchronization monitor.
- Самое простое java-приложение будет иметь корневые точки:
	- локальные переменные внутри метода main() и параметры метода main();
	- поток, который выполняет main();
	- статические переменные класса, внутри которого находится метод main().

![](Pasted%20image%2020250225154230.png)


#### Какие разновидности сборщиков мусора реализованы

Serial GC (JDK 1.3) – по умолчанию в старых клиентских JVM  
Parallel GC (JDK 1.3) – по умолчанию в JDK 5–8  
CMS GC (JDK 1.4, удалён в JDK 14)  
G1 GC (JDK 7) – по умолчанию в JDK 9+
ZGC (JDK 11)  
Shenandoah GC (JDK 12)  
Epsilon GC (JDK 11)

#### Опишите алгоритм работы какого-нибудь сборщика мусора, реализованного в виртуальной машине HotSpot

[Сборка мусора: процесс](Garbage%20Collector.md#Сборка%20мусора%20процесс)

#### Что такое Heap- и Stack-память в Java? Какая разница между ними?

- Heap (куча) используется Java Runtime для выделения памяти под объекты и классы. Создание нового объекта также происходит в куче. Она же является областью работы сборщика мусора. Любой объект, созданный в куче, имеет глобальный доступ и на него могут ссылаться из любой части приложения.
- Stack (стек) – равно локальная память потока. Всякий раз, когда вызывается метод, в памяти стека создается новый блок, который содержит примитивы и ссылки на другие объекты в методе. Как только метод заканчивает работу, блок перестает использоваться, тем самым предоставляя доступ для следующего метода. Стек в Java работает по схеме LIFO (последний-зашел-первый-вышел).

#### Различия между Heap и Stack памятью:

- куча используется всеми частями приложения, в то время как стек используется
только одним потоком исполнения программы;
- всякий раз, когда создается объект, он всегда хранится в куче, а в памяти стека
содержится лишь ссылка на него, память стека содержит только локальные
переменные примитивных типов и ссылки на объекты в куче;
- объекты в куче доступны из любой точки программы, в то время как стековая память
не может быть доступна для других потоков;
- стековая память существует лишь какое-то время работы программы, а память в куче
живет с самого начала до конца работы программы;
- если память стека полностью занята, то Java Runtime бросает исключение
java.lang.StackOverflowError, если заполнена память кучи, то бросается исключение
java.lang.OutOfMemoryError: Java Heap Space;
- размер памяти стека намного меньше памяти в куче;
- из-за простоты распределения памяти стековая память работает намного быстрее
кучи.

#### Верно ли утверждение, что примитивные типы данных всегда хранятся в стеке, а экземпляры ссылочных типов данных – в куче?

Не совсем. Примитивное поле экземпляра класса хранится не в стеке, а в куче. Любой
объект (все, что явно или неявно создается при помощи оператора new) хранится в куче.

#### Что такое явное и неявное приведение типов? В каких случаях в java нужно использовать явное приведение?

- Тождественное (identity). Преобразование выражения любого типа к точно такому же типу всегда допустимо и происходит автоматически.
- Расширение (повышение, upcasting) примитивного типа (widening primitive). Означает, что
осуществляется переход от менее емкого типа к более емкому. Например, от типа byte
(длина 1 байт) к типу int (длина 4 байта). Такие преобразование безопасны в том смысле, что
новый тип всегда гарантировано вмещает в себя все данные, которые хранились в старом
типе, и таким образом не происходит потери данных. Этот тип приведения всегда допустим и
происходит автоматически.
- Сужение (понижение, downcasting) примитивного типа (narrowing primitive). Означает, что
переход осуществляется от более емкого типа к менее емкому. При таком преобразовании
есть риск потерять данные. Например, если число типа int было больше 127, то при
приведении его к byte значения битов старше восьмого будут потеряны. В Java такое
преобразование должно совершаться явным образом, при этом все старшие биты, не
умещающиеся в новом типе, просто отбрасываются – никакого округления или других
действий для получения более корректного результата не производится.
- Расширение объектного типа (widening reference). Означает неявное восходящее
приведение типов или переход от более конкретного типа к менее конкретному, т. е. переход
от потомка к предку. Разрешено всегда и происходит автоматически.
- Сужение объектного типа (narrowing reference). Означает нисходящее приведение, то
есть приведение от предка к потомку (подтипу). Возможно только если исходная переменная
является подтипом приводимого типа. При несоответствии типов в момент выполнения
выбрасывается исключение ClassCastException. Требует явного указания типа.
Преобразование к строке (to String). Любой тип может быть приведен к строке, т. е. к
экземпляру класса String.
- Запрещенные преобразования (forbidden). Не все приведения между произвольными
типами допустимы. Например, к запрещенным преобразованиям относятся приведения от
любого ссылочного типа к примитивному и наоборот (кроме преобразования к строке). 

#### Что такое пул интов?

В классе-обертке Integer есть внутренний класс IntegerCache – пул (pool) целых чисел в
промежутке [-128; 127], так как это самый часто встречающийся диапазон. Он объявлен как
private static. В этом внутреннем классе кешированные объекты находятся в массиве cache[].
Кеширование выполняется при первом использовании класса-обертки. После первого
использования вместо создания нового экземпляра (кроме использования конструктора),
используются кешированные объекты, JVM берет их из пула.

#### Можно ли изменить размер пула Integer?

Не из кода, а в параметре JVM. `-Djava.lang.Integer.IntegerCache.high=1000`

#### Какие еще есть пулы примитивов?
У всех целочисленных и char, но размеры изменять нельзя, можно только у int.

#### Какие есть особенности класса String?

• это неизменяемый (immutable) и финализированный тип данных;
• все объекты класса String JVM хранит в пуле строк;
• объект класса String можно получить, используя двойные кавычки;
• можно использовать оператор + для конкатенации строк;
• начиная с Java 7, строки можно использовать в конструкции switch.

#### Что такое «пул строк»?

Пул строк – это набор строк, хранящийся в Heap.
• пул строк возможен благодаря неизменяемости строк в Java и реализации идеи
интернирования строк;
• если для создания строки используются ", то сначала ищется строка в пуле с
таким же значением, если находится, то просто возвращается ссылка, иначе
создается новая строка в пуле, а затем возвращается ссылка на нее;
• при использовании оператора new создается новый объект String, затем при
помощи метода intern() эту строку можно поместить в пул или же получить из пула
ссылку на другой объект String с таким же значением;
• пул строк является примером паттерна «Приспособленец» (Flyweight).

```
String str1 = "Hello";
String str2 = "Hello";

// str1 и str2 указывают на одну строку в пуле строк
System.out.println(str1 == str2); // true

// Создание строк с помощью оператора new
String str3 = new String("Hello");
String str4 = new String("Hello");

// str3 и str4 — разные объекты в памяти
System.out.println(str3 == str4); // false

// Использование метода intern() для интернирования строк
String str5 = str3.intern();
String str6 = str4.intern();

// После интернирования str5 и str6 ссылаются на строку в пуле
System.out.println(str5 == str6); // true

// Показать ссылки на строки в пуле
System.out.println(str1 == str5); // true
```
#### Почему не рекомендуется изменять строки в цикле? Что рекомендуется использовать?

Строка – неизменяемый класс, поэтому растет потребление ресурсов при редактировании,
т. к. при каждой итерации будет создаваться новый объект строки. Рекомендуется
использовать StringBuilder.

#### Почему String неизменяемый и финализированный класс?

- Пул строк возможен только потому, что строка неизменяемая, таким образом виртуальная машина сохраняет больше свободного места в Heap, поскольку разные строковые переменные указывают на одну и ту же переменную в пуле. Если бы строка была изменяемой, то интернирование строк не было бы возможным, потому что изменение значения одной переменной отразилось бы также и на остальных переменных, ссылающихся на эту строку.
- Если строка будет изменяемой, тогда это станет серьезной угрозой безопасности приложения. Например, имя пользователя базы данных и пароль передаются строкой для получения соединения с базой данных и в программировании сокетов реквизиты хоста и порта передаются строкой. Так как строка неизменяемая, ее значение не может быть изменено, в противном случае злоумышленник может изменить значение ссылки и вызвать проблемы в безопасности приложения.
- Неизменяемость позволяет избежать синхронизации: строки безопасны для многопоточности, и один экземпляр строки может быть совместно использован различными потоками.
- Строки используются classloader, и неизменность обеспечивает правильность загрузки класса.
- Поскольку строка неизменяемая, ее hashCode() кешируется в момент создания и нет необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в HashMap, т. к. его обработка происходит быстрее.

#### Что такое StringJoiner?

Класс StringJoiner используется, чтобы создать последовательность строк, разделенных
разделителем с возможностью присоединить к полученной строке префикс и суффикс:

```java
StringJoiner joiner = new StringJoiner(".", "prefix-", "-suffix");
for (String s : "Hello the brave world".split(" ")) {
	joiner.add(s);
}
System.out.println(joiner); //prefix-Hello.the.brave.world-suffix
```

#### Какие типы классов есть в Java?

- Top level class (обычный класс):
	- Abstract class (абстрактный класс);
	-  Final class (финализированный класс).
- Interfaces (интерфейс).
- Enum (перечисление).
- Nested class (вложенный класс):
	- Static nested class (статический вложенный класс);
	- Member inner class (простой внутренний класс);
	- Local inner class (внутри метода класса);
	- Anonymous inner class (к примеру переопределение евента на клик).
#### Что такое «анонимные классы»? Где они применяются?

Это вложенный локальный класс без имени, который разрешено декларировать в любом
месте обрамляющего класса, разрешающем размещение выражений. Создание экземпляра
анонимного класса происходит одновременно с его объявлением. В зависимости от
местоположения анонимный класс ведет себя как статический либо как нестатический
вложенный класс – в нестатическом контексте появляется окружающий его экземпляр.

Анонимные классы имеют несколько ограничений:
-  использование разрешено только в одном месте программы – месте его создания;
-  применение возможно только в том случае, если после порождения экземпляра нет необходимости на него ссылаться;
- реализует лишь методы своего интерфейса или суперкласса, т. е. не может объявлять каких-либо новых методов, так как для доступа к ним нет поименованного типа.

Анонимные классы обычно применяются для:
- создания объекта функции (function object), например, реализация интерфейса Comparator;
- создания объекта процесса (process object), такого как экземпляры классов Thread, Runnable и подобных;
- в статическом методе генерации;
- инициализации открытого статического поля final, которое соответствует сложному перечислению типов, когда для каждого экземпляра в перечислении требуется отдельный подкласс.


#### Особенности Enum-классов

- Конструктор всегда private или default.
- Могут имплементировать интерфейсы.
- Не могут наследовать класс.
- Можно переопределить toString().
- Нет public конструктора, поэтому нельзя создать экземпляр вне Enum.
- При equals() выполняется ==
- ordinal() возвращает порядок элементов.
- Может использоваться в TreeSet и TreeMap, т. к. Enum имплементирует Comparable.
- compareTo() имитирует порядок элементов, предоставляемый ordinal().
- Можно использовать в Switch Case.
- values() возвращает массив всех констант.
- Легко создать потокобезопасный singleton без double check volatile переменных.

####  Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?

При переопределении метода нельзя сузить модификатор доступа к методу (например, с
public до private), но можно расширить.

Изменить тип возвращаемого значения нельзя, но можно сузить возвращаемое
значение, если они совместимы. Например, если метод возвращает объект класса, а
переопределенный метод возвращает класс-наследник.

#### Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы (throws и т. п.)?

- При переопределении метода сужать модификатор доступа не разрешается, т. к. это приведет к нарушению принципа подстановки Барбары Лисков. Расширение уровня доступа возможно.
- Можно изменять все, что не мешает компилятору понять, какой метод родительского класса имеется в виду:
- Поэтому в сигнатуре (имя + параметры) менять ничего нельзя, но возможно расширение уровня доступа.
- Изменять тип возвращаемого значения при переопределении метода разрешено только в сторону сужения типа (вместо родительского класса-наследника).
- Секцию throws метода можно не указывать, но стоит помнить, что она остается действительной, если уже определена у метода родительского класса. Можно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения RuntimeException. Порядок следования таких элементов при переопределении значения не имеет.

####  Что означает модификатор final? К чему он может быть применим?

Модификатор final может применяться к переменным, параметрам методов, полям и методам класса или самим классам.

- класс не может иметь наследников;
- метод не может быть переопределен в классах-наследниках;
- поле не может изменить свое значение после инициализации;
- параметры методов не могут изменять свое значение внутри метода;
- для локальных переменных примитивного типа это означает, что однажды присвоенное значение не может быть изменено;
- для ссылочных переменных это означает, что после присвоения объекта нельзя изменить ссылку на данный объект (ссылку изменить нельзя, но состояние объекта изменять можно).

#### Можно ли объявить метод абстрактным и статическим одновременно?

Нет. В таком случае компилятор выдаст ошибку: "Illegal combination of modifiers: ‘abstract’ and
‘static’". Модификатор abstract говорит, что метод будет реализован в другом классе, а static
наоборот указывает, что этот метод будет доступен по имени класса.


#### Чем интерфейсы отличаются от абстрактных классов? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?

- Интерфейс описывает только поведение (методы) объекта, а вот состояний (полей) у
- него нет (кроме public static final), в то время как у абстрактного класса они могут быть.
- Можно наследовать только один класс, а реализовать интерфейсов сколько угодно.
- Интерфейс может наследовать (extends) другой интерфейс/интерфейсы.
- Абстрактные классы используются, когда есть отношение «is-a», то есть класс-наследник расширяет базовый абстрактный класс, а интерфейсы могут быть реализованы разными классами, вовсе не связанными друг с другом.
- Абстрактный класс может реализовывать методы; интерфейс может реализовывать статические методы начиная с 8-й версии.
- Нет конструктора у интерфейса.

- В Java класс может одновременно реализовать несколько интерфейсов, но наследоваться только от одного класса.
- Абстрактные классы используются только тогда, когда присутствует тип отношений «is a» (является). Интерфейсы могут реализоваться классами, которые не связаны друг с другом.
- Абстрактный класс – средство, позволяющее избежать написания повторяющегося кода, инструмент для частичной реализации поведения.
- Интерфейс – это средство выражения семантики класса, контракт, описывающий возможности. Все методы интерфейса неявно объявляются как public abstract или (начиная с Java 8) default-методами с реализацией по умолчанию, а поля – public static final.
- Интерфейсы позволяют создавать структуры типов без иерархии.
- Наследуясь от абстрактного, класс «растворяет» собственную индивидуальность. Реализуя интерфейс, он расширяет собственную функциональность.
- Абстрактные классы содержат частичную реализацию, которая дополняется или расширяется в подклассах. При этом все подклассы схожи между собой в части реализации, унаследованной от абстрактного класса и отличаются лишь в части собственной реализации абстрактных методов родителя. Поэтому абстрактные классы применяются в случае построения иерархии однотипных, очень похожих друг на друга классов. В этом случае наследование от абстрактного класса, реализующего поведение объекта по умолчанию может быть полезно, так как позволяет избежать написания повторяющегося кода. Во всех остальных случаях лучше использовать интерфейсы.

#### Что имеет более высокий уровень абстракции – класс, абстрактный класс или интерфейс?

Интерфейс.

#### Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?

- Если возникшее исключение – наследник Error:
	- для статических блоков инициализации будет выброшено java.lang.ExceptionInInitializerError;
	- для нестатических будет проброшено исключение-источник.
- Если возникшее исключение – наследник Error, то в обоих случаях будет выброшено java.lang.Error.
- Если исключение java.lang.ThreadDeath (смерть потока), то в этом случае никакое исключение выброшено не будет.

#### Какие методы есть у класса Object (перечислить все)? Что они делают?

Object – это базовый класс для всех остальных объектов в Java. Любой класс наследуется от
Object и, соответственно, наследуют его методы:
- public boolean equals(Object obj) – служит для сравнения объектов по значению;
- int hashCode() – возвращает hash-код для объекта;
- String toString() – возвращает строковое представление объекта;
- Class getClass() – возвращает класс объекта во время выполнения;
- protected Object clone() – создает и возвращает копию объекта;
- void notify() – возобновляет поток, ожидающий монитор;
- void notifyAll() – возобновляет все потоки, ожидающие монитор;
- void wait() – остановка вызвавшего метод потока до момента, пока другой поток не вызовет метод notify() или notifyAll() для этого объекта;
- void wait(long timeout) – остановка вызвавшего метод потока на определенное время или пока другой поток не вызовет метод notify() или notifyAll() для этого объекта;
- void wait(long timeout, int nanos) – остановка вызвавшего метод потока на определенное время или пока другой поток не вызовет метод notify() или notifyAll() для этого объекта;
- protected void finalize() – может вызываться сборщиком мусора в момент удаления объекта при сборке мусора.

###### Какие методы объекта нативные

`hashCode()`, `equals()`, `wait()`, `notify()` и `clone()`
###### Свойства equals()

- Рефлексивность: для любой ссылки на значение x, x.equals(x) вернет true;
- Симметричность: для любых ссылок на значения x и y, x.equals(y) должно вернуть true, тогда и только тогда, когда y.equals(x) возвращает true.
- Транзитивность: для любых ссылок на значения x, y и z, если x.equals(y) и y.equals(z) возвращают true, тогда и x.equals(z) вернет true;
- Непротиворечивость: для любых ссылок на значения х и у, если несколько раз вызвать х.equals(y), постоянно будет возвращаться значение true либо постоянно будет возвращаться значение false при условии, что никакая информация, используемая при сравнении объектов, не поменялась;
-  Совместимость с hashCode(): два тождественно равных объекта должны иметь одно и то же значение hashCode().

При переопределении equals() обязательно нужно переопределить метод hashCode().
Равные объекты должны возвращать одинаковые хэш коды.

###### Каким образом реализованы методы hashCode() и equals() в классе Object?

- Реализация метода Object.equals() сводится к проверке на равенство двух ссылок:

```
public boolean equals(Object obj) {
	return (this == obj);
}
```

- Реализация метода Object.hashCode() описана как native, т. е. определенной не с помощью Java-кода и обычно возвращает адрес объекта в памяти: `public native int hashCode();`

###### Правила переопределения метода Object.equals()

- Использование оператора == для проверки, является ли аргумент ссылкой на указанный объект. Если является, возвращается true. Если сравниваемый объект == null, должно вернуться false.
- Использование оператора instanceof и вызова метода getClass() для проверки, имеет ли аргумент правильный тип. Если не имеет, возвращается false.
- Приведение аргумента к правильному типу. Поскольку эта операция следует за проверкой instanceof она гарантированно будет выполнена.
- Обход всех значимых полей класса и проверка того, что значение поля в текущем объекте и значение того же поля в проверяемом на эквивалентность аргументе соответствуют друг другу. Если проверки для всех полей прошли успешно, возвращается результат true, в противном случае – false.
- По окончанию переопределения метода equals() следует проверить: является ли порождаемое отношение эквивалентности рефлексивным, симметричным, транзитивным и непротиворечивым? Если ответ отрицательный, метод подлежит соответствующей правке.

###### Правила переопределения метода hashcode()

1. Если хеш-коды разные, то и входные объекты гарантированно разные.
2. Если хеш-коды равны, то входные объекты не всегда равны.
3. При вычислении хеш-кода следует использовать те же поля, которые сравниваются в equals и которые не вычисляются на основе других значений.

#### Могут ли у разных объектов быть одинаковые hashCode()?

Да, могут. Метод hashCode() не гарантирует уникальность возвращаемого значения.
Ситуация, когда у разных объектов одинаковые хеш-коды называется коллизией.
Вероятность возникновения коллизии зависит от используемого алгоритма генерации хеш-кода.

#### Опишите иерархию исключений

[Java исключения](Java%20исключения.md)


#### Расскажите про обрабатываемые и необрабатываемые исключения

- checked (контролируемые/проверяемые исключения) должны обрабатываться блоком catch или описываться в сигнатуре метода (например throws IOException), наличие такого обработчика/модификатора сигнатуры проверяются на этапе компиляции;
- unchecked (неконтролируемые/непроверяемые исключения), к которым относятся ошибки Error (например OutOfMemoryError), обрабатывать которые не рекомендуется и исключения времени выполнения, представленные классом RuntimeException и его наследниками (например NullPointerException), которые могут не обрабатываться блоком catch и не быть описанными в сигнатуре метода.

#### Опишите процесс сериализации/десериализации с использованием Serializable

При использовании Serializable применяется алгоритм сериализации, который с помощью
рефлексии (Reflection API) выполняет:
- запись в поток метаданных о классе, ассоциированном с объектом (имя класса, идентификатор SerialVersionUID, идентификаторы полей класса);
- рекурсивную запись в поток описания суперклассов до класса java.lang.Object (не включительно);
-  запись примитивных значений полей сериализуемого экземпляра, начиная с полей самого верхнего суперкласса;
-  рекурсивную запись объектов, которые являются полями сериализуемого объекта.

При этом ранее сериализованные объекты повторно не сериализуются, что позволяет
алгоритму корректно работать с циклическими ссылками.
Для выполнения десериализации под объект выделяется память, после чего его поля
заполняются значениями из потока. Конструктор объекта при этом не вызывается. Однако
при десериализации будет вызван конструктор без параметров родительского
несериализуемого класса, а его отсутствие повлечет ошибку десериализации.


###### Как изменить стандартное поведение сериализации/десериализации?

Реализовать интерфейс java.io.Externalizable, который позволяет применение
пользовательской логики сериализации. Способ сериализации и десериализации
описывается в методах writeExternal() и readExternal(). Во время десериализации вызывается
конструктор без параметров, а потом уже на созданном объекте вызывается метод
readExternal.
Если у сериализуемого объекта реализован один из следующих методов, то механизм
сериализации будет использовать его, а не метод по умолчанию :
• writeObject() – запись объекта в поток;
• readObject() – чтение объекта из потока;
• writeReplace() – позволяет заменить себя экземпляром другого класса перед
записью;
• readResolve() – позволяет заменить на себя другой объект после чтения.


###### Почему метод clone() объявлен в классе Object, а не в интерфейсе Cloneable?

Метод clone() объявлен в классе Object с указанием модификатора native, чтобы обеспечить
доступ к стандартному механизму поверхностного копирования объектов. Одновременно он
объявлен и как protected, чтобы нельзя было вызвать этот метод у не переопределивших его
объектов. Непосредственно интерфейс Cloneable является маркерным (не содержит
объявлений методов) и нужен только для обозначения самого факта, что данный объект
готов к тому, чтобы быть клонированным. Вызов переопределенного метода clone() у не
Cloneable объекта вызовет выбрасывание CloneNotSupportedException.

##### Что такое generics?

Generics – это технический термин, обозначающий набор свойств языка, позволяющих
определять и использовать обобщенные типы и методы. Обобщенные типы или методы
отличаются от обычных тем, что имеют типизированные параметры.

Примером использования обобщенных типов может служить _Java Collection Framework_. Так, класс `LinkedList<E>` - типичный обобщенный тип. Он содержит параметр `E`, который представляет тип элементов, которые будут храниться в коллекции. Создание объектов обобщенных типов происходит посредством замены параметризированных типов реальными типами данных. Вместо того, чтобы просто использовать `LinkedList`, ничего не говоря о типе элемента в списке, предлагается использовать точное указание типа `LinkedList<String>`, `LinkedList<Integer>` и т.п.

###### Что такое raw type (сырой тип)?

Raw-types are ancient history of the Java language. In the beginning there were `Collections` and they held `Objects` nothing more and nothing less. Every operation on `Collections` required casts from `Object` to the desired type.

Это имя интерфейса без указания параметризованного типа:
`List list = new ArrayList(); // raw type`
`List<Integer> listIntgrs = new ArrayList<>(); // parameterized type`

###### Что такое стирание типов?

Суть заключается в том, что внутри класса не хранится никакой информации о типе-
параметре. Эта информация доступна только на этапе компиляции и стирается (становится
недоступной) в runtime.

###### А всегда ли Object при стирании типов?

- **Нет**, дженерики стираются до `Object` (или верхней границы, например, `Number` для `T extends Number`).

###### Что такое «лямбда»? Какова структура и особенности использования лямбда-выражения?

Лямбда представляет собой набор инструкций, которые можно выделить в отдельную
переменную и затем многократно вызвать в различных местах программы.
Основу лямбда-выражения составляет лямбда-оператор, который представляет стрелку ->.
Этот оператор разделяет лямбда-выражение на две части: левая часть содержит список
параметров выражения, а правая представляет тело лямбда-выражения, где выполняются
все действия.
Лямбда-выражение не выполняется само по себе, а образует реализацию метода,
определенного в функциональном интерфейсе. При этом важно, что функциональный
интерфейс должен содержать только один единственный метод без реализации.
По факту лямбда-выражения являются в некотором роде сокращенной формой внутренних
анонимных классов, которые ранее применялись в Java.

#### К каким переменным есть доступ у лямбда-выражений?

Доступ к переменным внешней области действия из лямбда-выражения очень схож с доступом из анонимных объектов. Можно ссылаться на:
- неизменяемые (effectively final – не обязательно помеченные как final) локальные
переменные;
- поля класса;
- статические переменные.
К методам по умолчанию реализуемого функционального интерфейса обращаться внутри
лямбда-выражения запрещено.

#### В чем разница инвариантность, ковариантность, контрвариантность 

- Инвариантность ([[Generics]]) : `Запись List<Number> list = new ArrayList<Integer>() не скомпилируется.`
- Ковариантность (upper constrains): `List<Integer> можно присвоить в переменную типа List<? extends Number> (как будто он наследник List<Number>).`

```java
Reader<String> strR = ...
Reader<Object> objR = strR;
Object data = objR.read();
```

- Контрвариантность (below constrains): `в качестве типа Comparator<? super Number> может быть передан Comparator<Object> (как будто он родитель Comparator<Number>)`

```java
Writer<Object> objW = ...
Writer<String> strW = objW;
strW.write(new String());
```

###### Что такое синтетический мост

![[Pasted image 20241003220834.png]]

Дело в том, что после компиляции все дженерики затираются и если мы используем параметризованный метод базового класса в классе наследнике, то у нас будет несоответствие возвращаемых типов, хотя синтаксически все будет верно, то есть по сути метод в классе наследнике будет методом подставкой. Для таких методов компилятором в классе наследнике генерируется синтетический метод, который имеет такой же возвращаемый тип, как у метода базового класса. Данный метод будет вызывать метод класса наследника и возвращать тип класса родителя. 

Синтетический мост — это класс, генерируемый компилятором Java для обеспечения совместимости типов при использовании дженериков. Он помогает сохранять правильное поведение методов в иерархии классов и обеспечивает полиморфизм.

- Синтетические мосты не видны в исходном коде, так как они создаются на этапе компиляции.
- Они помогают сохранить правильное поведение программ, когда используются дженерики и наследование.

Синтетические мосты создаются в случаях, когда методы с одинаковым именем имеют разные типы параметров из-за использования дженериков и типов, которые связаны с наследованием. Например, если у вас есть базовый класс с обобщённым методом, и производный класс переопределяет этот метод с конкретным типом, компилятор создаёт синтетический мост для того, чтобы разрешить вызовы методов с правильными типами.

###### Что такое красно-черное дерево

- [[0006 Programming/006 Inforage/Java/Core/data structure/Красно-черное дерево|Красно-черное дерево]]

###### Class Loader, виды и этапы выполнения

- [[Загрузка классов. Class Loader]]

###### Что такое fat JAR?

- [[Jar#Fat Jar]]

###### Что такое проблема зависимостей в теневых JAR (shaded JAR)

- [[Jar#Shaded JAR]]

 ###### Есть ли среди примитивов беззнаковые типы?

Беззнаковый значит, только положительный, char — это единственный примитивный тип, который является беззнаковым. Он используется для представления символов Unicode и может хранить значения от 0 до 65535.

###### Разница сложности между ArrayList и LinkedList

[Array vs. Linked List](https://www.happycoders.eu/algorithms/array-vs-linked-list/)

![](Pasted%20image%2020250402124147.png)

LinkedList:
- Elements can be inserted and removed with constant time.
- A linked list does not occupy any unused memory.
ArrayList:
- We can access any array element ("random access") in constant time.
- We can traverse an array from back to front – this is not possible with a singly linked list, only with a doubly linked one.
- When containing the same number of elements, an array occupies significantly less memory than a linked list (C/C++: factor 2–3; Java: factor 6).
- Due to the principle of locality, we can access elements close to each other much faster in an array.
- The garbage collector can perform a reachability analysis much quicker on an array than on a linked list.
- Deleting an array frees a contiguous memory area, while deleting a linked list leaves fragmented memory.


8. Какие существуют виды полиморфизма? 

- [[Полиморфизм#Виды]]

9. В чем проблемность наследования?

- [[Наследование#Проблемы]]

10. В чем разница между интерфейсом и абстрактным классом

- Можно несколько интерфейсов, но один абстрактный класс.
- Интерфейс - свойство, абстрактный класс - принадлежность, is a

11. Что такое Java Memory Model

Java Memory Model (JMM) — это спецификация, определяющая, как потоки взаимодействуют через память и как синхронизируются изменения переменных между потоками. Она описывает:

- Как и когда изменения в одной переменной могут быть видны другим потокам.
- Как работают ключевые слова, такие как `volatile`, `synchronized`, и блокировки.
- Обеспечивает упорядочение инструкций и предотвращает возможные проблемы с кэшированием и изменением значений в многопоточности.

12. Что такое data race?

- [[Race Condition]]

13. В чем разница Thread и Runnable

- **`Thread`** — это класс, представляющий поток выполнения. Он может быть запущен напрямую.
- **`Runnable`** — это интерфейс, представляющий задачу, которую поток должен выполнить. Он должен быть передан объекту **`Thread`**.
    Разница:
    - Thread наследуется, что накладывает ограничения на наследование (класс может наследовать только один класс).
    - Runnable более гибкий, так как интерфейсы можно реализовывать, не наследуя классы, и часто используется с Thread для отделения логики потока от класса самого потока.

14. В чем разница между методами start и run

- **`start()`**: Метод запускает новый поток, который начинает выполнение кода в методе **`run()`**. Поток запускается асинхронно.
- **`run()`**: Метод содержит код, который должен выполнить поток. Если вызвать **`run()`** напрямую, код выполнится в текущем потоке, а не в новом.

15. Как запустить поток в JVM на любом языке

Запустить принудительно поток нельзя. Можно лишь дать инструкции в JVM когда запустить, проверить блокировки и когда закончить.

17. Какие существуют состояния потоков

- [[Состояния потоков]]

18. Что такое daemon поток? 

- [[Daemon потоки]]

19. Daemon может выжрать батарейку андроида?

Да, daemon-поток может потреблять ресурсы и негативно влиять на батарею Android, если он выполняет постоянные задачи (например, бесконечные циклы или слишком частые операции). Хотя daemon-потоки работают в фоновом режиме и завершаются при завершении всех обычных потоков, если они активно работают, они могут истощать ресурсы устройства.

20. Можно ли сделать поток daemon в программе?

Да, любой поток можно сделать daemon-потоком до его запуска, вызвав метод **`setDaemon(true)`**. Это делает поток фоновым, и JVM завершит его автоматически, если все недаэмонские потоки завершены. Но сделать его обслуживающим может стать вопросом, наверное.

21. 

22. Что такое Thread Pool, виды

Thread Pool — это пул заранее созданных потоков, которые могут многократно использоваться для выполнения задач. Вместо создания новых потоков для каждой задачи, задачи назначаются потокам из пула.

- Fixed Thread Pool: Пул с фиксированным количеством потоков.
- Cached Thread Pool: Пул, который создает новые потоки по мере необходимости, но повторно использует ранее созданные потоки.
- Single Thread Pool: Пул с одним потоком для выполнения задач последовательно.
- Scheduled Thread Pool: Пул, который может планировать задачи на будущее выполнение или повторно запускать задачи через определенные интервалы.

23. Что такое CountDownLatch?

- [[CountDownLatch]]

CountDownLatch — это синхронизатор, который позволяет одному или нескольким потокам ожидать выполнения набора операций другими потоками. Он использует счётчик, который уменьшается при каждом вызове **`countDown()`**, и как только счётчик достигает нуля, потоки, ожидающие с помощью **`await()`**, продолжают выполнение.

24. Причем здесь Алиса и Semaphore?

[[Semaphore]] управляет доступом к ресурсам с помощью "счётчика разрешений", что напоминает поведение двери, через которую можно проходить только определённое количество людей одновременно. Похожая ситуация встречается в сказке "Алиса в Стране Чудес", когда герои могут проходить через узкие ворота по очереди — что схоже с логикой семафора.

25. Многопоточка всегда ограничена процессором и кэшами

Многопоточность в значительной степени зависит от:

- Числа ядер процессора: Количество физических ядер ограничивает, сколько потоков могут выполняться одновременно.
- Кэш-памяти: Потоки могут конфликтовать за кэш-память, что может снижать эффективность многопоточности.

26. В чем разница между CountDownLatch и Semaphore?

- [[CountDownLatch]]: Используется для синхронизации потоков на основе счётчика, который уменьшается до нуля. Потоки могут продолжить выполнение только после того, как счётчик достигнет нуля. **Не может быть "перезаряжен"**.
- [[Semaphore]]: Контролирует доступ к ресурсу с помощью разрешений. Семафор можно увеличивать и уменьшать на заданное число разрешений, что даёт большую гибкость.

27. Что такое read-write lock

Read-write lock (блокировка для чтения-записи) — это механизм, позволяющий различать блокировки для операций чтения и записи:

- Read Lock: Несколько потоков могут одновременно читать данные, не мешая друг другу.
- Write Lock: Только один поток может писать данные, и во время записи никто не может читать или писать.

Пример в Java — **`ReentrantReadWriteLock`**, который позволяет эффективно управлять доступом к ресурсам с разделением на операции чтения и записи.

28. Что такое lock stripping 

Lock stripping — это техника, используемая для повышения производительности многопоточных приложений путем уменьшения блокировок, которые накладываются на общие ресурсы. Вместо использования одной блокировки на уровне класса или объекта, система разбивает ресурсы на более мелкие сегменты (например, на уровне коллекций или отдельных данных), что позволяет потокам параллельно работать с различными частями ресурса без ожидания. Это помогает избежать узких мест, связанных с блокировкой, и позволяет увеличить производительность.

29. В чем разница между sleep и yield

- sleep(long millis): Приостанавливает выполнение текущего потока на указанный период времени. Поток остается в состоянии `sleep` и не может быть пробужден до истечения времени. Создания пауз в выполнении потоков, например, для снижения нагрузки на процессор.
- yield(): Указывает текущему потоку, что он готов уступить своё время другим потокам, которые могут быть готовы к выполнению. Поток переходит в состояние `ready`, но не гарантируется, что он будет приостановлен. Улучшения планирования потоков и обеспечения более справедливого распределения процессорного времени.

30. Что такое double-checked locking?

Double-checked locking — это шаблон, используемый для уменьшения накладных расходов на синхронизацию при реализации ленивой инициализации объектов. Сначала проверяется, инициализирован ли объект, и если нет, тогда применяется синхронизация для второй проверки. Если объект всё ещё не инициализирован, он создаётся. Это помогает избежать ненужной блокировки при каждом доступе к объекту.

32. Где принципы SOLID могут нарушаться в Android разработке

- Нарушение принципа единственной ответственности (Single Responsibility Principle): Иногда классы, такие как `Activity`, могут содержать логику как для пользовательского интерфейса, так и для бизнес-логики, что делает их слишком сложными.
- Нарушение принципа открытости/закрытости (Open/Closed Principle): В проектах может быть сложно добавлять новые функции без изменения существующего кода.
- Нарушение принципа инверсии зависимостей (Dependency Inversion Principle): Часто используются конкретные реализации, что затрудняет тестирование и замещение компонентов.

33. Какие функциональные интерфейсы существуют?

- [[Predicate]]
- [[Function]]
- [[BiFunction]]
- [[Consumer]]
- [[Supplier]]
- [[UnaryOperator]]
- [[BinaryOperator]]

34. Как устроена память в Java

- [[JVM]]
- [[Java Memory Стэк]]
- [[Java Memory Куча]]
- [[String Pool]]
- [[Загрузка классов. Class Loader]]

35. Привести виды Garbage Collector 

[[Garbage Collector#Кратко по версиям спецификации]]


36. Принципы ООП

- [[OOP]]

38. Когда использовать интерфейсы, а когда абстрактные классы

- Когда нужно состояние, абстрактный класс для этого может иметь поля.
- Если нужно добавить только какое-то свойство без привязки к состоянию, тогда интерфейс.

39. Что такое функциональные интерфейсы?

- Имеет один абстрактный метод, используется в лямбда-выражениях.
- Если интерфейс помечен как `@FunctionalInterface`, и в нем будет более одного абстрактного метода, компилятор выдаст ошибку.

40. Как работает лямбда-выражения и в чем их преимущества?

![[Лямбда выражения#Процесс]]
![[Лямбда выражения#Преимущества]]

41. Как можно внутри потока Stream обрабатывать исключение?

- [[Stream API#Руководство по обработке исключений]]

42. Garbage Collector по версиям java

- [[Garbage Collector#Кратко по версиям спецификации]]

43. Иерархия коллекций

- [[Иерархия коллекций.canvas|Иерархия коллекций]]

44. Как реализуется полиморфизм в Generics?

- [[Полиморфизм#Универсальный полиморфизм. Generics]]

#### Что такое PECS?

- [PECS](Wildcard.md#PECS)

46. Разница между super и extends?

**? extends T** обозначает, что класс должен быть наследником T.
**? super T** обозначает, что класс должен быть предком T. 

47. В коллекциях нарушается принцип Барборы Лисков? 

- В случае с коллекциями, такими как `ArrayList`, если у вас есть код, который **ожидает**, что коллекция всегда будет корректно возвращать элементы при итерации, и вдруг она выбрасывает исключение `ConcurrentModificationException`, то это может **нарушить LSP**.
- Если вы заменяете `ArrayList` на другой объект (например, потокобезопасный `CopyOnWriteArrayList`), вы могли бы ожидать отсутствие ошибок при изменении коллекции в параллельном потоке. 


48. Такая ситуация в гите. Если ты сделал cherry pick какого-то файла из ветки другого разработчика, как потом решить проблему сливания обеих веток в главную, не будут ли конфликтовать взятый файл с файлом другого разработчика?

Проблемы:

- Ветка A: Разработчик A вносит изменения в файл `file.txt` и коммитит их.
- Ветка B: Разработчик B делает cherry-pick этих изменений из ветки A, применяя их в своей ветке.
- Ветка A и B сливаются: В какой-то момент обе ветки сливаются в основную ветку, например, в `master`. Теперь Git может обнаружить конфликты, если изменения в `file.txt` в обеих ветках не согласуются.

Решение: 

- Основной способ разрешения — ручное разрешение конфликта при слиянии.
- В некоторых случаях использование `rebase` или других стратегий слияния может уменьшить вероятность конфликтов.

#### Жизненный цикл сборщика Maven и какие его основные фазы?

- Clean Lifecycle (очистка):
    - **pre-clean**: Фаза, выполняющая действия перед началом очистки.
    - **clean**: Удаляет все файлы, сгенерированные предыдущими сборками, включая директорию `target`.
    - **post-clean**: Фаза, выполняющая действия после завершения очистки.
- Default Lifecycle (основной жизненный цикл):
    - **validate**: Проверяет, что проект правильно сконфигурирован и готов к сборке.
    - **compile**: Компилирует исходный код проекта.
    - **test**: Выполняет модульные тесты, обычно используя фреймворки, такие как JUnit.
    - **package**: Создаёт исполнимый артефакт (например, JAR, WAR или EAR).
    - **verify**: Проверяет, что артефакт прошёл все проверки и тесты.
    - **install**: Устанавливает артефакт в локальный репозиторий, чтобы его могли использовать другие проекты.
    - **deploy**: Отправляет артефакт в удалённый репозиторий, чтобы его могли использовать другие разработчики.
- Site Lifecycle (создание сайта):
    - **pre-site**: Фаза перед созданием сайта.
    - **site**: Генерирует сайт проекта (обычно в формате HTML).
    - **post-site**: Выполняет действия после создания сайта.
    - **site-deploy**: Разворачивает сайт проекта на сервере.

`mvn clean install`

- Выполнит фазы из clean lifecycle, чтобы очистить старую сборку.
- Затем выполнит фазы из default lifecycle, начиная с валидации, компиляции, тестирования, упаковки, и установит артефакт в локальный репозиторий.

53. Что лучше set или list указывать в ассоциации Hibernate

Выбор между Set и List для указания в ассоциации зависит от конкретных требований и ситуации.  **Для ассоциаций ManyToMany обычно предпочтительнее Set**. Он не содержит дубликатов и генерирует более эффективные SQL-запросы. **List** **может быть более эффективным** **для ассоциаций OneToMany**, так как не требует дополнительных проверок на дублирование данных, если список может содержать их. Также стоит учитывать, что тип данных влияет на то, как Hibernate управляет ассоциацией в базе данных. Например, для ассоциаций ManyToMany не рекомендуется использовать List, так как при этом Hibernate неэффективно удаляет связанные объекты.

54. Как работает авторизация через JSON Web Token (JWT)

- [[JSON Web Token (JWT)]]

55. Почему `AbstractList` реализует `List`, а `ArrayList` расширяет `AbstractList` и снова реализует `List`?

- **`AbstractList` реализует `List`**, потому что он предоставляет частичную реализацию интерфейса `List`. Этот класс реализует некоторые методы, такие как `contains()`, которые могут быть полезны для всех списков, но оставляет реализацию некоторых методов (например, `get(int index)` или `size()`) за конкретными классами.
- **`ArrayList` расширяет `AbstractList`** и снова реализует `List`, потому что:
    - Наследует общую логику от `AbstractList`, которая частично реализует интерфейс `List`.
    - Реализует специфические для `ArrayList` методы (например, хранение в массиве и доступ по индексу).

Такой подход позволяет разделить:

- Абстракцию (`List` — контракт, что должно делать, без деталей реализации),
- Частичную реализацию (`AbstractList` — общая логика работы со списками),
- Конкретную реализацию (`ArrayList` — конкретное хранение данных в массиве).

56. Зачем нужен AbstractCollection, который implements Collection, почему сразу не implements Collection

- `AbstractCollection` сокращает этот код, предоставляя реализацию, которую можно переиспользовать, и тем самым упрощает создание новых коллекций.

57. В LinkedList хранятся элементы как отдельные объекты, просто имеют ссылку на след. и пред. для поддержания связанности?

- [[LinkedList]]

58. Что за модификатор native, который используется в Object.

- Java Native Interface (JNI) используется для вызова нативного кода и операций, которые не могут быть выполнены чисто на Java, обычно на C/C++.
- Реализация этих методов происходит в нативных библиотеках, а вызовы через JNI выполняются на уровне JVM.
- Методы, требующие взаимодействия с нативной системой. Например, методы для работы с памятью, операциями на уровне ОС, доступом к файлам и другим низкоуровневым ресурсам.
- **`public native int hashCode();`** — Метод `hashCode()` в классе `Object` реализован нативным кодом, потому что он требует оптимального доступа к памяти и процессам, специфичным для платформы.
- **`public native void wait(long timeout) throws InterruptedException;`** — Этот метод синхронизации связан с нативной реализацией ожидания потока.

59. Основные принципы ClassLoader?

![[Загрузка классов. Class Loader#Основные принципы ClassLoader в Java]]

60. На каком этапе и причине можно прийти к выбору сборщика мусора?

- [[Garbage Collector#Когда и почему следует выбирать сборщик мусора]]

61. Как храниться Hash Map и HashSet в памяти?

> HashMap и хэш-таблица:

- Внутри **`HashMap`** есть **массив бакетов**.
- Этот массив похож на обычный массив в Java: **`bucket[]`** = `new bucket[initialCapacity]`, где `initialCapacity` — это начальный размер массива (например, по умолчанию 16).
- **Каждый бакет** в массиве является **ссылкой** на **цепочку элементов** (в виде списка или дерева).

> Что такое бакет?

- **Бакет** — это **ячейка массива**. В этой ячейке находится либо `null` (если там пока ничего нет), либо ссылка на **первый элемент** связанного списка (или дерева), в котором хранятся элементы с одинаковым хеш-кодом.
- **Когда несколько элементов имеют одинаковый хеш-код**, они попадают в **один и тот же бакет**. Чтобы различать их, внутри бакета строится либо **связанный список**, либо, если элементов слишком много (начиная с Java 8), **дерево**.

> Структура бакета:

- В начале, когда элементы добавляются в **пустую хэш-таблицу**, в каждом бакете может храниться либо:
    - `null` (если в этом бакете нет данных).
    - Ссылка на **связанный список** элементов (если в бакете один или несколько элементов с одинаковым хеш-кодом).
- Когда количество элементов в одном бакете становится слишком большим (обычно 8 или больше), этот связанный список преобразуется в **красно-черное дерево** для ускорения доступа.

> Алгоритм работы:

- **Хэш-таблица** в `HashMap` — это массив, который индексируется по **хеш-коду ключа**.
    - Хеш-код ключа используется для вычисления **индекса** в массиве бакетов.
- **Бакеты**:
    - Если хеш-коды **разные**, элементы будут храниться в **разных бакетах** (ячейках массива).
    - Если хеш-коды **одинаковые** (коллизия), элементы будут храниться **в одном бакете** — сначала как **связанный список**, а при увеличении количества элементов как **дерево**.

- **`HashMap`** использует **массив бакетов**, где каждый бакет — это **ссылка** на структуру данных (связанный список или дерево) для хранения элементов с одинаковым хеш-кодом.
- Сам массив бакетов выглядит как обычный массив: **`bucket[]` = `new bucket[initialCapacity]`**, и в каждой ячейке массива может быть либо `null`, либо ссылка на первый элемент связанного списка (или дерева), который хранит элементы с одинаковыми хеш-кодами.

Представьте, что **бакет** — это ячейка в массиве. Если два элемента попадают в один бакет (т.е. имеют одинаковый хеш-код), то бакет хранит **ссылку на список** этих элементов. Когда список становится слишком большим, он преобразуется в **дерево** для более быстрого поиска.

#### Когда использовать Stream API?

- [[Stream API#Когда использовать Stream API?]]

63. Что такое CompletableFuture?

- [[CompletableFuture]]

64. Можно ли в контексте List, ArrayList пример разделения на абстракцию и реализацию?

- Абстракция (`List`): Начнем с того, что интерфейс `List` — это абстракция, которая задает **контракт** для всех списков. Он определяет, что любой список должен уметь делать (например, добавлять элементы, получать по индексу, проверять размер). Важный момент: интерфейс не говорит нам, как именно это будет сделано, лишь описывает, какие методы должны быть у списка.
- Реализация (`ArrayList`): Наконец, `ArrayList` — это **конкретная реализация**. Он отвечает за конкретную реализацию методов, например, как хранить элементы (в данном случае, в массиве) и как получить элемент по индексу. Это тот класс, который действительно выполняет действия, которые ожидаются от списка.

65. Какие внутренние методы, аннотации юнит тестов ты знаешь?

- [[JUnit]]

66. Разница Mock и Spy

- [[Mockito#Mock vs Spy]]

67. Что хранится в Soft/Weak/Phantom ссылках?

- [[Виды ссылок. Weak, Soft, Phantom]]

68. Какие statefull операции ты знаешь?

- [[Stateless-Stateful операторы]]

69. Load factor?

- [[HashMap#LoadFactor]]

70. Какова основная идея хэш-таблиц и как они работают?

-  Словарь, ключ-значение.
- Хранение в бакетах по индексам — Каждый ключ преобразуется с помощью хэш-функции в числовой индекс.
- Рехеширование — Когда количество элементов в хэш-таблице превышает Load Factor, размер таблицы увеличивается, и данные распределяются заново, чтобы уменьшить количество коллизий.
- Load Factor (коэффициент загрузки) — Это отношение количества элементов к количеству бакетов в хэш-таблице. По умолчанию 0.75
- Коллизии — Когда два разных ключа генерируют один и тот же хэш-индекс, возникает коллизия. Хэш-таблицы решают это с помощью методов вроде цепочек (связные списки в бакетах) или открытой адресации (поиск другого свободного места в таблице).
- Хэш-функция — Преобразует хэш код в хэш индекс.
- Производительность — В среднем время составляет **O(1)**, но в худшем случае, при множественных коллизиях, может стать **O(n)**.

71. Что такое лямбда-выражение?

- Анонимная функция, которую можно присваивать в переменные и передавать в методы.
- Реализует функциональное программирование, позволяя работать с функциями как с объектами.

72. Каковы основные характеристики функционального интерфейса?

- Имеет один абстрактный метод, что позволяет реализовать его с помощью лямбда-выражения.
- Может содержать любое количество default и static методов.
- Упрощает использование лямбда-выражений и функциональных стилей программирования.

73. Какие преимущества и недостатки использования лямбда-выражений по сравнению с анонимными классами?

- **Преимущества:** Лямбда-выражения короче и удобнее для написания и понимания, особенно если они используются для реализации простых методов.
- **Недостатки:** Лямбда-выражения не могут иметь собственного состояния или дополнительных методов, как это возможно в анонимных классах. Они зависят от функционального интерфейса и его единственного метода.

74. Как можно использовать лямбда-выражения для реализации интерфейсов?

- Лямбда-выражение позволяет реализовать функциональный интерфейс, т. е. интерфейс с одним абстрактным методом. Лямбда выражение фактически реализует этот метод и передаёт его логику.

75. Какие стратегии и подходы используются для оптимизации производительности 

- Stream API is lazy, что позволяет выполнять операции только по необходимости.
- `parallelStream` для больших объемов данных.
- Использование встроенных функций, таких как `mapToInt`, `reduce`, чтобы избежать дополнительных преобразований данных.
- Кеширование промежуточных результатов и использование иммутабельных объектов для безопасности потоков.

76. Как можно создавать собственный функциональный интерфейс в джава?

- Использовать аннотацию `@FunctionalInterface`, чтобы указать, что интерфейс предназначен для реализации через лямбда-выражения.
- Создать только один абстрактный метод в интерфейсе. Допустимо добавлять default и static методы.

77. Какие есть способы обработки исключений в лябмда-выражениях и стрим апи? Приведите пример

Исключения можно обрабатывать с помощью `try-catch` внутри лямбда-выражений, либо использовать обёртки для лямбд, которые позволяют перехватывать исключения.

```java
list.stream()
    .map(item -> {
        try {
            return someMethod(item);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    })
    .collect(Collectors.toList());
```

78. Что такое стрим апи в джава?

- Это декларативный подход к обработке коллекций и последовательностей данных.
- Получил вдохновение из функциональных языков, таких как Haskell, и используется для облегчения операций над данными, таких как фильтрация, маппинг и свёртка.

79. Как создать поток из коллекции в джава с использованием стрим апи?

- Можно создать поток из массива с помощью `Arrays.stream(array)` или из коллекции с `list.stream()`.

80. Для чего используется лябмда-выражения в контексте стрим апи?

- Для реализации операций, таких как `map`, `filter`, `reduce`, и `flatMap`, которые позволяют трансформировать, фильтровать и обрабатывать данные в коллекциях.

81. Как с помощью Stream API отфильтровать элементы коллекции по определенному критерию?

```java
phoneStream.filter(p->p.getPrice()<50000)
citiesStream.filter(s->s.length()==6)
```

82. Как преобразовать каждый элемент коллекции в другой тип данных с использованием Stream API?

```java
List<Entry> entries = testList
                        .stream()
                        .map(Entry::new)
                        .collect(Collectors.toList());
```

83. Что делает метод collect() в Stream API, и какие существуют варианты его использования?

- [[Класс Collector]]

84. Как реализовать параллельную обработку данных с использованием Stream API?

- [[Stream API parallel]]

85. Какие особенности работы с состоянием в лямбда-выражениях и Stream API следует учитывать для избежания проблем?

Лямбда-выражения и Stream API работают с неизменяемыми данными, что уменьшает вероятность ошибок при многопоточности. Однако изменения состояния могут привести к непредсказуемым результатам, особенно если данные используются в параллельных потоках.

86. Как использовать метод reduce() в Stream API для агрегации данных, и какие подводные камни могут возникнуть при его использовании?

Метод `reduce()` в Stream API используется для агрегирования, объединяя элементы с помощью бинарной функции. Нужно учитывать, что `reduce()` неэффективен для параллельных операций, если он не ассоциативен (порядок операций) или требует значительных вычислений.

87. Каковы основные операции, которые можно выполнить с массивами?

- Чтение элемента — доступ по индексу: `array[i]`
- Запись элемента — изменение значения по индексу: `array[i] = value`
- Итерация — перебор элементов: `for` или `for-each`
- Добавление элемента — для фиксированных массивов создаётся новый массив: `Arrays.copyOf()`
- Удаление элемента — для фиксированных массивов создаётся новый массив: `System.arraycopy()` или вручную.
- Сортировка — упорядочивание элементов: `Arrays.sort(array)`
- Поиск элемента — нахождение индекса: `Arrays.binarySearch()` (если массив отсортирован) или `for` loop для линейного поиска.

88. Что такое двоичное дерево поиска и каковы его основные свойства?

- В двоичном дереве поиска элементы расположены не в последовательной памяти, как в массиве, а в виде узлов с указателями на потомков. Поиск в BST основан на сравнении элементов с текущим узлом и переходе влево или вправо.
- Двоичное дерево поиска полезно, когда ты часто выполняешь вставку, удаление и поиск по значению. Оно поддерживает порядок элементов и позволяет находить их за **O(log n)** (если дерево сбалансировано), иначе за O(n).

89. Опишите принцип алгоритма сортировки пузырьком?

- [[Пузырьковая сортировка]]

90. Объясните, как работает линейный поиск.

Линейный поиск — это алгоритм поиска элемента в списке или массиве, при котором каждый элемент проверяется последовательно, начиная с первого, пока не будет найден нужный или не завершится перебор всех элементов. O(n).

91. Какова основная идея бинарного поиска?

- В любой момент мы рассматриваем только подмассив, т.е. часть массива между индексами (включительно);
- Уменьшение диапазона поиска вдвое на каждой итерации;
- Сложность O(log n);
- Требует, чтобы массив или список был отсортирован;
- Меньше итераций — меньше затрат на вычисления.

92. Что такое О-нотация?

- Математический способ описания предельной сложности алгоритмов, который позволяет оценивать, как время выполнения или потребление памяти алгоритма зависит от размера входных данных;

- O(1): Константное время (независимо от n).
- O(log n): Логарифмическое время (например, бинарный поиск).
- O(n): Линейное время (поиск в массиве).
- O(n log n): Линейно-логарифмическое время (например, алгоритмы сортировки, такие как быстрая сортировка).
- O(n²): Квадратичное время (например, сортировка пузырьком).
- O(2^n): Экспоненциальное время (например, некоторые алгоритмы перебора).

- Помогает разработчикам и исследователям сравнивать эффективность различных алгоритмов и выбирать наиболее подходящий для конкретной задачи.

93. Какова временная сложность алгоритма линейного поиска в худшем случае?

- Временная сложность алгоритма **линейного поиска** в худшем случае составляет **O(n)**, где **n** — это количество элементов в массиве или списке.

94. Приведите пример временной сложности алгоритма, которая является линейной.

- Метод: `List.contains()`
- Метод: `Stream.sum()`
- Метод: `Set.add()`

95. Каковы преимущества и недостатки использования связанных списков по сравнению с массивами?
- Связанные списки хороши только при добавление элементов в начале и в конце
96. Как реализуется алгоритм поиска в глубину на графе и для каких задач он обычно используется?
- [[Depth-First Search, DFS]]
97. Объясните, как работает алгоритм двоичного поиска и в каких условиях он наиболее эффективен.
- [[Binary search]]
98. Какова асимптотическая сложность алгоритма сортировки вставками? 
- [[Асимптотическая сложность]]
- [[Сортировка методом вставки#Асимптотическая сложность]]
99. Опишите принцип алгоритма сортировки слиянием.
- [[Сортировка слиянием]]
100.  В чем преимущество алгоритма быстрой сортировки по сравнению с другими алгоритмами сортировки?
- [[Быстрая сортировка#Преимущества быстрой сортировки]]
101. Как изменится временная сложность алгоритма сортировки массива, если количество элементов в массиве удвоится?
- Для алгоритмов с квадратичной сложностью $(O(n^2))$ время выполнения увеличится примерно в 4 раза при удвоении количества элементов;
- Для алгоритмов с линейно-логарифмической сложностью $(O(n log n))$ время выполнения увеличится немного больше, чем в 2 раза (так как log(2n) = log n + log 2);
- Для алгоритмов с линейной сложностью (O(n)) время выполнения увеличится в 2 раза.
102. Что такое амортизационный анализ временной сложности алгоритма?
- [[Амортизационный анализ]]
103. Чем отличается временная сложность в худшем случае от средней временной сложности?
- **Худший случай** — оценивает максимальное время на самом сложном входе.
- **Средний случай** — оценивает время на случайных входах, что дает более реалистичную картину производительности.
104. Опишите, как реализуется и используется алгоритм Дейкстры для поиска кратчайшего пути на взвешенном графе.  
- [[Алгоритм Дейкстры]]
105. Какие существуют методы балансировки двоичных деревьев поиска и в чем заключается их необходимость?

- [[Двоичное дерево поиска#Балансировка]]

106. Каковы особенности реализации и применения хэш-таблиц с открытой адресацией по сравнению с методом цепочек?

Иногда разные ключи могут указывать на одно и то же место. Например, хэш-функция может дать один и тот же "адрес" (индекс) для двух разных ключей. Это называется **коллизией**, и есть два основных способа её решить:

**Метод цепочек.** HashMap, HashTable. В этом методе каждый "индекс" таблицы **ведёт к списку** (или цепочке) элементов, которые попали в одно и то же место. Если у нас несколько ключей с одинаковым индексом, мы просто добавляем их в этот список.

**Открытая адресация.** Свой класс. Здесь мы решаем коллизии не с помощью цепочек, а **поиском свободного места** в самой таблице. Если при добавлении новый элемент попадает на занятое место, мы ищем следующую свободную ячейку, куда его можно вставить. Есть несколько способов поиска

107. Какие четыре основных принципа объектно-ориентированного программирования?  

- [[OOP]]

###### Что такое immutable класс в Java?  Как создать? 

Mutable объекты могут изменять свое состояние после создания. 
Примеры из JDK: StringBuilder, Date.  
Immutable называются объекты, чье состояние не изменяется после создания. 

Примеры из JDK: String, Integer. Достоинства:  
• Просты в создании, тестировании, использовании  
• Автоматически потокобезопасны, не нуждаются в синхронизации  
• Не нужны конструктор копирования, и имплементация клонирования  
• Значение hashCode может быть кэшировано  
• Хорошо подходят как ключи Map и элементы Set  

Чтобы сделать класс Immutable:  
• Запретить перегрузку класса - сделать его final или использовать статическую фабрику и сделать конструктор private  
• Поля должны быть private и final  
• Создавать объект за один шаг, в отличие от идеологии JavaBeans (используя конструктор без аргументов и последовательность вызовов сеттеров)  
• Не описывать никаких методов (даже сеттеров), которые изменяют состояние объекта любым способом  
• Если класс имеет любые mutable поля – они должны защищенно копироваться (defensive copying) при передаче между классом и вызывающим его

###### Пример immutable класса

```java
public final class Planet {
	private final Double mass;			//immutable field
	private final String name;			//immutable field
	private final Date dateOfDiscovery;	//mutable field

	public Planet(Double mass, String name, Date dateOfDiscovery) {
		this.mass = mass;
		this.name = name;
		//this.dateOfDiscovery = dateOfDiscovery; 					//this is NOT private copy
		//this.dateOfDiscovery = dateOfDiscovery.clone();			//private copy
		this.dateOfDiscovery = new Date(dateOfDiscovery.getTime());	//private copy
	}
	public Double getMass() { return mass; }
	public String getName() { return name; }
	public Date getDateOfDiscovery() {
		return new Date(dateOfDiscovery.getTime());		//defensive copy of field
	}
}
```

###### Зачем String сделали immutable, что при этом декларировалось разработчиками?

[http://tlazarenko.blogspot.com/2013/10/string-java.html](http://tlazarenko.blogspot.com/2013/10/string-java.html)  
Безопасность и String pool - основные причины неизменяемости строк в Java.  

Безопасность объекта неизменяемого класса String обусловлена такими фактами:  
= потокобезопасность - вы можете передавать строку между потоками и не беспокоиться, что она будет изменена  
= нет проблем с синхронизацией (не нужно синхронизировать операции со String)  
= отсутствие утечек памяти  
= в Java строки используются для передачи параметров для авторизации, открытия файлов и т.д. - неизменяемость позволяет избежать проблем с доступом  
= класс String кэширует хэш-код, что улучшает производительность хеш-коллекций, использующих String  

String pool позволяет экономить память и не создавать новые объекты для каждой повторяющийся строки. В случае с изменяемыми строками - изменение одной приводило бы к изменению всех строк одинакового содержания.

###### Что такое автоупаковка (autoboxing) и автораспаковка (unboxing) в Java?  

- **Автоупаковка (autoboxing)**: Примитивный тип автоматически преобразуется в соответствующий объект-обертку, когда это необходимо.
- **Автораспаковка (unboxing)**: Обратно, объект-обертка автоматически преобразуется в примитивный тип.

112. Какие типы данных поддерживают операции автоупаковки и автораспаковки в Java?  

- `int` ↔ `Integer`
- `double` ↔ `Double`
- `float` ↔ `Float`
- `long` ↔ `Long`
- `short` ↔ `Short`
- `byte` ↔ `Byte`
- `char` ↔ `Character`
- `boolean` ↔ `Boolean`

113. Какие существуют типы исключений в Java?  

- [[Java исключения]]

114. Что такое статическое связывание в Java?  

**Статическое связывание** в Java — это процесс, при котором компилятор определяет, какой метод или переменная будет использоваться, на этапе компиляции, а не во время выполнения программы. Это связано с тем, что статически связанный код не зависит от конкретных объектов, а работает с типами данных, известными на момент компиляции.

Статическое связывание происходит для методов, которые **не переопределяются** (например, `static` методы, `private` методы и методы класса, которые не являются полиморфными).

115. Как тестировать статические методы?
- [PowerMock(+Mockito) +TestNG и имитация вызова (mock) статических методов]([PowerMock(+Mockito) +TestNG и имитация вызова (mock) статических методов / Хабр](https://habr.com/ru/articles/185834/))
116. Как тестировать feign client?
- [WireMock – швейцарский нож в арсенале тестировщика. Часть 1 / Хабр](https://habr.com/ru/companies/rostelecom/articles/679276/)
- [Offical Docs. Mockoon](https://mockoon.com/docs/latest/gui-cheat-sheet/))
- [Youtube. Mockoon - локальная работа с моками](https://www.youtube.com/watch?v=ZVsqeoWqSlU))
- ApiDog
- Postman
- SoapUI
117. Сколько вмещается байт и размерность в примитивы

- **byte** — целые числа в пределах -128 до 127, весит **1 байт**; 
- **short** — целые числа в пределах -32768 до 32767, весит **2 байта**; 
- **int** — целые числа -2147483648 до 2147483647, весит **4 байта**;
- **long** — целые числа в пределах 9223372036854775808 до 9223372036854775807, весит **8 байтов**; 
- **float** — числа с плавающей запятой в пределах -3.4E+38 до 3.4E+38, весит **4 байта**; 
- **char** — одиночные символы в UTF-16, весит **2 байта**;
- **boolean** — значения true/false, весит **1 байт**. 

118. Difference between HashMap and TreeMap

 [TreeMap](https://www.geeksforgeeks.org/treemap-in-java/) offers ****O(log N)**** lookup and insertion. Keys are ordered, so if you need to iterate through the keys in sorted order, you can. This means that keys must implement the Comparable interface. TreeMap is implemented by a [Red-Black Tree](https://www.geeksforgeeks.org/red-black-tree-set-1-introduction-2/).

[HashMap](https://www.geeksforgeeks.org/java-util-hashmap-in-java-with-examples/) offers ****0(1)**** lookup and insertion. If you iterate through the keys, though, the ordering of the keys is essentially arbitrary. It is implemented by an array of [linked list](https://www.geeksforgeeks.org/linked-list-in-java/)s.

![[Pasted image 20241202110836.png]]

119. В чем разница Optional.of(), Optional.ofNullable()

Если Optional.ofNullable() пулучит null она вернет empty Optional, but if we use Optional.of(null), this throw NullPointerException.

- [Guide To Java Optional](https://www.baeldung.com/java-optional)

120. Какие есть неизменяемые коллекции

```java
Map<String, String> unmodifiableMap = Collections.unmodifiableMap(modifiableMap);
Map<String, String> immutableMap = Map.of("name1", "Michael", "name2", "Harry");
Map<String, String> copyOfImmutableMap = Map.copyOf(immutableMap);
```
121. В чем разница бинарных и красно-черных деревьев?

- **BST** может быть разбалансированным, что ухудшает производительность.
- **RBT** всегда сбалансировано, обеспечивая O(log⁡n)O(\log n)O(logn) для операций вставки, удаления и поиска.
- **RBT**:
	- Каждый узел либо красный, либо черный.
	- Корень всегда черный.
	- Все пути от корня до листьев содержат одинаковое количество черных узлов.
	- Красный узел не может иметь красных детей ("правило двух красных").
	- Новые узлы всегда добавляются как красные, с последующим ребалансированием.

122.  Различия между Collections.unmodifiable... и List.of()/Set.of() и их применение.

- [Creating Unmodifiable Lists, Sets, and Maps](https://docs.oracle.com/en/java/javase/17/core/creating-immutable-lists-sets-and-maps.html#GUID-6A9BAE41-A1AD-4AA1-AF1A-A8FC99A14199)
- In java 8:
```java
List<String> stringList = Arrays.asList("a", "b", "c");
stringList = Collections.unmodifiableList(stringList);
```
- in java 9:
```java
List<String> stringList = List.of("a", "b", "c");
```
- copy to unmodifiable collection
```java
List<Item> snapshot = List.copyOf(list);
```
- creating Unmodifiable Collections from Streams
```java
Collectors.toUnmodifiableList() Collectors.toUnmodifiableSet() Collectors.toUnmodifiableMap(keyMapper, valueMapper)     Collectors.toUnmodifiableMap(keyMapper, valueMapper, mergeFunction)
```
- The collections returned by the convenience factory methods added in JDK 9 are unmodifiable. Any attempt to add, set, or remove elements from these collections causes an **UnsupportedOperationException** to be thrown.

123. TreeSet vs. HashSet

- **_HashSet_ can store _null_ objects, while _TreeSet_ does not allow them**
- **_TreeSet_ is rich in functionalities**, implementing additional methods like:
	- **_pollFirst()_** – to return the first element, or _null_ if _Set_ is empty
	- **_pollLast()_** – to retrieve and remove the last element, or return _null_ if _Set_ is empty
	- **_first()_** – to return the first item
	- **_last()_ –** to return the last item
	- **_ceiling()_** – to return the least element greater than or equal to the given element, or _null_ if there is no such element
	- **_lower()_** – to return the largest element strictly less than the given element, or _null_ if there is no such element


124. Что такое Mapped Diagnostic Context?
https://www.baeldung.com/mdc-in-log4j-2-logback

125. Для чего используются immutable классы на практике?

- HashMap

126. Разница внедрения через поле и конструктор

- **Внедрение через поле**: Зависимость внедряется напрямую в поле класса с помощью аннотации (например, `@Autowired`). Не требует конструктора, но может быть менее предпочтительным из-за сложности тестирования и отсутствия явного указания обязательных зависимостей.
- **Внедрение через конструктор**: Зависимости передаются через конструктор. Это предпочтительный способ, так как он делает зависимости явными, упрощает тестирование и обеспечивает неизменяемость объекта после создания.

127. Какие основные различия между HashMap и TreeMap?

- **HashMap**:
    - Основан на хэш-таблице.
    - Не гарантирует порядок элементов.
    - В среднем обеспечивает O(1) для операций вставки, удаления и поиска.
        
- **TreeMap**:
    - Основан на красно-черном дереве.
    - Элементы сортируются по ключам (естественный порядок или через `Comparator`).
    - Обеспечивает O(log n) для операций вставки, удаления и поиска.

128. Happens-before в Java?

- В одном потоке операции выполняются в порядке их написания.
- Разблокировка монитора одним потоком происходит до блокировки того же монитора другим потоком.
- Запись в `volatile` переменную происходит до чтения этой переменной другим потоком
- Вызов `Thread.start()` происходит до начала выполнения кода в новом потоке.
- Любые действия в потоке происходят до того, как другой поток увидит его завершение (например, через `join()`).
- Прерывание потока (`interrupt()`) происходит до того, как другой поток обнаружит это прерывание.

129. Как работает ThreadPoolExecutor и какие у него основные параметры?

`ThreadPoolExecutor` — это гибкий пул потоков с настраиваемыми параметрами, то что возвращает Executors. Параметры:

- **corePoolSize**: Минимальное количество потоков.
- **maximumPoolSize**: Максимальное количество потоков.
- **keepAliveTime**: Время, которое избыточные потоки ожидают новые задачи перед завершением.
- **workQueue**: Очередь задач.
- **threadFactory**: Фабрика для создания потоков.
- **handler**: Обработчик для задач, которые не могут быть выполнены из-за ограничений.

Executors:

- `Executors.newFixedThreadPool(int nThreads)`
- `Executors.newCachedThreadPool()`
- `Executors.newSingleThreadExecutor()`
- `Executors.newScheduledThreadPool(int corePoolSize)` - **возвращает** `ScheduledThreadPoolExecutor` (подкласс `ThreadPoolExecutor`).
- Метод `Executors.newWorkStealingPool()` **НЕ использует `ThreadPoolExecutor`** , а работает через `ForkJoinPool`.

130. В чем разница между ReentrantLock и ReentrantReadWriteLock?

- В отличие от syncronized блокировок, `ReentrantLock`  позволяет более гибко выбирать моменты снятия и получения блокировки т.к. использует обычные Java вызовы. Также `ReentrantLock` позволяет получить информацию о текущем состоянии блокировки, разрешает «ожидать» блокировку в течение определенного времени. Поддерживает правильное рекурсивное получение и освобождение блокировки для одного потока. Если вам необходимы честные блокировки (соблюдающие очередность при захвате монитора) — `ReentrantLock` также снабжен этим механизмом.

- ReentrantReadWriteLock Дополняет свойства `ReentrantLock` возможностью захватывать множество блокировок на чтение и блокировку на запись. Блокировка на запись может быть «опущена» до блокировки на чтение, если это необходимо.

![](Pasted%20image%2020250213141953.png)

131. Какие существуют способы передачи пропертей в Spring?

- Через файлы `.properties` или `.yaml`.
- Через аннотацию `@Value`.
- Через `Environment` API.
- Через `@ConfigurationProperties`.
- Через аргументы командной строки или переменные окружения.

132. Для чего используется аннотация @Lazy при self-injection в Spring?

`@Lazy` используется для отложенной инициализации бина. При self-injection (когда бин ссылается на себя) это помогает избежать циклических зависимостей и уменьшить нагрузку на старте приложения.

133. Какой дефолтный fetchType в Hibernate?

- Для `@OneToMany` и `@ManyToMany`: `LAZY`.
- Для `@ManyToOne` и `@OneToOne`: `EAGER`.

134. Как можно джоинить таблицы в Hibernate?

- Используя `@JoinColumn` для указания внешнего ключа.
- Используя `@OneToOne`, `@OneToMany`, `@ManyToOne`, `@ManyToMany`.
- Через HQL или Criteria API.
- EntityGraph

135. Что делает оператор SELECT FOR UPDATE и для чего он используется?

`SELECT FOR UPDATE` блокирует выбранные строки до завершения транзакции, предотвращая их изменение другими транзакциями. Используется для пессимистичной блокировки.

136. Как реализовать оптимистичную блокировку в Hibernate?

- Добавить поле с аннотацией `@Version`. Hibernate автоматически проверяет это поле при обновлении, чтобы убедиться, что данные не были изменены другой транзакцией.

137. Как реализовать пессимистичную блокировку в Hibernate?

- Использовать `LockModeType.PESSIMISTIC_READ` или `LockModeType.PESSIMISTIC_WRITE` в запросах.
- Использовать `SELECT FOR UPDATE` через HQL или Criteria API.

138. Что такое wildcards в Java?


139. Что такое PECS

[PECS](Wildcard.md#PECS)

140. Что такое ко- ин- контр- вариантность 
- [Ко- ин- контр- вариантность](Ко-%20ин-%20контр-%20вариантность.md)

141. В каких областях применяются пессимистичная и оптимистичная блокировки в Java?


142. Почему G1 (Garbage-First) сборщик стал сборщиком по умолчанию в Java?


143. Как происходит перестроение (rehashing) в HashMap?


144. Что такое композизция и агрегация?

- **Агрегация** подразумевает такой тип отношений, в которых дочерняя структура может существовать независимо от родительской. Пример: `Person` (родительский класс) и `Student` (дочерний класс). Если `Person` будет удалён, `Student` всё равно продолжит существовать.
- **Композиция** подразумевает такой тип отношений, в которых дочерняя структура не может существовать отдельно от родительской. Пример: `House` (родительский класс) и `Room` (дочерний класс). `Room` не существует отдельно от `House`.

148. Что храниться в стеке, а что в хипе?

- **Стек:** адреса возврата, параметры функций, локальные переменные (примитивные и ссылки на объекты).
- **Хип:** объекты и динамически выделенная память.

149. Во сколько раз увеличивается ArrayList при заполнении? Что если выставить capacity 1?

```java
newCapacity = oldCapacity + (oldCapacity >> 1) newCapacity = 1 + (1 >> 1) = 1 + 0 = 1
```

Но емкость **не может остаться той же**, поэтому срабатывает **минимальное увеличение до 2**.

150. В чем плюс Optional?

- **Избегает `NullPointerException`** – вместо `null` возвращает `Optional.empty()`, что явно указывает на отсутствие значения.
- **Читаемый код** – методы `orElse()`, `orElseGet()`, `ifPresent()` делают работу с возможным `null` понятной и лаконичной.
- **Функциональный стиль** – упрощает потоковую обработку (`map()`, `filter()`, `flatMap()`).
- **Явный контракт** – показывает, что метод **может вернуть пустое значение**, что делает API понятнее.

151. Какие пуллы можно получить при помощи Executors

- **FixedThreadPool (`newFixedThreadPool(n)`)**
    - `n` потоков, **не больше**.
    - Очередь **неограниченная** (`LinkedBlockingQueue`).
    - Подходит для **фиксированного количества задач**.
- **CachedThreadPool (`newCachedThreadPool()`)**
    - `0` начальных потоков, **создаёт новый при необходимости**.
    - `max = Integer.MAX_VALUE`, если задачи приходят **одновременно**.
    - Потоки **удаляются через 60 сек** бездействия.
    - Подходит для **многочисленных коротких задач**.
- **SingleThreadExecutor (`newSingleThreadExecutor()`)**
    - **Один поток**, задачи выполняются **по очереди**.
    - Очередь **неограниченная**.
    - Подходит, если важен **порядок выполнения**.
- **ScheduledThreadPool (`newScheduledThreadPool(n)`)**
    - `n` потоков, задачи **по расписанию**.
    - Методы: `schedule()`, `scheduleAtFixedRate()`, `scheduleWithFixedDelay()`.
    - Подходит для **периодических задач**.
- **WorkStealingPool (`newWorkStealingPool()`)**
    - Основан на `ForkJoinPool`, использует **адаптивное распределение**.
    - Количество потоков = **числу CPU** (`Runtime.getRuntime().availableProcessors()`).
    - Подходит для **параллельных вычислений**.

152. Что такое Json Схема?

Набор **правил** для проверки JSON. JSON Schema **описывает** структуру данных, а затем на его основе можно **автоматически создавать DTO**, экономя время и снижая вероятность ошибок.

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "type": "object",
  "properties": {
    "name": { "type": "string" },
    "age": { "type": "integer", "minimum": 0 }
  },
  "required": ["name", "age"]
}
```

#### ООП vs Функциональное программирование vs Процедурное программирование

- **ООП (Объектно-Ориентированное Программирование)** основывается на моделировании мира через объекты, которые объединяют данные и методы. Основные принципы: инкапсуляция, наследование, полиморфизм, абстракция.
- **Функциональное программирование** ориентировано на использование функций как основных строительных блоков. Принципы: неизменяемость данных, функции высшего порядка, чистые функции, лямбда-выражения.
- **Процедурное программирование** фокусируется на последовательном выполнении шагов и операции над данными. Основной акцент на действиях и изменении состояния программы.

#### JDK, JRE, JVM - что для чего

- **JDK (Java Development Kit)** — набор инструментов для разработки программ на Java, включает компилятор (javac), библиотеки, JRE.
- **JRE (Java Runtime Environment)** — среда выполнения Java-программ, включает JVM и стандартные библиотеки.
- **JVM (Java Virtual Machine)** — виртуальная машина Java, которая исполняет байт-код Java-программ, обеспечивая платформонезависимость.

#### JVM основные понятия

- Загрузчик классов (ClassLoader)
- Пространство памяти (heap, stack)
- Garbage Collector (GC)
- Execution Engine (для выполнения байт-кода)

#### Динамическая, статическая компиляция java

- **Статическая компиляция** происходит до запуска программы (например, компиляция исходного кода в байт-код).
- **Динамическая компиляция** происходит во время выполнения программы (например, JIT компиляция).

#### Загрузчики классов

Загрузчик классов (ClassLoader) отвечает за загрузку классов в JVM во время выполнения. Он использует иерархию: System ClassLoader, Extension ClassLoader, Bootstrap ClassLoader.
#### Поколения в heap

Heap в JVM разделен на несколько поколений:

- **Young Generation** — ново созданные объекты, которые часто удаляются.
- **Old Generation** — старые объекты, которые пережили несколько сборок мусора.
- **Permanent Generation (или Metaspace в Java 8+)** — хранит метаданные классов.
#### Виды Garbage collector

- Serial
- Parallel
- Concurrent Mark-Sweep (CMS)
- G1
- Shenandoah
- Z GC
#### Как GC понимает что объект живой

- Если на объект нет ссылок (он недостижим), он считается мертвым.

#### Что значит "пережить сборку мусора"?

- Иметь ссылку на объект. Условно если объект лежит в коллекции, пока жива коллекция живы объекты внутри, если не используем очистку

#### Исключения какие бывают, иерархия

**Throwable**
- [Unchecked] **Error** — критические ошибки (например, OutOfMemoryError).
- **Exception** — исключения, которые могут быть обработаны (например, IOException, SQLException).
    - [Unchecked] **RuntimeException** — исключения времени выполнения (например, NullPointerException, ArrayIndexOutOfBoundsException, ArithmeticException).
    - [Checked] Other 
#### Try with resourse, AutoClosable интерфейс

- **AutoClosable** — интерфейс с методом `close()`, который должен быть реализован объектами, которые нужно закрывать (например, потоки).
- **try-with-resources** — синтаксическая конструкция, которая автоматически закрывает ресурсы (класс, реализующий AutoClosable) после использования.
#### JIT компилятор - можешь обьяснить его функции и чем он отличается от AOT компилятора.

- **JIT (Just-in-Time) компилятор** компилирует байт-код в машинный код прямо во время выполнения программы. Он может оптимизировать код в реальном времени.
- **AOT (Ahead-of-Time) компиляция** происходит до выполнения программы, когда весь код компилируется в машинный код заранее.
###### AOT компиляция происходит до рантайма?

Да, AOT компиляция происходит до выполнения программы.
###### Есть обьекты в Java - как они представлены в памяти?

- Header - Mark Word (identityHashCode, биты блокировки, флаги, возраст объекта), Klass Pointer - указатель на метаданные класса, содержит информацию о типе
- Поля экзмпляра
- Пустые байты для кратности 8 (оптимизация для CPU)
###### StringPool

String Pool — это специальная область памяти, где хранятся строки, созданные через литералы (например, "Hello"). Строки с одинаковыми значениями в пуле ссылаются на один и тот же объект.
###### Если мы не передаем компаратор как при преобразование в кчд, в мапе сортируются элементы?

```java
int cmp = System.identityHashCode(a) - System.identityHashCode(b);
```

###### Структура самого обьекта в памяти: Header обьекта - что в нем находится и для чего он?

![](Pasted%20image%2020250401151612.png)

- identity_hashcode — хеш объекта, который появляется лениво. Если у объекта будет впервые вызов System.identityHashCode(obj), то этот хеш будет рассчитан и записан в заголовок объекта.  
    В других состояниях, когда за объект конкурируют различные потоки, identity_hashcode будет храниться уже не в заголовке объекта, а в мониторе объекта.
- age — количество пережитых сборок мусора. Когда age достигает числа max-tenuring-threshold,  
    объект перемещается в область хипа old generation.
- biased_lock — содержит 1, если biased locking включено для этого объекта, иначе 0.
- lock — содержит код состояние блокировки. 00 — Lightweight Locked, 01 — Unlocked or Biased, 10 — Heavyweight Locked, 11 — Marked for Garbage Collection.

![](Pasted%20image%2020250401152713.png)

###### Lock in header 

- Режим Biased Locked (biased_lock = 1, lock = 01)
	- thread — в режиме biased блокировки предполагается, что объектом преимущественно владеет какой-то конкретный поток, в поле хранится id этого потока.
	- epoch содержит некоторый временной индикатор владения объектом потоком, id которого сохранено в thread
- Режим Lightweight Locked (lock = 00)
	- В этом режиме предполагается, что время захвата данным объектом разными потоками не пересекается вообще или пересекается незначительно. В этом режиме вместо тяжеловесных блокировок операционной системы, JVM использует атомики.
	- ptr_to_lock_record — для установки/ожидания блокировки используется CAS (compare and set) внутри цикла spin loop.  Для справки, минимальное время блокировки ОС будет в районе порядка 10 мс, при помощи атомиков поток не засыпает, а продолжает молотить небольшой цикл, и как только ресурс освободится, цикл с атомиком закончится, и поток тут же захватит этот объект.

- Режим Heavyweight Locked (lock = 10)
	- ptr_to_heavyweight_monitor — если время захвата данным объектом различными потоками будет значительно пересекаться, то lightweight lock будет заменена на heavyweight lock. В ptr_to_heavyweight_monitor будет записан указатель на монитор. Используется блокировка ОС.
###### ClassPointer - к какому базовому классу он относится


###### Как выглядит аннотация

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface MyCustomAnnotation {
    String value() default "default value"; // Параметр аннотации
    int priority() default 1;              // Еще один параметр
}
```

###### Какие есть ElementType

- `ElementType.TYPE`: Классы, интерфейсы, перечисления.
- `ElementType.FIELD`: Поля класса.
- `ElementType.METHOD`: Методы.
- `ElementType.PARAMETER`: Параметры методов.
- `ElementType.CONSTRUCTOR`: Конструкторы.
- `ElementType.LOCAL_VARIABLE`: Локальные переменные.
- `ElementType.ANNOTATION_TYPE`: Другие аннотации.
- `ElementType.PACKAGE`: Пакеты.

###### Какие есть там RetentionPolicy? 

- `SOURCE`, `CLASS`, `RUNTIME`
###### Что такое @Repeatable

Позволяет использовать одну и ту же аннотацию несколько раз для одного элемента.
###### Как процессить аннотации? Мы ее создали, она есть, а как сделать так чтобы когда мы ее встречаем -> мы ее обрабатываем? 

- Тут нужно подробно рассказать о работе RetentionPolicy.RUNTIME

###### Какой механизм в рантайме позволяет точно аннотации определять и обрабатывать? 

- Рефлексия

###### Пример конвейерных и терминальных методов Stream API.


###### В чем разница между map() и peek()?

- Map - преобразует одно в другое
- Peek - для отладки
- 

###### Сигнатура функционального интерфейса Predicate, для какого конвейерного метода используется?

```java
@FunctionalInterface
public interface Predicate<T> {
    boolean test(T t);
}
```

Используется в `Stream.filter()`, `Collection.removeIf()`.

###### Разница между Optional.of() и Optional.ofNullable()?

Бросает `NPE`, если `value == null` - Используется, когда `null` недопустим. 
Возвращает `Optional.empty()` при `null` -  Для обертки потенциально `null`-значений
###### Чем ConcurrentHashMap отличается от HashTable?

-  ConcurrentHashMap: Поддерживает параллельные операции (блокировка на уровне сегментов/buckets)
- HashTable: Глобальная блокировка (медленнее), потокобезопасность за счет синхронизации всех методов
###### Какие проблемы возникнут, если была переопределена хэш-code и теперь всегда возвращает константу?

- Деградация производительности:
    - `HashMap`: O(1) → O(n) (цепочка коллизий) → O(log n) (при преобразовании в дерево).
    - `HashSet`: Аналогично.
- Нарушение контракта `hashCode`-`equals`: Объекты с разными `equals` будут считаться одинаковыми.
###### Как правильно реализовать хэш-code, требования?

1. **Консистентность**: Если `equals()` не изменился, `hashCode()` должен возвращать то же значение.
2. **Равенство по `equals`** → одинаковый `hashCode`.
3. **Разные `hashCode`** → объекты могут быть неравными (но желательно минимизировать коллизии).
4. **Используйте `Objects.hash()`** для удобства
###### Разница между Set и List?

- Set: уникальные элементы, не гарантирует порядок (кроме `LinkedHashSet`/`TreeSet`), основан на `HashMap`/`TreeMap`
- List: Дубликаты разрешены, сохраняет порядок вставки

###### Что такое сериализация в Java?

- **Сериализация**: Преобразование объекта в байтовый поток (для сохранения/передачи).
- **Десериализация**: Восстановление объекта из потока.
- **Интерфейс**: `Serializable` (маркерный).
- **Поля с `transient`** не сериализуются.
- **Версионирование**: `serialVersionUID`.
###### Как получить OutOfMemoryError?

```java
List<Object> list = new ArrayList<>();
while (true) list.add(new Object());
```

- **Stack OOM** (рекурсия без базового случая).
###### Можно ли переопределять конструктор у наследника(как метод)?

- **Нет**, конструктор не переопределяется (у наследника свой конструктор).
- Можно вызвать родительский через `super()`.
###### Какова сложность поиска элементов в HashMap?

- **В среднем**: O(1) (хороший `hashCode`).
- **В худшем случае**: O(n) (все элементы в одной корзине) → O(log n) (если преобразовано в дерево).
###### Можно ли в HashMap положить ключ null?

- **Да**, можно (`HashMap` разрешает один `null`-ключ).
- `Hashtable` и `ConcurrentHashMap`, TreeMap — нет.

###### Для чего нужны wildcard в дженериках?

- **`<?>`**: Любой тип (но нельзя добавлять элементы).
- **`<? extends T>`**: Ковариантность (чтение).
- **`<? super T>`**: Контравариантность (запись).
###### Корректно ли такое присваивание `List<Number> list = new ArrayList<Integer>();`?

- **Некорректно** (из-за инвариантности дженериков).

```java
List<? extends Number> list = new ArrayList<Integer>();
```

###### Есть массив с типом Number и есть лист с типом Number, что мы можем положить в массив, а что можем положить в List?

```java
Number[] arr = new Integer[10]; // OK (ковариантность)
arr[0] = 1.0; // ArrayStoreException

List<Number> list = new ArrayList<Integer>();
```

###### Можем ли мы типизировать статическое поле, статический метод?
- **Нет**, дженерики работают только для экземпляров.
- **Но** можно использовать параметризованный метод:

```java
static <T> T doSomething(T input) { ... }
```
###### Можно ли ставить @Transactional над приватными методами?

- **Нет**, Spring создает прокси только для публичных методов.
- **Приватные методы** не могут быть переопределены в прокси (они не видны в подклассах).
###### Каким способом можно обратиться из сервиса в другой сервис back-to-back с аутентификацией?

###### Что такое Java профелирование?

- `VisualVM`, `JProfiler`, `Async Profiler`, ThreadDump
- Метрики: CPU, память, потоки.
######  Могут ли создать проблемы List.of и entity.List

- `List.of()`: Неизменяемый лист (нарушает `LSP`, если ожидается изменяемый).
- **Решение**: Возвращайте `Collections.unmodifiableList()`.
###### Есть два интерфейса А и Б. В обоих определен дефолтный метод run. Класс имплементит оба интерфейса. Как это все будет работать (с методом run).

```java
interface A { default void run() { ... } }
interface B { default void run() { ... } }
class C implements A, B { } // Ошибка компиляции!

class C implements A, B {
    @Override
    public void run() { A.super.run(); } // Явное указание
}
```

###### Интернирование в Java (в классах обёртках, string pool, кеширование малых чисел у int)

**`String Pool`**:

```java
String s1 = "abc"; // Пул
String s2 = new String("abc"); // Куча
s2.intern(); // Добавляет в пул
```

Кеширование чисел:  

```java
`Integer.valueOf(127) == Integer.valueOf(127)` (true, кеш от -128 до 127).
```

###### Есть две одинаковые строки, но по equals они не равны. Почему так может произойти

- Переопределенный `equals()`.
###### При вставке в середину листа N количество, элементов, какой реализацией листа лучше воспользоваться и почему?

- **`LinkedList`**: O(1) для вставки (но O(n) для поиска позиции).
- **`ArrayList`**: O(n) (сдвиг элементов).
- **Вывод**: Если частые вставки — `LinkedList`.

###### В каких ситуациях ArrayList будет точно быстрее?

- **Random access**: `get(i)` — O(1).
- **Кэш-локальность**: Данные в памяти последовательны.
- **Итерация**: Быстрее `LinkedList`.
###### Почему 2 фильтра в StreamAPI хуже, чем один?

- Лишние итерации.
- Накладные расходы на создание промежуточных стримов.

###### Java 10+ Features

- `var` (локальный вывод типа).
- `Records` (Java 16).
- `Pattern Matching` (`instanceof` + автоматическое приведение).
- `Text Blocks` (многострочные строки).
###### Правила переопределения и контракт между HashCode и Equals.

1. Если `a.equals(b)` → `a.hashCode() == b.hashCode()`.
2. Если по хэш коду равны, не обязательно равны по equals
###### Как формируется стек в JVM?

- Хранит фреймы методов (локальные переменные, ссылки).
###### Можно ли запустить GC из кода?

```java
System.gc();
```

###### Приходилось хоть раз самому писать свою имплементацию коллекций в проде, не для тренировки или собеса?

###### Что храниться в метаданных?

###### Какие есть итераторы в Java , их типы? (более абстрактно, fail fast,fail save)

- **`Fail-fast`**: `ArrayList`, `HashMap` (бросают `ConcurrentModificationException` при изменении во время итерации).
- **`Fail-safe`**: `ConcurrentHashMap`, `CopyOnWriteArrayList` (итератор по копии).
###### Может ли быть примитив null?

- **Нет**, только объекты.
- **Обертки**: `Integer i = null` (но `int` — не может).
###### Если super то что можем прочитать?

- **Чтение**: Можно читать только `Object` (безопасность типов).
- **Запись**: Можно добавлять `T` и его подтипы.
###### Представьте что к вам пришел разработчик, старого формата, расскажите как надо работать с nullPointerException. расскажите про фишки? расскажите что конкретно нужно делать?

###### Разница unmodifiable collection vs immutable?

- unmodifiable collection - Collections.unmodifiableList() - оборачивает исходную, посути дает иммутабельное чтение, поверх исходной, но если изеняем исходную отразится в обертке
-  immutable collection - List.of, Set.of()

###### В чем разница orElse vs orElseGet

- **`orElse`**: Вычисляется всегда (даже если `Optional` не пуст).
- **`orElseGet`**: Ленивый (`Supplier` выполняется только при пустом `Optional`).

**Remember (from the Javadoc) that the Supplier method passed as an argument is only executed when *an Optional* value is not present.**
###### В чем разница Optional.of vs Optional.ofNullable()

- Если Optional.of попадет null, будет NPE
- Если Optional.ofNullable() попадет null, будет возращено Optional.empty()

**String** nullableName = null;
**Optional**<**String**> optionalNullableName = **Optional**.ofNullable(nullableName);
###### можно ли создать объекты абстрактных классов и интерфейсов 

- **Абстрактные классы**: Нельзя создать экземпляр абстрактного класса напрямую. Однако можно создать объект класса, который наследуется от абстрактного класса, если он реализует все абстрактные методы. Или воспользовать анонимными классами и лямбдой:
	- Анонимные классы: AbstractClass obj = new AbstractClass() { ... };
	- Лямбды (для интерфейсов с одним методом): Runnable r = () -> System.out.println("Hello");
- **Интерфейсы**: Нельзя создать объект интерфейса напрямую. Интерфейс может быть реализован классом, и именно этот класс можно инстанцировать. Интерфейсы служат для задания контракта, который должен реализовать класс.
###### что такое сериализация данных

Сериализация данных — это процесс преобразования объекта в последовательность байтов для хранения или передачи (например, через сеть). Этот процесс позволяет сохранить состояние объекта, чтобы позже можно было его восстановить. В Java сериализация осуществляется с помощью интерфейса `Serializable`. При десериализации объект восстанавливается из байтовой последовательности.
###### как исключить поле из сериализации (ключевое слов transient)

- private **transient** String password;
###### разница процесс vs поток

- **Процесс**: Это независимая программа, которая выполняется в своей собственной области памяти. Каждый процесс имеет свой стек, память, и т.д. В операционных системах процессы изолированы друг от друга.    
- **Поток**: Это более легкая единица выполнения внутри процесса. Потоки внутри одного процесса разделяют общую память, что делает их более легкими в плане создания и управления. Потоки позволяют более эффективно использовать ресурсы системы и ускоряют выполнение задач, которые могут быть параллельно обработаны.

В Java процесс — это запущенная программа, а поток — это отдельная часть выполнения программы.
###### плюсы и минусы джавы

**Плюсы Java**:
- **Кросс-платформенность**: Java программы могут работать на разных платформах благодаря JVM (Java Virtual Machine).
- **Мощная экосистема**: Java имеет огромную экосистему библиотек и фреймворков для решения различных задач, включая разработку веб-приложений (например, Spring, Hibernate).
- **Безопасность**: Java имеет встроенные механизмы для защиты от многих видов уязвимостей, таких как управление памятью.
- **Многозадачность**: Java поддерживает многозадачность и многопоточность, что важно для производительных и масштабируемых приложений.
- **Производительность**: С развитием JVM и оптимизацией Just-In-Time компиляции, Java демонстрирует хорошую производительность для крупных приложений.

**Минусы Java**:

- **Большой объем памяти**: Java-программы могут потреблять больше памяти из-за работы JVM и особенностей сборщика мусора.
- **Сложность и громоздкость**: Java может показаться более громоздким по сравнению с более легкими языками, такими как Python или Ruby, особенно при написании коротких программ.
- **Быстродействие старта**: Программы на Java могут иметь более медленное время старта из-за необходимости запуска JVM.

###### Iterable vs Externalizable?

- Интерфейс `Externalizable` является более специализированным и используется для сериализации объектов в Java. Он расширяет интерфейс `Serializable` и дает программисту больше контроля над процессом сериализации и десериализации объекта.
- **Основные методы**:
    - `writeExternal(ObjectOutput out)`: позволяет объекту записать свои данные в поток (сериализация).
    - `readExternal(ObjectInput in)`: позволяет объекту восстановить свои данные из потока (десериализация).

###### Сколько занимает хип по умолчанию?

- **Начальный размер heap'а (Xms)**:  
    обычно составляет **1/64 от доступной физической памяти**,  
    но не менее **8 МБ**.
- **Максимальный размер heap'а (Xmx)**:  
    примерно **1/4 от доступной физической памяти**,  
    но есть потолки и по самой JVM/ОС.

Пример:

На машине с **16 ГБ ОЗУ**:
- `-Xms` (начальный heap): ≈ **256 МБ**
- `-Xmx` (максимальный heap): ≈ **4 ГБ**

###### Какие существуют _unchecked exception_?

Наиболее часто встречающиеся: `ArithmeticException`, `ClassCastException`, `ConcurrentModificationException`, `IllegalArgumentException`, `IllegalStateException`, `IndexOutOfBoundsException`, `NoSuchElementException`, `NullPointerException`, `UnsupportedOperationException`.

###### Что вы знаете о `OutOfMemoryError`?

`OutOfMemoryError` выбрасывается, когда виртуальная машина Java не может создать (разместить) объект из-за нехватки памяти, а сборщик мусора не может высвободить достаточное её количество.

Область памяти, занимаемая java процессом, состоит из нескольких частей. Тип `OutOfMemoryError` зависит от того, в какой из них не хватило места:

- `java.lang.OutOfMemoryError: Java heap space`: Не хватает места в куче, а именно, в области памяти в которую помещаются объекты, создаваемые в приложении программно. Обычно проблема кроется в утечке памяти. Размер задается параметрами `-Xms` и `-Xmx`.
- `java.lang.OutOfMemoryError: PermGen space`: (до версии Java 8) Данная ошибка возникает при нехватке места в _Permanent_ области, размер которой задается параметрами `-XX:PermSize` и `-XX:MaxPermSize`.
- `java.lang.OutOfMemoryError: GC overhead limit exceeded`: Данная ошибка может возникнуть как при переполнении первой, так и второй областей. Связана она с тем, что памяти осталось мало и сборщик мусора постоянно работает, пытаясь высвободить немного места. Данную ошибку можно отключить с помощью параметра `-XX:-UseGCOverheadLimit`.
- `java.lang.OutOfMemoryError: unable to create new native thread`: Выбрасывается, когда нет возможности создавать новые потоки.
###### Предположим, есть метод, который может выбросить `IOException` и `FileNotFoundException` в какой последовательности должны идти блоки `catch`? Сколько блоков `catch` будет выполнено?

Общее правило: обрабатывать исключения нужно от «младшего» к старшему. Т.е. нельзя поставить в первый блок `catch(Exception ex) {}`, иначе все дальнейшие блоки `catch()` уже ничего не смогут обработать, т.к. любое исключение будет соответствовать обработчику `catch(Exception ex)`.

Таким образом, исходя из факта, что `FileNotFoundException extends IOException` сначала нужно обработать `FileNotFoundException`, а затем уже `IOException`:

```java
void method() {
    try {
        //...
    } catch (FileNotFoundException ex) {
        //...
    } catch (IOException ex) {
        //...
    }
}
```

## QA Middle

###### Как скомпилировать и запустить класс, используя консоль?

• <Путь_к_JDK>\bin\javac <Путь_к_java-классу>\<Имя_класса>.java  
После этого в папке с java-файлом появится файл <Имя_класса>.class  
Более подробно: <Путь_к_JDK>\bin\javac -d <Директория_build> -sourcepath <Список_директорий_через_;> <Путь_к_java-классу>\<Имя_класса>.java  
• <Путь_к_JDK>\bin\java <Путь_к_java-классу>\<Имя_класса>  
Если путь к JDK прописан в classpath:  
• javac <Путь_к_java-классу>\<Имя_класса>.java  
• java <Путь_к_java-классу>\<Имя_класса>
## Задачи

###### Устная задачка: есть список 1 млн элементов - в какую структуру мы его запихнём?

**Ответ:** `HashSet` или `HashMap` — если нужны уникальные значения и быстрый доступ.  
**Если просто хранить:** `ArrayList`.  
**Если часто читаем:** `ArrayList`  
**Если часто вставляем/удаляем:** `LinkedList`  
**Если нужен быстрый поиск по ключу:** `HashMap`

###### HashMap, создали массив примитивов(целочисленный), положили какой-то элемент в мапу. Могу ли использовать данный массив в качестве ключа?

Массивы не переопределяют `equals` и `hashCode` — сравниваются по **ссылке**, не по содержимому.

###### Переопределен equals, hashcode не переопределен. Если класть одинаковые объекты в HashSet, то что будет? А если TreeSet, то что будет?

###### Есть файл А с контентом на английском языке и пустой файл B. Нужно, чтобы контент появился в файле B, проговори код, который решит эту задачу

```java
Files.copy(Paths.get("A.txt"), Paths.get("B.txt"), StandardCopyOption.REPLACE_EXISTING);
...
try (BufferedReader reader = Files.newBufferedReader(Paths.get("A.txt"));
     BufferedWriter writer = Files.newBufferedWriter(Paths.get("B.txt"))) {
    String line;
    while ((line = reader.readLine()) != null) {
        writer.write(line);
        writer.newLine();
    }
}
```


## Resources

- [Array vs. Linked List](https://www.happycoders.eu/algorithms/array-vs-linked-list/)
- [Java Interview Q & A ](https://andrei-punko.github.io/java-interview-faq-n-answers/#q-1972963652)
