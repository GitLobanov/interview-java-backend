# `git status`

Когда вы запускаете `git status`, первая строка всегда будет выглядеть как одна из этих двух:

1. `on branch main`. Это означает, что `.git/HEAD` содержит ветвь.
2. `HEAD detached at 90c81c72`. Это означает, что `.git/HEAD` содержит ID коммита.

# detached HEAD state

"HEAD is detached" или "detached HEAD state" означают, что у вас нет текущей ветви.

Отсутствие текущей ветви немного опасно, потому что если вы сделаете новые коммиты, они не будут прикреплены ни к какой ветви — они будут сиротами! Осиротевшие коммиты — это проблема по двум причинам:

1. коммиты сложнее найти (вы не можете запустить `git log somebranch`, чтобы найти их)
2. осиротевшие коммиты со временем будут удалены сборщиком мусора git'а

Я тщательно избегаю создания коммитов в "detached HEAD state", хотя [некоторые предпочитают работать именно так](https://github.com/arxanas/git-branchless). Выйти из "detached HEAD state" довольно просто, вы можете либо:

1. Вернутся к ветви (`git checkout main`)
2. Создать новую ветвь на этом коммите (`git checkout -b newbranch`).
3. Если вы находитесь в "detached HEAD state", потому что находитесь в середине ребейза, завершите или прервите ребейз (`git rebase --abort`).

# `git log`: `(HEAD -> main)`

Когда запускаете `git log` и смотрите на первую строку, то можете увидеть одну из следующих трёх вещей:

1. `commit 96fa6899ea (HEAD -> main)`
2. `commit 96fa6899ea (HEAD, main)`
3. `commit 96fa6899ea (HEAD)`

Не совсем понятно, как их интерпретировать, поэтому вот что я расскажу:

- Внутри `(...)`, git перечисляет все ссылки, которые указывают на этот коммит, например `(HEAD -> main, origin/main, origin/HEAD)` означает, что `HEAD`, `main`, `origin/main` и `origin/HEAD` все указывают на этот коммит (прямо или косвенно).
- `HEAD -> main` означает, что ваша текущая ветвь — `main`.
- Если в этой строке написано `HEAD`, а не `HEAD ->`, это означает, что вы находитесь в ["detached HEAD state"](https://www.dev-notes.ru/articles/git/how-head-works-in-git/#detached_head_state) (у вас нет текущей ветви).

Если использовать эти правила для объяснения 3 примеров, приведённых выше, то получится следующее:

1. `commit 96fa6899ea (HEAD -> main)` означает:
    - `.git/HEAD` содержит `ref: refs/heads/main`
    - `.git/refs/heads/main` содержит `96fa6899ea`
2. `commit 96fa6899ea (HEAD, main)` означает:
    - `.git/HEAD` содержит `96fa6899ea (HEAD is “detached”)`
    - `.git/refs/heads/main` также содержит `96fa6899ea`
3. `commit 96fa6899ea (HEAD)` означает:
    - `.git/HEAD` содержит `96fa6899ea (HEAD is “detached”)`
    - `.git/refs/heads/main` либо содержит другой ID коммита, либо не существует

# Конфликты слияния: `<<<<<<< HEAD` просто запутывает.

Когда вы разрешаете конфликт слияния, то можете увидеть что-то вроде этого:

```text
<<<<<<< HEAD
def parse(input):    
	return input.split("\n")
=======
def parse(text):
	return text.split("\n\n")
>>>>>>> somebranch
```

Я нахожу `HEAD` в этом контексте чрезвычайно запутанным и в основном просто игнорирую его. Вот почему.

- Когда вы выполняете **слияние**, `HEAD` в конфликте слияния будет тем же, чем был `HEAD`, когда вы запускали `git merge`. Просто.
- Когда вы делаете **ребейз**, `HEAD` в конфликте слияния — это нечто совершенно иное: это **другой коммит**, поверх которого вы делаете ребейз. Так что это совершенно не то, чем был `HEAD`, когда вы запускали `git rebase`. Так происходит потому, что ребейз работает, сначала проверяя другой коммит, а затем многократно выбирая (`cherry-pick`) коммиты поверх него.

Аналогично, при слиянии и ребейзе меняются местами значения слов "наш" и "их".

Тот факт, что значение `HEAD` меняется в зависимости от того, делаю ли я ребейз или слияние, слишком запутан для меня, и я нахожу, что гораздо проще просто игнорировать `HEAD` полностью и использовать другой метод для выяснения того, какая часть кода является таковой.
# Resources

- [Как HEAD работает в git](https://www.dev-notes.ru/articles/git/how-head-works-in-git/)
- 