Индексы - это специальные объекты, которые ускоряют доступ к записям таблицы. Если их не использовать, то каждая строка будет последовательно извлекаться в результирующий набор, а потом фильтроваться (это называется полное сканирование)

# Типы индексов в SQL

## 1. Кластеризованные индексы (Clustered Index)

Кластеризованный индекс определяет физический порядок хранения строк в таблице. У таблицы может быть только один кластеризованный индекс, так как строки не могут быть одновременно расположены в нескольких порядках.

- **Особенности:**
	- В листьях (допустим что это B-Tree индекс, для упрощения) данного индекса лежат сами данные (прям строки таблиц), а не TID.
	- Может быть только ОДИН в таблице.
	- Определяет физический порядок данных в таблице.
	- Некластеризованных индексов можно накладывать сколько угодно на таблицу, а в листьях такого индекса будут лежать TID. 
	- Таблица без кластеризованного индекса называется кучей. В ней данные хранятся неупорядоченно.
    - Упорядочивает строки таблицы в соответствии с индексом.
    - Таблица с кластеризованным индексом называется кластеризованной таблицей.
    - Используется для ускорения запросов, которые возвращают диапазоны значений.
    - Пример: индексация первичного ключа.

```sql
-- Создание таблицы с кластеризованным индексом на столбце 'id'
CREATE TABLE Employees (
    id INT PRIMARY KEY,  -- Кластеризованный индекс создается автоматически, так как это PRIMARY KEY
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    department VARCHAR(50)
);

-- Явное создание кластеризованного индекса (MS SQL Server)
CREATE CLUSTERED INDEX idx_employees_id ON Employees (id);
```

## 2. Некластеризованные индексы (Non-Clustered Index)

Некластеризованный индекс создается отдельно от данных таблицы. Он содержит ключи индекса и указатели на фактические строки данных, что позволяет находить строки, не изменяя их физическое расположение.

- **Особенности:**
    
    - Может быть несколько некластеризованных индексов на одну таблицу.
    - Создаётся на определённом столбце или столбцах.
    - Быстрее для поиска конкретных значений, но медленнее для диапазонов значений.
    - Пример: индексирование столбцов, по которым часто выполняются запросы с фильтрацией.
        
```sql
-- Создание некластеризованного индекса на столбце 'last_name'
CREATE NONCLUSTERED INDEX idx_employees_last_name ON Employees (last_name);
```

## 3. **Уникальные индексы (Unique Index)**

Уникальные индексы не допускают дублирующихся значений в одном или нескольких столбцах.

- **Особенности:**
    
    - Гарантирует уникальность значений в столбце.
    - Может быть кластеризованным или некластеризованным.
    - Пример: индекс на столбце с уникальными данными (например, адреса электронной почты).

```sql
-- Создание уникального индекса на столбце 'email'
CREATE UNIQUE INDEX idx_employees_email ON Employees (email);
```

## 4. **Полнотекстовые индексы (Full-Text Index)**

Полнотекстовые индексы используются для поиска текста в больших текстовых полях, таких как `VARCHAR` или `TEXT`.

- **Особенности:**
    
    - Оптимизирует запросы на поиск текстовых данных.
    - Используется для поиска ключевых слов в больших текстовых полях.
    - Пример: поиск по текстовому полю в документах или статьях.
        
```sql
-- Сначала необходимо создать полнотекстовый каталог
CREATE FULLTEXT CATALOG ftCatalog AS DEFAULT;

-- Затем создать полнотекстовый индекс на столбце 'description'
CREATE FULLTEXT INDEX ON Employees(description) KEY INDEX PK_Employees;
```

## 5. **Составные индексы (Composite Index)**

Составные индексы создаются на нескольких столбцах одновременно.

- **Особенности:**
    
    - Используются для оптимизации запросов, которые фильтруют данные по нескольким столбцам.
    - Порядок столбцов в индексе важен.
    - Пример: индекс на комбинации `Фамилия` и `Имя`.
        
```sql
-- Создание составного индекса на столбцах 'first_name' и 'last_name'
CREATE INDEX idx_employees_name ON Employees (first_name, last_name);
```

## 6. **Индексы с фильтром (Filtered Index)**

Индексы с фильтром включают подмножество строк таблицы, основываясь на условии фильтрации.

- **Особенности:**
    
    - Используются для создания индекса на части данных, которые соответствуют определённому критерию.
    - Повышает производительность и уменьшает размер индекса.
    - Пример: индекс на столбце с условием `WHERE active = 1`.

```sql
-- Создание индекса с фильтром на активных сотрудниках
CREATE NONCLUSTERED INDEX idx_employees_active ON Employees (last_name) WHERE active = 1;
```

## 7. **Пространственные индексы (Spatial Index)**

Пространственные индексы используются для данных, связанных с географией, например, для координат GPS.

- **Особенности:**
    
    - Оптимизирует запросы на поиск данных в географических областях.
    - Пример: поиск ближайших объектов в определённом радиусе.

```sql
-- Создание таблицы с пространственными данными
CREATE TABLE Locations (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    location GEOGRAPHY
);

-- Создание пространственного индекса
CREATE SPATIAL INDEX idx_locations_location ON Locations(location);
```

## 8. **XML-индексы (XML Index)**

Используются для ускорения запросов по данным, хранящимся в формате XML.

- **Особенности:**
    
    - Оптимизируют запросы на извлечение данных из XML.
    - Пример: запросы к столбцам XML-типа.
        
```sql
-- Создание таблицы с XML-данными
CREATE TABLE XmlData (
    id INT PRIMARY KEY,
    data XML
);

-- Создание XML индекса
CREATE PRIMARY XML INDEX idx_xmldata_data ON XmlData(data);
```

## 9. **Bitmap-индексы (Bitmap Index)**

Используются в основном в хранилищах данных и системах OLAP. Эти индексы эффективны для столбцов с небольшим числом уникальных значений (например, пол, статус).

- **Особенности:**
    
    - Оптимальны для таблиц с большим количеством строк и столбцов с низкой кардинальностью.
    - Используются в аналитических запросах.
        
```sql
-- Создание bitmap индекса
CREATE BITMAP INDEX idx_employees_gender ON Employees (gender);
```
# Структуры данных

## Индексы на основе B-деревьев (B-Tree)

![[../../../_res/Pasted image 20240923103218.jpg]]

B-дерево — это структура данных самобалансирующегося дерева, которая часто используется в качестве алгоритма индексирования **в базах данных по умолчанию**. Каждый узел дерева состоит из набора ключей и указателей на дочерние узлы; хранение данных осуществляется в иерархической структуре. Деревья B-узлов упорядочены таким образом, что позволяют быстро выполнять поиск, вставку и удаление данных.

```sql
CREATE INDEX idx_users_name
ON users (name);
```

Подходит для диапазонных запросов, например:

```SQL
SELECT * FROM employees WHERE id BETWEEN 100 AND 200;
```

### Недостатки

- **Излишняя трата ресурсов**: B-деревья задействуют большой объём излишнего пространства, поскольку каждый узел в B-дереве содержит указатель на родительский и дочерний узлы.
- **Сложность**: алгоритмы, используемые для вставки, удаления и поиска данных в B-дереве, сложнее по сравнению с другими структурами данных. Это усложняет реализацию и поддержку B-деревьев.
- **Медленные обновления**: обновление данных в B-дереве может быть относительно медленным по сравнению с другими структурами данных. Каждая операция обновления требует множества операций доступа к диску, и этот процесс может быть медленным для больших B-деревьев.

### Как это работает

1. **Инициализация**: при создании B-дерева создаётся пустой корневой узел. Параметр, задающий максимальное количество ключей («порядок»), которые могут храниться в каждом узле, управляет B-порядком дерева.
2. **Вставка**: при добавлении нового узла в B-дерево алгоритм сначала подыскивает подходящий узел-лист, в который нужно вставить ключ. B-дерево разделяет заполненный узел-лист на два новых узла и перемещает медианный ключ в родительский узел. Пока не достигнут корневой узел, процесс разделения может распространяться по дереву. Благодаря этой процедуре дерево остаётся сбалансированным, а узлы-листья находятся на одинаковой высоте.
3. **Удаление**: когда ключ удаляется из B-дерева, алгоритм ищет узел, который изначально хранил ключ. Если узел-лист хранил ключ, то ключ извлекается и узел может нуждаться в перебалансировке. Алгоритм удаляет предшествующий или последующий лист после листа-узла, удалив ключ с ним, если ключ обнаружен не в узле-листе.
4. **Поиск**: в процессе поиска ключа в B-дереве алгоритм начинает с корневого узла и рекурсивно движется к веткам, пока не найдёт нужный узел-лист. Метод поиска сравнивает искомый ключ с ключами, содержащимися в каждом узле, а затем использует соответствующий указатель для перехода к дочернему узлу, в котором может находиться ключ. Этот процесс продолжается, пока не будет найден искомый ключ или пока не будет определено, что он отсутствует в дереве.
## Индексы на основе хэш-таблиц Hash-index

![[../../../_res/Pasted image 20240923112714.png]]

Хэш-индексы используют хэш-функции для преобразования значений в индексы. 

```sql
CREATE INDEX idx_users_id_hash ON users USING HASH (id);
```

Важно отметить, что не все СУБД поддерживают хэш-индексы. Например, MySQL **не поддерживает** создание хэш-индексов напрямую, но они могут быть **применены** в InnoDB для уникальных индексов автоматически.

Применение: Подходит для запросов типа:

```SQL
SELECT * FROM users WHERE username = 'johndoe';
```

Преимущества: Быстрая работа при точном совпадении значений.

### Недостатки

- **Ограниченные возможности поиска**: хэш-индексы предназначены для обработки только поисков равенства (например, «найти все записи, где столбец A равен значению»). Они плохо подходят для запросов диапазонов или сортировки.
- **Коллизии**: хэш-индексы могут иметь коллизии, при которых несколько ключей соответствуют одному хэш-значению. Это может привести к снижению производительности, поскольку базе данных нужно будет выполнять дополнительные операции для разрешения коллизий.
- **Непредсказуемые требования к размеру хранилища**: размер хэш-индекса невозможно предугадать, так как он зависит от количества уникальных значений в индексируемом столбце. Это усложняет планирование требований к размеру хранилища.
### Как это работает

1. Мы создадим хэш-функцию, получающую на входе пользовательский ID и генерирующую на выходе уникальный хэш-код. Хэш-функция должна быть спроектирована таким образом, чтобы генерировать равномерно распределённое множество хэш-кодов для равномерного распределения записей по корзинам в файле индекса. На практике хэш-функция может использовать для генерации хэш-кода различные методики, например, модульную арифметику или побитовые операции.
2. Мы создаём файл хэш-индекса, содержащий набор корзин (bucket), каждая из которых соответствует уникальному хэш-коду сгенерированному хэш-функцией. Каждая корзина содержит указатель на файл базы данных, содержащий записи для этого хэш-кода.
3. При выполнении запроса к значению запроса применяется хэш-функция для генерации хэш-кода. Затем хэш-код используется для нахождения соответствующей корзины в файле хэш-индекса. Записи с одинаковым хэш-кодом хранятся в одной корзине, поэтому мы можем просто просканировать записи в этой корзине и найти совпадающую запись/записи. Если присутствуют коллизии (то есть несколько записей с одинаковым хэш-кодом), то для их разрешения можно использовать техники наподобие создания цепочек или открытой адресации.
4. Чтобы вставить новую запись в хэш-индекс, мы применяем к значению ключа записи хэш-функцию, чтобы сгенерировать его хэш-код, а затем вставляем запись в соответствующую корзину в файле хэш-индекса. Если коллизии отсутствуют, вставку можно выполнить за постоянное время O(1), так как нам нужно всего лишь вычислить хэш-код и вставить запись в корзину. Если коллизии есть, нам может потребоваться проделать дополнительные операции, например, вставку записи в связанный список в корзине или проверку других корзин, пока не будет найден свободный слот.

## Индексы на основе битовых карт (Bitmap Index)

![[../../../_res/Pasted image 20240923104427.png]]

Битовые индексы используют битовые карты для представления наличия или отсутствия значений в строках таблицы.

```java
CREATE BITMAP INDEX idx_employees_status
ON employees (employment_status);
```

**Важное замечание:** базы данных, такие как MySQL и PostgreSQL, **не поддерживают** Bitmap индексы напрямую. Эти индексы обычно применяются в Oracle и некоторых других специализированных СУБД.

Допустим, у нас есть таблица сотрудников с колонкой `employment_status`:

| id  | name    | employment_status |
| --- | ------- | ----------------- |
| 1   | Alice   | Full-Time         |
| 2   | Bob     | Part-Time         |
| 3   | Charlie | Full-Time         |
| 4   | David   | Contract          |
| 5   | Eve     | Full-Time         |
Для этой таблицы мы можем построить Bitmap Index на основе колонки `employment_status`

| Row ID | Full-time | Part-Time | Contract |
| ------ | --------- | --------- | -------- |
| 1      | 1         | 0         | 0        |
| 2      | 0         | 1         | 0        |
| 3      | 1         | 0         | 0        |
| 4      | 0         | 0         | 1        |
| 5      | 1         | 0         | 0        |
- В столбце Full-Time стоят единицы в строках 1, 3 и 5, так как сотрудники Alice, Charlie и Eve работают полный рабочий день.
- В столбце Part-Time стоит единица только во 2-й строке, так как Bob работает на неполный рабочий день.
- В столбце Contract стоит единица в 4-й строке для David, работающего по контракту.

Применение: Эффективен для столбцов с небольшим количеством уникальных значений, например:

```sql
SELECT * FROM orders WHERE status = 'shipped';
```

Преимущества: Эффективен для поиска по статическим полям с ограниченным числом уникальных значений.

### Недостатки

- **Большой размер**: Bitmap-индексы могут быть большими, особенно при работе с крупными датасетами. Из-за этого они могут оказаться менее эффективными, чем другие методики индексирования.
- **Столбцы с высокой кардинальностью**: Bitmap-индексы неэффективны для столбцов с высокой кардинальностью, где количество уникальных значений очень высоко. В таких случаях bitmap-индексы могут становиться очень большими и не помещаться в памяти.
- **Смещённое распределение данных**: если данные смещены, у нескольких значений может быть гораздо более высокая частота, чем у других, и bitmap-индексы окажутся неэффективными. Это вызвано тем, что bitmap для наиболее частых значений становятся очень большими и могут доминировать в индексе.

### Как это работает

- Для создания bitmap-индекса столбца для каждого уникального значения столбца создаётся отдельный bitmap. Каждый bitmap имеет длину, равную количеству строк в таблице.
- Если значение присутствует в строке, соответствующему биту в bitmap присваивается значение 1, а если оно отсутствует, то присваивается значение 0. (Представьте таблицу, где столбец «Gender» имеет два уникальных значения, например, «Male» и «Female». Если этот столбец имеет bitmap-индекс, можно создать два bitmap, длина каждого из которых равна количеству строк в таблице. Когда в строке встречается «Male» или «Female», соответствующий бит в bitmap «Male» или «Female» получает значение 1, и наоборот. В случае отсутствия значения «Male» или «Female» соответствующему биту присваивается значение 0.)
- Чтобы выполнить запрос при помощи bitmap-индекса, соответствующие в запросе значения bitmap комбинируются при помощи побитовых операторов AND, OR и NOT. (например, если мы хотим найти все строки, где «Gender» равно «Male» И «Age» больше 30, нам сначала нужно получить bitmap «Male» и bitmap «Age > 30» из соответствующих индексов. Затем мы комбинируем эти два bitmap при помощи побитового оператора AND и получаем окончательный bitmap только с единицами в тех позициях, где оба условия истинны. Затем окончательный bitmap используется для получения из таблицы строк, удовлетворяющих запросу.)

## Индексы на основе реверсированных файлов (Reverse Key Index)

Описание: Индексы, которые хранят данные в обратном порядке. Это может помочь распределить нагрузки при вставке данных.

```sql
CREATE INDEX idx_customers_id_reverse
ON customers (customer_id)
REVERSE;
```

Обычный индекс:

| customer_id | Indexed Key |
| ----------- | ----------- |
| 1234        | 1234        |
| 2345        | 2345        |
| 3456        | 3456        |
| 4567        | 4567        |

Реверсированный индекс:

| customer_id | Reversed Key |
| ----------- | ------------ |
| 1234        | 4321         |
| 2345        | 5432         |
| 3456        | 6543         |
| 4567        | 7654         |
- В обычном индексе ключи хранятся так, как они есть: 1234, 2345 и так далее.
- В реверсированном индексе ключи перед индексацией реверсируются: 1234 становится 4321, 2345 — 5432 и так далее.

Это помогает сбалансировать нагрузку на дерево индекса, особенно когда ключи имеют последовательный характер.

Когда значения ключей возрастают последовательно (например, `1`, `2`, `3`, и так далее), вставки новых записей всегда будут происходить в одну и ту же часть B-дерева индекса. Это создает **горячие точки**, где постоянно происходит обновление узлов дерева в одной и той же области.

Применение: 

Реверсированные индексы полезны, когда у вас есть последовательные ключи, которые могут привести к горячим точкам. Например:

- Автоинкрементные идентификаторы.
- Время или даты (если они идут по возрастанию).
- Последовательные числовые или символьные данные.

Преимущества:

- Равномерное распределение ключей по индексу: Поскольку реверсированные значения не следуют друг за другом, вставки распределяются более равномерно по разным узлам B-дерева.
- Улучшенная производительность при вставке: Меньше блокировок и коллизий при вставке новых записей, что снижает нагрузку на систему и повышает производительность.

Недостатки:

Реверсированные индексы не подходят для поиска по диапазонам (например, найти все идентификаторы от 1000 до 2000), так как реверсирование нарушает естественный порядок значений.

## Индексы на основе полного текста (Full-Text Index)

Индексы, которые оптимизированы для поиска текста, включающего слова и фразы.

```sql
CREATE FULLTEXT INDEX idx_articles_content
ON articles (content);
```

Здесь создается Full-Text Index для колонки `content` в таблице `articles`, что позволит эффективно искать ключевые слова в тексте статей.

После создания Full-Text индекса, вы можете выполнять поиск по тексту с использованием оператора `MATCH ... AGAINST`.

```java
SELECT * FROM articles
WHERE MATCH(content) AGAINST('технологии' IN NATURAL LANGUAGE MODE);
```

Этот запрос найдет все строки, где в колонке `content` упоминается слово "технологии".

Применение:

- Большие объемы текста: Например, для статей, блогов, комментариев.
- Поиск ключевых слов или фраз: Когда нужно найти упоминания определенных слов в текстовых данных.
- Эффективный поиск: В отличие от обычных индексов, Full-Text индексы намного быстрее для поиска по длинным строкам текста.

MySQL, PostgreSQL и Microsoft SQL Server поддерживают Full-Text индексы, но их реализация может различаться. Например, PostgreSQL использует **tsvector** и **tsquery** для создания полнотекстовых индексов.

Преимущества: Позволяет выполнять сложные текстовые поисковые запросы.

### Недостатки

1. **Сниженная скорость индексирования и поиска**: полнотекстовое индексирование может быть более сложным, чем другие техники индексирования, что может приводить к снижению скорости индексирования и поиска, особенно в больших базах данных со множеством текстовых полей.
2. **Подходит не для всех типов данных**: полнотекстовое индексирование лучше всего подходит для баз данных, содержащих большие объёмы текстовых данных. Оно может и не быть наиболее эффективной техникой для баз данных, по большей мере, для содержащих числовую или другую нетекстовую информацию.
3. **Зависимость от языка**: полнотекстовое индексирование может быть не очень эффективно для многоязычных баз данных, поскольку требует отдельных индексов для каждого языка и может оказаться неспособным справиться с нюансами различных языков и систем письменности.

### Как это работает

1. **Токенизация**: текстовое содержимое индексируемого столбца разбивается на отдельные слова или токены, которые затем сохраняются в индекс. При создании полнотекстового индекса система базы данных сначала анализирует текстовое содержимое индексируемых столбцов, а затем разбивает его на отдельные слова или токены. Этот процесс называется токенизацией, он может включать в себя фильтрацию игнорируемых слов (например, «the», «and», «or») и выделение корней (редуцирование слов до их базовой формы).
2. **Индексирование**: затем токены индексируются при помощи специальной структуры данных, например, B-дерева или инвертированного индекса. Структура индекса обеспечивает возможность эффективного поиска и извлечения строк, содержащих указанные токены.
3. **Построение и выполнение запросов**: система базы данных использует полнотекстовый индекс для поиска строк, содержащих релевантные токены. В процессе поиска токены запроса сопоставляются с индексированными токенами и извлекаются строки, соответствующие запросу. Результаты поиска можно ранжировать на основании их релевантности запросу, который вычисляется при помощи алгоритмов наподобие TF-IDF (term frequency-inverse document frequency).

## Индексы на основе пространственных данных (Spatial Index)

Описание: Индексы, используемые для данных, представляющих географические или пространственные объекты.

```sql
CREATE TABLE locations (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100),
    coordinates POINT NOT NULL,
    SPATIAL INDEX idx_coordinates (coordinates)
);
```

После создания индекса **можно выполнять пространственные запросы**, используя функции для работы с геометрическими данными.

```sql
SELECT name
FROM locations
WHERE MBRContains(ST_GeomFromText('POLYGON((x1 y1, x2 y2, x3 y3, x4 y4, x1 y1))'), coordinates);
```

- MBRContains — проверяет, находится ли точка внутри минимального ограничивающего прямоугольника (bounding box).
- ST_GeomFromText — создает геометрический объект из текста в формате WKT (Well-Known Text).

Применение:

- Географические данные: Например, для хранения координат местоположений, дорог, границ.
- Пространственные запросы: Когда нужно найти объекты, находящиеся в пределах области, пересекающие другие объекты и т.д.
- Быстрый поиск по координатам: Для ускорения выполнения запросов, связанных с географическими данными, такими как поиск по радиусу или области.

- MySQL: Поддерживает создание пространственных индексов для типов данных, таких как `POINT`, `LINESTRING`, `POLYGON`.
- PostgreSQL (с расширением PostGIS): Поддерживает пространственные индексы через GiST и SP-GiST индексы.
- Oracle: Поддерживает пространственные индексы через механизм Oracle Spatial.
- SQL Server: Поддерживает пространственные индексы для данных типа `GEOGRAPHY` и `GEOMETRY`.

Преимущества: Эффективен для запросов с пространственными данными.

Недостатки: Могут быть менее эффективны для текстовых или числовых запросов.

## Индексы на основе выражений (Expression Index)

Описание: Индексы создаются на основе вычислений или функций, применяемых к столбцам.

```sql
CREATE TABLE products (
    product_id INT PRIMARY KEY,
    price DECIMAL(10, 2),
    discount DECIMAL(10, 2)
);

CREATE INDEX idx_discounted_price ON products(price - discount);
```

Ускоряет запросы, использующие вычисления:

```sql
SELECT * FROM products WHERE price - discount > 100;

CREATE INDEX idx_lower_name
ON users (LOWER(name));

CREATE INDEX idx_upper_email
ON customers ((UPPER(email)));
```

Преимущества: Позволяет оптимизировать запросы с вычислениями.

Недостатки: Может занимать дополнительное пространство и потребовать пересчета при изменении данных.

## GiST (Generalized Search Tree, обобщённое поисковое дерево)

![[../../../_res/Pasted image 20240923113957.jpg]]

Это техника индексирования баз данных, которая может использоваться для индексирования сложных типов данных, например, геометрических объектов, текста или массивов. Это сбалансированная древовидная структура, состоящая из узлов с множественными дочерними узлами. Каждый узел описывает диапазон или множество значений и связан с предикативной функцией, проверяющей, принадлежит ли значение диапазону или множеству. Предикативная функция зависит от типа индексируемых данных и может быть подстроена под разные типы данных.

### Недостатки

1. **Сниженная скорость вставок и обновлений**: структуры индексирования GiST могут быть сложнее, чем традиционные структуры индексирования, что может привести к снижению скорости операций вставки и обновления.
2. **Больше дискового пространства**: структуры индексирования GiST могут требовать больше дискового пространства, чем другие методики индексирования, поскольку хранят дополнительную информацию для поддержки различных типов поиска.
3. **Подходит не для всех типов данных**: GiST оптимизирован под индексирование сложных типов данных, например, пространственных данных, однако может быть не лучшим выбором для индексирования более простых типов данных, например, целочисленных значений или строк.
4. **Повышенные затраты на поддержку**: из-за сложности реализации индексы GiST требуют больше обслуживания по сравнению с традиционными индексами.

### Как это работает  

1. Зададим множество предикатов и функций преобразования, специфичных для индексируемого типа пространственных данных. В данном случае мы должны задать предикат, проверяющий, находится ли заданная точка в ограничивающем прямоугольнике, описанном узлом в индексе, и функцию преобразования, преобразующую точку в набор ключей на основании её позиции в ограничивающем прямоугольнике.
2. Создаём файл индекса GiST, состоящий из множества узлов, каждый из которых описывает ограничивающий прямоугольник, охватывающий диапазон координат.  
      
    Корневой узел описывает весь диапазон координат в таблице базы данных, а каждый дочерний узел описывает подмножество этого диапазона.  
      
    Каждый узел связывается с предикативной функцией и функцией преобразования, специфичными для индексируемого типа пространственных данных.
3. При выполнении запроса значение в запросе преобразуется при помощи функции преобразования в набор ключей.  
      
    Затем ключи сравниваются с предикатами, связанными с каждым узлом индекса, начиная с корневого узла.  
      
    Поиск продолжается вниз по дереву и выбирает дочерний узел, содержащий значение из запроса.  
      
    Процесс повторяется, пока не будет достигнут узел-лист, содержащий элементы индекса, соответствующие значению в запросе.
4. Для вставки в индекс нового города координаты города сначала при помощи функции преобразования преобразуются в набор ключей.  
      
    Затем ключи вставляются в соответствующие узлы индекса, начиная с корневого узла.  
      
    Если узел заполнен, выполняется операция разделения для создания двух новых узлов и ключи распределяются между узлами.


# Источники

- [Как устроено индексирование баз данных](https://habr.com/ru/companies/ruvds/articles/724066/)
- [SQL Indexing and Tuning e-Book](https://use-the-index-luke.com/)
- 


