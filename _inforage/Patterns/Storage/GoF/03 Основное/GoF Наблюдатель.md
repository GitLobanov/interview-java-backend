---
Определение: Создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах. Определяет связь "один ко многим" между объектами, так что когда один объект (субъект или публикатор) изменяет своё состояние, все зависимые объекты (наблюдатели или подписчики) автоматически уведомляются и обновляются.
Тип:
  - Поведенческий
пример: Используется в чатах, где подписчики получают обновления при отправке сообщения.
---
Издатель-Подписчик, Слушатель, Observer
### Описание

В основе паттерна "Наблюдатель" лежат два ключевых интерфейса: интерфейс Subject и интерфейс Observer. Интерфейс Subject объявляет методы, отвечающие за управление объектами-наблюдателями, включая их регистрацию, удаление и уведомление из публикатора событий. В свою очередь, интерфейс Observer объявляет метод update, который конкретные объекты наблюдатели реализует для реагирования на изменения состояния объекта-публикатора.

```java
public interface Subject {
	void registerObserver(Observer observer);
	void removeObserver(Observer observer);
	void notifyObservers();
}

public interface Observer {
	void update (String message);
}
```

Конкретный класс публикатора реализует интерфейс Subject и служит центральной точкой, к которой наблюдатели могут присоединяться для получения уведомлений. Публикатор поддерживает список зарегистрированных в нем наблюдателей и уведомляет их о любых изменениях состояния. 
### Пример

Сайт показа погоды. В этом примере у нас есть класс `WeatherStation`, который представляет собой источник данных о погоде. Этот класс получает данные от внешнего API и уведомляет подписчиков (наблюдателей) об изменениях. Наблюдатели могут быть разными компонентами сайта, такими как отображение температуры, влажности и других погодных условий.

Определим интерфейс для наблюдателей, который будет использоваться для получения обновлений.

```java
interface Observer {
    void update(float temperature, float humidity, float pressure);
}
```

Интерфейс для класса `WeatherStation`, который позволяет подписываться, отписываться и уведомлять наблюдателей.

```java
interface Subject {
    void registerObserver(Observer observer);
    void removeObserver(Observer observer);
    void notifyObservers();
}
```

Класс `WeatherStation` реализует интерфейс `Subject` и содержит методы для получения данных от внешнего API.

```java
class WeatherStation implements Subject {
    private List<Observer> observers;
    private float temperature;
    private float humidity;
    private float pressure;

    public WeatherStation() {
        observers = new ArrayList<>();
    }

    @Override
    public void registerObserver(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }

    @Override
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(temperature, humidity, pressure);
        }
    }

    // Метод для получения данных от внешнего API и обновления состояния
    public void fetchWeatherData() {
        // Симуляция получения данных от внешнего API
        // Например, используем API, чтобы получить данные и обновить их
        this.temperature = 22.5f;  // Пример данных
        this.humidity = 60.0f;     // Пример данных
        this.pressure = 1013.0f;   // Пример данных
        
        notifyObservers(); // Уведомляем наблюдателей об обновлении
    }
}
```

Создаем конкретные наблюдатели для отображения погоды.

```java
class TemperatureDisplay implements Observer {
    @Override
    public void update(float temperature, float humidity, float pressure) {
        System.out.println("Temperature Display: Temperature is " + temperature + "°C");
    }
}

class HumidityDisplay implements Observer {
    @Override
    public void update(float temperature, float humidity, float pressure) {
        System.out.println("Humidity Display: Humidity is " + humidity + "%");
    }
}

class PressureDisplay implements Observer {
    @Override
    public void update(float temperature, float humidity, float pressure) {
        System.out.println("Pressure Display: Pressure is " + pressure + " hPa");
    }
}
```

Теперь мы можем использовать созданные классы для наблюдения за изменениями погоды.

```java
public class WeatherApp {
    public static void main(String[] args) {
        WeatherStation weatherStation = new WeatherStation();

        TemperatureDisplay tempDisplay = new TemperatureDisplay();
        HumidityDisplay humidityDisplay = new HumidityDisplay();
        PressureDisplay pressureDisplay = new PressureDisplay();

        weatherStation.registerObserver(tempDisplay);
        weatherStation.registerObserver(humidityDisplay);
        weatherStation.registerObserver(pressureDisplay);

        // Симулируем обновление данных погоды
        weatherStation.fetchWeatherData();
    }
}
```

### Шаги реализации

1. Разбить функциональность на две части: независимое ядро и опциональные зависимые части. Независимое ядро станет издателем. Зависимые части станут подписчиками.
    
2. Создайте интерфейс подписчиков. Обычно в нём достаточно определить единственный метод оповещения.
    
3. Создайте интерфейс издателей и опишите в нём операции управления подпиской. Помните, что издатель должен работать только с общим интерфейсом подписчиков.
    
4. Вам нужно решить, куда поместить код ведения подписки, ведь он обычно бывает одинаков для всех типов издателей. Самый очевидный способ — вынести этот код в промежуточный абстрактный класс, от которого будут наследоваться все издатели.
    
    Но если вы интегрируете паттерн в существующие классы, то создать новый базовый класс может быть затруднительно. В этом случае вы можете поместить логику подписки во вспомогательный объект и делегировать ему работу из издателей.
    
5. Создайте классы конкретных издателей. Реализуйте их так, чтобы после каждого изменения состояния они отправляли оповещения всем своим подписчикам.
    
6. Реализуйте метод оповещения в конкретных подписчиках. Не забудьте предусмотреть параметры, через которые издатель мог бы отправлять какие-то данные, связанные с происшедшим событием.
    
    Возможен и другой вариант, когда подписчик, получив оповещение, сам возьмёт из объекта издателя нужные данные. Но в этом случае вы будете вынуждены привязать класс подписчика к конкретному классу издателя.
    
7. Клиент должен создавать необходимое количество объектов подписчиков и подписывать их у издателей.

### Отношения с другими паттернами

- [[GoF Цепочка обязанностей]], [[GoF Команда]], [[GoF Посредник]] и [[GoF Наблюдатель]] показывают различные способы работы отправителей запросов с их получателями:
    
    - _Цепочка обязанностей_ передаёт запрос последовательно через цепочку потенциальных получателей, ожидая, что какой-то из них обработает запрос.
    - _Команда_ устанавливает косвенную одностороннюю связь от отправителей к получателям.
    - _Посредник_ убирает прямую связь между отправителями и получателями, заставляя их общаться опосредованно, через себя.
    - _Наблюдатель_ передаёт запрос одновременно всем заинтересованным получателям, но позволяет им динамически подписываться или отписываться от таких оповещений.
- Разница между [[GoF Посредник]] и **наблюдателем** не всегда очевидна. Чаще всего они выступают как конкуренты, но иногда могут работать вместе.
    
    Цель _Посредника_ — убрать обоюдные зависимости между компонентами системы. Вместо этого они становятся зависимыми от самого посредника. С другой стороны, цель _Наблюдателя_ — обеспечить динамическую одностороннюю связь, в которой одни объекты косвенно зависят от других.
    
    Довольно популярна реализация _Посредника_ при помощи _Наблюдателя_. При этом объект посредника будет выступать издателем, а все остальные компоненты станут подписчиками и смогут динамически следить за событиями, происходящими в посреднике. В этом случае трудно понять, чем же отличаются оба паттерна.
    
    Но _Посредник_ имеет и другие реализации, когда отдельные компоненты жёстко привязаны к объекту посредника. Такой код вряд ли будет напоминать _Наблюдателя_, но всё же останется _Посредником_.
    
    Напротив, в случае реализации посредника с помощью _Наблюдателя_ представим такую программу, в которой каждый компонент системы становится издателем. Компоненты могут подписываться друг на друга, в то же время не привязываясь к конкретным классам. Программа будет состоять из целой сети _Наблюдателей_, не имея центрального объекта-_Посредника_.