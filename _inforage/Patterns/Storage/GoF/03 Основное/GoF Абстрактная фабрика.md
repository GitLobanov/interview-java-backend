---
Определение: Позволяет создавать семейства связанных объектов, не указывая их конкретный класс
Тип:
  - Порождающий
Пример: "Производство мебели поставляет комплекты: столы и стулья из одного стиля."
---
Abstract Factory

![[../../../../../_res/Pasted image 20241001185451.png]]
### Проблема

Представьте, что пишем симулятор мебельного магазина. Код содержит:

1. Семейство зависимых продуктов. Скажем, `Кресло` + `Диван` + `Столик`.
2. Несколько вариаций этого семейства. Например, продукты `Кресло`, `Диван` и `Столик` представлены в трёх разных стилях: `Ар-деко`, `Викторианском` и `Модерне`.

Вам нужно, чтобы объекты продуктов можно было легко комбинировать с другими продуктами из того же семейства. Это важно, потому что клиенты расстраиваются, когда получают мебель, которая не подходит друг к другу.  

Кроме того, вы не хотите каждый раз изменять существующий код при добавлении новых продуктов или семейств в программу. Поставщики часто обновляют свои каталоги, и вы бы не хотели постоянно менять уже написанный код, когда появляются новые модели мебели.
### Решение 

Для начала паттерн Абстрактная фабрика предлагает выделить общие интерфейсы для отдельных продуктов, составляющих семейства. Так, все вариации кресел получат общий интерфейс `Кресло`, все диваны реализуют интерфейс `Диван` и так далее.

Далее вы создаёте _абстрактную фабрику_ — общий интерфейс, который содержит методы создания всех продуктов семейства (например, `создатьКресло`, `создатьДиван` и `создатьСтолик`). Эти операции должны возвращать **абстрактные** типы продуктов, представленные интерфейсами, которые мы выделили ранее — `Кресла`, `Диваны` и `Столики`.

Как насчёт вариаций продуктов? Для каждой вариации семейства продуктов мы должны создать свою собственную фабрику, реализовав абстрактный интерфейс. Фабрики создают продукты одной вариации. Например, `ФабрикаМодерн` будет возвращать только `КреслаМодерн`,`ДиваныМодерн` и `СтоликиМодерн`.
### Пример

Для примера, предположим, что мы разрабатываем приложение для изучения иностранных языков, и нам нужно создать наборы ресурсов для изучения различных языков (например, английского и испанского). Каждый набор ресурсов может включать в себя такие компоненты, как учебник, словарь и аудио-курс.

```java
// Интерфейс учебника
interface Textbook {
    void getTitle();
}

// Интерфейс словаря
interface Dictionary {
    void lookup(String word);
}

// Интерфейс аудио-курса
interface AudioCourse {
    void play();
}
```

```java
// Учебник для английского языка
class EnglishTextbook implements Textbook {
    @Override
    public void getTitle() {
        System.out.println("English Textbook: 'Mastering English'");
    }
}

// Словарь для английского языка
class EnglishDictionary implements Dictionary {
    @Override
    public void lookup(String word) {
        System.out.println("Looking up English word: " + word);
    }
}

// Аудио-курс для английского языка
class EnglishAudioCourse implements AudioCourse {
    @Override
    public void play() {
        System.out.println("Playing English audio course...");
    }
}
```

Теперь создадим аналогичные реализации для испанского языка:

```java
// Учебник для испанского языка
class SpanishTextbook implements Textbook {
    @Override
    public void getTitle() {
        System.out.println("Spanish Textbook: 'Dominando el Español'");
    }
}

// Словарь для испанского языка
class SpanishDictionary implements Dictionary {
    @Override
    public void lookup(String word) {
        System.out.println("Looking up Spanish word: " + word);
    }
}

// Аудио-курс для испанского языка
class SpanishAudioCourse implements AudioCourse {
    @Override
    public void play() {
        System.out.println("Playing Spanish audio course...");
    }
}
```

Теперь определим интерфейс абстрактной фабрики, которая будет создавать наборы продуктов:

```java
// Интерфейс абстрактной фабрики
interface LanguageResourceFactory {
    Textbook createTextbook();
    Dictionary createDictionary();
    AudioCourse createAudioCourse();
}
```

Теперь создадим конкретные фабрики для английского и испанского языков:

```java
// Фабрика ресурсов для английского языка
class EnglishResourceFactory implements LanguageResourceFactory {
    @Override
    public Textbook createTextbook() {
        return new EnglishTextbook();
    }

    @Override
    public Dictionary createDictionary() {
        return new EnglishDictionary();
    }

    @Override
    public AudioCourse createAudioCourse() {
        return new EnglishAudioCourse();
    }
}

// Фабрика ресурсов для испанского языка
class SpanishResourceFactory implements LanguageResourceFactory {
    @Override
    public Textbook createTextbook() {
        return new SpanishTextbook();
    }

    @Override
    public Dictionary createDictionary() {
        return new SpanishDictionary();
    }

    @Override
    public AudioCourse createAudioCourse() {
        return new SpanishAudioCourse();
    }
}
```
### Шаги реализации

1. Создайте таблицу соотношений типов продуктов к вариациям семейств продуктов.
2. Сведите все вариации продуктов к общим интерфейсам.
3. Определите интерфейс абстрактной фабрики. Он должен иметь фабричные методы для создания каждого из типов продуктов.
4. Создайте классы конкретных фабрик, реализовав интерфейс абстрактной фабрики. Этих классов должно быть столько же, сколько и вариаций семейств продуктов.
5. Измените код инициализации программы так, чтобы она создавала определённую фабрику и передавала её в клиентский код.
6. Замените в клиентском коде участки создания продуктов через конструктор вызовами соответствующих методов фабрики.

### Отношения с другими паттернами

- Многие архитектуры начинаются с применения [[GoF Фабричный метод]]  (более простого и расширяемого через подклассы) и эволюционируют в сторону **абстрактной фабрики**, [[GoF Прототип|Прототипа]] или [[GoF Строитель|Строителя]] (более гибких, но и более сложных).
    
- [[GoF Строитель]] концентрируется на построении сложных объектов шаг за шагом. **Абстрактная фабрика** специализируется на создании семейств связанных продуктов. _Строитель_ возвращает продукт только после выполнения всех шагов, а _Абстрактная фабрика_ возвращает продукт сразу же.
    
- Классы **абстрактной фабрики** чаще всего реализуются с помощью [[GoF Фабричный метод]], хотя они могут быть построены и на основе [[GoF Прототип]]. [[../01 Примеры/EX. Абстрактная фабрика при помощи паттерна Прототип]]
    
- **Абстрактная фабрика** может быть использована вместо [[GoF Фасад]] для того, чтобы скрыть платформо-зависимые классы.
    
- **Абстрактная фабрика** может работать совместно с [[GoF Мост|Мостом]]. Это особенно полезно, если у вас есть абстракции, которые могут работать только с некоторыми из реализаций. В этом случае фабрика будет определять типы создаваемых абстракций и реализаций.
    
- **Абстрактная фабрика**, [[GoF Строитель]] и [[GoF Прототип]] могут быть реализованы при помощи [[GoF Одиничка]].